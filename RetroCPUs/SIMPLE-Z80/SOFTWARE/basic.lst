0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0017   0000             ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0018   0000             ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0019   0000             ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0020   0000             ; the original ROM code (checksum A934H). PA
0021   0000             
0022   0000             ; GENERAL EQUATES
0023   0000             
0024   0000             CTRLC   .EQU    03H             ; Control "C"
0025   0000             CTRLG   .EQU    07H             ; Control "G"
0026   0000             BKSP    .EQU    08H             ; Back space
0027   0000             LF      .EQU    0AH             ; Line feed
0028   0000             CS      .EQU    0CH             ; Clear screen
0029   0000             CR      .EQU    0DH             ; Carriage return
0030   0000             CTRLO   .EQU    0FH             ; Control "O"
0031   0000             CTRLQ	.EQU	11H		        ; Control "Q"
0032   0000             CTRLR   .EQU    12H             ; Control "R"
0033   0000             CTRLS   .EQU    13H             ; Control "S"
0034   0000             CTRLU   .EQU    15H             ; Control "U"
0035   0000             ESC     .EQU    1BH             ; Escape
0036   0000             DEL     .EQU    7FH             ; Delete
0037   0000             
0038   0000             ; BASIC WORK SPACE LOCATIONS
0039   0000             
0040   0000             WRKSPC  .EQU    2045H             ; BASIC Work space
0041   0000             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0042   0000             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0043   0000             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0044   0000             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0045   0000             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0046   0000             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0047   0000             DIV3    .EQU    WRKSPC+12H           ; <-   be
0048   0000             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0049   0000             SEED    .EQU    WRKSPC+17H           ; Random number seed
0050   0000             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0051   0000             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0052   0000             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0053   0000             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0054   0000             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0055   0000             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0056   0000             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0057   0000             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0058   0000             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0059   0000             LINESN  .EQU    WRKSPC+48H           ; Lines number
0060   0000             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0061   0000             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0062   0000             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0063   0000             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0064   0000             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0065   0000             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0066   0000             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0067   0000             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0068   0000             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0069   0000             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0070   0000             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0071   0000             STACK   .EQU    WRKSPC+66H           ; Initial stack
0072   0000             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0073   0000             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0074   0000             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0075   0000             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0076   0000             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0077   0000             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0078   0000             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0079   0000             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0080   0000             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0081   0000             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0082   0000             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0083   0000             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0084   0000             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0085   0000             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0086   0000             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0087   0000             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0088   0000             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0089   0000             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0090   0000             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0091   0000             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0092   0000             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0093   0000             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0094   0000             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0095   0000             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0096   0000             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0097   0000             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0098   0000             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0099   0000             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0100   0000             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0101   0000             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0102   0000             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0103   0000             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0104   0000             
0105   0000             ; BASIC ERROR CODE VALUES
0106   0000             
0107   0000             NF      .EQU    00H             ; NEXT without FOR
0108   0000             SN      .EQU    02H             ; Syntax error
0109   0000             RG      .EQU    04H             ; RETURN without GOSUB
0110   0000             OD      .EQU    06H             ; Out of DATA
0111   0000             FC      .EQU    08H             ; Function call error
0112   0000             OV      .EQU    0AH             ; Overflow
0113   0000             OM      .EQU    0CH             ; Out of memory
0114   0000             UL      .EQU    0EH             ; Undefined line number
0115   0000             BS      .EQU    10H             ; Bad subscript
0116   0000             DD      .EQU    12H             ; Re-DIMensioned array
0117   0000             DZ      .EQU    14H             ; Division by zero (/0)
0118   0000             ID      .EQU    16H             ; Illegal direct
0119   0000             TM      .EQU    18H             ; Type miss-match
0120   0000             OS      .EQU    1AH             ; Out of string space
0121   0000             LS      .EQU    1CH             ; String too long
0122   0000             ST      .EQU    1EH             ; String formula too complex
0123   0000             CN      .EQU    20H             ; Can't CONTinue
0124   0000             UF      .EQU    22H             ; UnDEFined FN function
0125   0000             MO      .EQU    24H             ; Missing operand
0126   0000             HX      .EQU    26H             ; HEX error
0127   0000             BN      .EQU    28H             ; BIN error
0128   0000             
0129   0150                     .ORG    00150H
0130   0150             
0131   0150 C3 56 01    COLD:   JP      STARTB          ; Jump for cold start
0132   0153 C3 F4 01    WARM:   JP      WARMST          ; Jump for warm start
0133   0156             STARTB: 
0134   0156 DD 21 00 00         LD      IX,0            ; Flag cold start
0135   015A C3 61 01            JP      CSTART          ; Jump to initialise
0136   015D             
0137   015D 07 0A               .WORD   DEINT           ; Get integer -32768 to 32767
0138   015F 7D 11               .WORD   ABPASS          ; Return integer in AB
0139   0161             
0140   0161             
0141   0161 21 45 20    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0142   0164 F9                  LD      SP,HL           ; Set up a temporary stack
0143   0165 C3 9C 1D            JP      INITST          ; Go to initialise
0144   0168             
0145   0168 11 2E 04    INIT:   LD      DE,INITAB       ; Initialise workspace
0146   016B 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0147   016D 21 45 20            LD      HL,WRKSPC       ; Into workspace RAM
0148   0170 1A          COPY:   LD      A,(DE)          ; Get source
0149   0171 77                  LD      (HL),A          ; To destination
0150   0172 23                  INC     HL              ; Next destination
0151   0173 13                  INC     DE              ; Next source
0152   0174 05                  DEC     B               ; Count bytes
0153   0175 C2 70 01            JP      NZ,COPY         ; More to move
0154   0178 F9                  LD      SP,HL           ; Temporary stack
0155   0179 CD 2F 06            CALL    CLREG           ; Clear registers and stack
0156   017C CD FD 0B            CALL    PRNTCRLF        ; Output CRLF
0157   017F 32 EF 20            LD      (BUFFER+72+1),A ; Mark end of buffer
0158   0182 32 3E 21            LD      (PROGST),A      ; Initialise program area
0159   0185 21 43 02    MSIZE:  LD      HL,MEMMSG       ; Point to message
0160   0188 CD 9B 12            CALL    PRS             ; Output "Memory size"
0161   018B CD 4C 06            CALL    PROMPT          ; Get input with '?'
0162   018E CD 55 09            CALL    GETCHR          ; Get next character
0163   0191 B7                  OR      A               ; Set flags
0164   0192 C2 AA 01            JP      NZ,TSTMEM       ; If number - Test if RAM there
0165   0195 21 A2 21            LD      HL,STLOOK       ; Point to start of RAM
0166   0198 23          MLOOP:  INC     HL              ; Next byte
0167   0199 7C                  LD      A,H             ; Above address FFFF ?
0168   019A B5                  OR      L
0169   019B CA BC 01            JP      Z,SETTOP        ; Yes - 64K RAM
0170   019E 7E                  LD      A,(HL)          ; Get contents
0171   019F 47                  LD      B,A             ; Save it
0172   01A0 2F                  CPL                     ; Flip all bits
0173   01A1 77                  LD      (HL),A          ; Put it back
0174   01A2 BE                  CP      (HL)            ; RAM there if same
0175   01A3 70                  LD      (HL),B          ; Restore old contents
0176   01A4 CA 98 01            JP      Z,MLOOP         ; If RAM - test next byte
0177   01A7 C3 BC 01            JP      SETTOP          ; Top of RAM found
0178   01AA             
0179   01AA CD 21 0A    TSTMEM: CALL    ATOH            ; Get high memory into DE
0180   01AD B7                  OR      A               ; Set flags on last byte
0181   01AE C2 FD 04            JP      NZ,SNERR        ; ?SN Error if bad character
0182   01B1 EB                  EX      DE,HL           ; Address into HL
0183   01B2 2B                  DEC     HL              ; Back one byte
0184   01B3 3E D9               LD      A,11011001B     ; Test byte
0185   01B5 46                  LD      B,(HL)          ; Get old contents
0186   01B6 77                  LD      (HL),A          ; Load test byte
0187   01B7 BE                  CP      (HL)            ; RAM there if same
0188   01B8 70                  LD      (HL),B          ; Restore old contents
0189   01B9 C2 85 01            JP      NZ,MSIZE        ; Ask again if no RAM
0190   01BC             
0191   01BC 2B          SETTOP: DEC     HL              ; Back one byte
0192   01BD 11 A1 21            LD      DE,STLOOK-1     ; See if enough RAM
0193   01C0 CD C5 07            CALL    CPDEHL          ; Compare DE with HL
0194   01C3 DA 85 01            JP      C,MSIZE         ; Ask again if not enough RAM
0195   01C6 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0196   01C9 22 F4 20            LD      (LSTRAM),HL     ; Save last available RAM
0197   01CC 19                  ADD     HL,DE           ; Allocate string space
0198   01CD 22 9F 20            LD      (STRSPC),HL     ; Save string space
0199   01D0 CD 0A 06            CALL    CLRPTR          ; Clear program area
0200   01D3 2A 9F 20            LD      HL,(STRSPC)     ; Get end of memory
0201   01D6 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0202   01D9 19                  ADD     HL,DE           ; Adjust HL
0203   01DA 11 3E 21            LD      DE,PROGST       ; Start of program text
0204   01DD 7D                  LD      A,L             ; Get LSB
0205   01DE 93                  SUB     E               ; Adjust it
0206   01DF 6F                  LD      L,A             ; Re-save
0207   01E0 7C                  LD      A,H             ; Get MSB
0208   01E1 9A                  SBC     A,D             ; Adjust it
0209   01E2 67                  LD      H,A             ; Re-save
0210   01E3 E5                  PUSH    HL              ; Save bytes free
0211   01E4 21 0C 02            LD      HL,SIGNON       ; Sign-on message
0212   01E7 CD 9B 12            CALL    PRS             ; Output string
0213   01EA E1                  POP     HL              ; Get bytes free back
0214   01EB CD 3E 19            CALL    PRNTHL          ; Output amount of free memory
0215   01EE 21 FD 01            LD      HL,BFREE        ; " Bytes free" message
0216   01F1 CD 9B 12            CALL    PRS             ; Output string
0217   01F4             
0218   01F4 31 AB 20    WARMST: LD      SP,STACK        ; Temporary stack
0219   01F7 CD 2F 06    BRKRET: CALL    CLREG           ; Clear registers and stack
0220   01FA C3 48 05            JP      PRNTOK          ; Go to get command line
0221   01FD             
0222   01FD 20 42 79 74 BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0222   0201 65 73 20 66 
0222   0205 72 65 65 0D 
0222   0209 0A 00 00 
0223   020C             
0224   020C 5A 38 30 20 SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0224   0210 42 41 53 49 
0224   0214 43 20 56 65 
0224   0218 72 20 34 2E 
0224   021C 37 62 0D 0A 
0225   0220 43 6F 70 79         .BYTE   "Copyright ",40,"C",41
0225   0224 72 69 67 68 
0225   0228 74 20 28 43 
0225   022C 29 
0226   022D 20 31 39 37         .BYTE   " 1978 by Microsoft",CR,LF,0,0
0226   0231 38 20 62 79 
0226   0235 20 4D 69 63 
0226   0239 72 6F 73 6F 
0226   023D 66 74 0D 0A 
0226   0241 00 00 
0227   0243             
0228   0243 4D 65 6D 6F MEMMSG: .BYTE   "Memory top",0
0228   0247 72 79 20 74 
0228   024B 6F 70 00 
0229   024E             
0230   024E             ; FUNCTION ADDRESS TABLE
0231   024E             
0232   024E B3 17       FNCTAB: .WORD   SGN
0233   0250 77 18               .WORD   INT
0234   0252 C9 17               .WORD   ABS
0235   0254 48 20               .WORD   USR
0236   0256 5B 11               .WORD   FRE
0237   0258 E0 14               .WORD   INP
0238   025A 89 11               .WORD   POS
0239   025C 3D 1A               .WORD   SQR
0240   025E 1C 1B               .WORD   RND
0241   0260 58 16               .WORD   LOG
0242   0262 8B 1A               .WORD   EXP
0243   0264 91 1B               .WORD   COS
0244   0266 97 1B               .WORD   SIN
0245   0268 F8 1B               .WORD   TAN
0246   026A 0D 1C               .WORD   ATN
0247   026C 34 15               .WORD   PEEK
0248   026E 78 1C               .WORD   DEEK
0249   0270 96 20               .WORD   POINT
0250   0272 0D 14               .WORD   LEN
0251   0274 25 12               .WORD   STR
0252   0276 A7 14               .WORD   VAL
0253   0278 1C 14               .WORD   ASC
0254   027A 2D 14               .WORD   CHR
0255   027C 9A 1C               .WORD   HEX
0256   027E 2D 1D               .WORD   BIN
0257   0280 3D 14               .WORD   LEFT
0258   0282 6D 14               .WORD   RIGHT
0259   0284 77 14               .WORD   MID
0260   0286             
0261   0286             ; RESERVED WORD LIST
0262   0286             
0263   0286 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0264   0289 C6 4F 52            .BYTE   'F'+80H,"OR"
0265   028C CE 45 58 54         .BYTE   'N'+80H,"EXT"
0266   0290 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0267   0294 C9 4E 50 55         .BYTE   'I'+80H,"NPUT"
0267   0298 54 
0268   0299 C4 49 4D            .BYTE   'D'+80H,"IM"
0269   029C D2 45 41 44         .BYTE   'R'+80H,"EAD"
0270   02A0 CC 45 54            .BYTE   'L'+80H,"ET"
0271   02A3 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0272   02A7 D2 55 4E            .BYTE   'R'+80H,"UN"
0273   02AA C9 46               .BYTE   'I'+80H,"F"
0274   02AC D2 45 53 54         .BYTE   'R'+80H,"ESTORE"
0274   02B0 4F 52 45 
0275   02B3 C7 4F 53 55         .BYTE   'G'+80H,"OSUB"
0275   02B7 42 
0276   02B8 D2 45 54 55         .BYTE   'R'+80H,"ETURN"
0276   02BC 52 4E 
0277   02BE D2 45 4D            .BYTE   'R'+80H,"EM"
0278   02C1 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0279   02C5 CF 55 54            .BYTE   'O'+80H,"UT"
0280   02C8 CF 4E               .BYTE   'O'+80H,"N"
0281   02CA CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0282   02CE D7 41 49 54         .BYTE   'W'+80H,"AIT"
0283   02D2 C4 45 46            .BYTE   'D'+80H,"EF"
0284   02D5 D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0285   02D9 C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0286   02DD D3 43 52 45         .BYTE   'S'+80H,"CREEN"
0286   02E1 45 4E 
0287   02E3 CC 49 4E 45         .BYTE   'L'+80H,"INES"
0287   02E7 53 
0288   02E8 C3 4C 53            .BYTE   'C'+80H,"LS"
0289   02EB D7 49 44 54         .BYTE   'W'+80H,"IDTH"
0289   02EF 48 
0290   02F0 CD 4F 4E 49         .BYTE   'M'+80H,"ONITOR"
0290   02F4 54 4F 52 
0291   02F7 D3 45 54            .BYTE   'S'+80H,"ET"
0292   02FA D2 45 53 45         .BYTE   'R'+80H,"ESET"
0292   02FE 54 
0293   02FF D0 52 49 4E         .BYTE   'P'+80H,"RINT"
0293   0303 54 
0294   0304 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0295   0308 CC 49 53 54         .BYTE   'L'+80H,"IST"
0296   030C C3 4C 45 41         .BYTE   'C'+80H,"LEAR"
0296   0310 52 
0297   0311 C3 4C 4F 41         .BYTE   'C'+80H,"LOAD"
0297   0315 44 
0298   0316 C3 53 41 56         .BYTE   'C'+80H,"SAVE"
0298   031A 45 
0299   031B CE 45 57            .BYTE   'N'+80H,"EW"
0300   031E             
0301   031E D4 41 42 28         .BYTE   'T'+80H,"AB("
0302   0322 D4 4F               .BYTE   'T'+80H,"O"
0303   0324 C6 4E               .BYTE   'F'+80H,"N"
0304   0326 D3 50 43 28         .BYTE   'S'+80H,"PC("
0305   032A D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0306   032E CE 4F 54            .BYTE   'N'+80H,"OT"
0307   0331 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0308   0335             
0309   0335 AB                  .BYTE   '+'+80H
0310   0336 AD                  .BYTE   '-'+80H
0311   0337 AA                  .BYTE   '*'+80H
0312   0338 AF                  .BYTE   '/'+80H
0313   0339 DE                  .BYTE   '^'+80H
0314   033A C1 4E 44            .BYTE   'A'+80H,"ND"
0315   033D CF 52               .BYTE   'O'+80H,"R"
0316   033F BE                  .BYTE   '>'+80H
0317   0340 BD                  .BYTE   '='+80H
0318   0341 BC                  .BYTE   '<'+80H
0319   0342             
0320   0342 D3 47 4E            .BYTE   'S'+80H,"GN"
0321   0345 C9 4E 54            .BYTE   'I'+80H,"NT"
0322   0348 C1 42 53            .BYTE   'A'+80H,"BS"
0323   034B D5 53 52            .BYTE   'U'+80H,"SR"
0324   034E C6 52 45            .BYTE   'F'+80H,"RE"
0325   0351 C9 4E 50            .BYTE   'I'+80H,"NP"
0326   0354 D0 4F 53            .BYTE   'P'+80H,"OS"
0327   0357 D3 51 52            .BYTE   'S'+80H,"QR"
0328   035A D2 4E 44            .BYTE   'R'+80H,"ND"
0329   035D CC 4F 47            .BYTE   'L'+80H,"OG"
0330   0360 C5 58 50            .BYTE   'E'+80H,"XP"
0331   0363 C3 4F 53            .BYTE   'C'+80H,"OS"
0332   0366 D3 49 4E            .BYTE   'S'+80H,"IN"
0333   0369 D4 41 4E            .BYTE   'T'+80H,"AN"
0334   036C C1 54 4E            .BYTE   'A'+80H,"TN"
0335   036F D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0336   0373 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0337   0377 D0 4F 49 4E         .BYTE   'P'+80H,"OINT"
0337   037B 54 
0338   037C CC 45 4E            .BYTE   'L'+80H,"EN"
0339   037F D3 54 52 24         .BYTE   'S'+80H,"TR$"
0340   0383 D6 41 4C            .BYTE   'V'+80H,"AL"
0341   0386 C1 53 43            .BYTE   'A'+80H,"SC"
0342   0389 C3 48 52 24         .BYTE   'C'+80H,"HR$"
0343   038D C8 45 58 24         .BYTE   'H'+80H,"EX$"
0344   0391 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0345   0395 CC 45 46 54         .BYTE   'L'+80H,"EFT$"
0345   0399 24 
0346   039A D2 49 47 48         .BYTE   'R'+80H,"IGHT$"
0346   039E 54 24 
0347   03A0 CD 49 44 24         .BYTE   'M'+80H,"ID$"
0348   03A4 80                  .BYTE   80H             ; End of list marker
0349   03A5             
0350   03A5             ; KEYWORD ADDRESS TABLE
0351   03A5             
0352   03A5 9F 09       WORDTB: .WORD   PEND
0353   03A7 9C 08               .WORD   FOR
0354   03A9 77 0D               .WORD   NEXT
0355   03AB EC 0A               .WORD   DATA
0356   03AD 7E 0C               .WORD   INPUT
0357   03AF B3 0F               .WORD   DIM
0358   03B1 AD 0C               .WORD   READ
0359   03B3 03 0B               .WORD   LET
0360   03B5 A9 0A               .WORD   GOTO
0361   03B7 8C 0A               .WORD   RUN
0362   03B9 7B 0B               .WORD   IF
0363   03BB 65 09               .WORD   RESTOR
0364   03BD 98 0A               .WORD   GOSUB
0365   03BF C7 0A               .WORD   RETURN
0366   03C1 EE 0A               .WORD   REM
0367   03C3 9D 09               .WORD   STOP
0368   03C5 EC 14               .WORD   POUT
0369   03C7 5D 0B               .WORD   ON
0370   03C9 DE 09               .WORD   NULL
0371   03CB F2 14               .WORD   WAIT
0372   03CD 91 11               .WORD   DEF
0373   03CF 3B 15               .WORD   POKE
0374   03D1 83 1C               .WORD   DOKE
0375   03D3 EE 0A               .WORD   REM
0376   03D5 69 1C               .WORD   LINES
0377   03D7 5C 1C               .WORD   CLS
0378   03D9 61 1C               .WORD   WIDTH
0379   03DB 99 1D               .WORD   MONITR
0380   03DD 99 20               .WORD   PSET
0381   03DF 9C 20               .WORD   RESET
0382   03E1 9F 0B               .WORD   PRINT
0383   03E3 CB 09               .WORD   CONT
0384   03E5 11 08               .WORD   LIST
0385   03E7 46 0A               .WORD   CLEAR
0386   03E9 EE 0A               .WORD   REM
0387   03EB EE 0A               .WORD   REM
0388   03ED 09 06               .WORD   NEW
0389   03EF             
0390   03EF             ; RESERVED WORD TOKEN VALUES
0391   03EF             
0392   03EF             ZEND    .EQU    080H            ; END
0393   03EF             ZFOR    .EQU    081H            ; FOR
0394   03EF             ZDATA   .EQU    083H            ; DATA
0395   03EF             ZGOTO   .EQU    088H            ; GOTO
0396   03EF             ZGOSUB  .EQU    08CH            ; GOSUB
0397   03EF             ZREM    .EQU    08EH            ; REM
0398   03EF             ZPRINT  .EQU    09EH            ; PRINT
0399   03EF             ZNEW    .EQU    0A4H            ; NEW
0400   03EF             
0401   03EF             ZTAB    .EQU    0A5H            ; TAB
0402   03EF             ZTO     .EQU    0A6H            ; TO
0403   03EF             ZFN     .EQU    0A7H            ; FN
0404   03EF             ZSPC    .EQU    0A8H            ; SPC
0405   03EF             ZTHEN   .EQU    0A9H            ; THEN
0406   03EF             ZNOT    .EQU    0AAH            ; NOT
0407   03EF             ZSTEP   .EQU    0ABH            ; STEP
0408   03EF             
0409   03EF             ZPLUS   .EQU    0ACH            ; +
0410   03EF             ZMINUS  .EQU    0ADH            ; -
0411   03EF             ZTIMES  .EQU    0AEH            ; *
0412   03EF             ZDIV    .EQU    0AFH            ; /
0413   03EF             ZOR     .EQU    0B2H            ; OR
0414   03EF             ZGTR    .EQU    0B3H            ; >
0415   03EF             ZEQUAL  .EQU    0B4H            ; M
0416   03EF             ZLTH    .EQU    0B5H            ; <
0417   03EF             ZSGN    .EQU    0B6H            ; SGN
0418   03EF             ZPOINT  .EQU    0C7H            ; POINT
0419   03EF             ZLEFT   .EQU    0CDH +2         ; LEFT$
0420   03EF             
0421   03EF             ; ARITHMETIC PRECEDENCE TABLE
0422   03EF             
0423   03EF 79          PRITAB: .BYTE   79H             ; Precedence value
0424   03F0 25 19               .WORD   PADD            ; FPREG = <last> + FPREG
0425   03F2             
0426   03F2 79                  .BYTE   79H             ; Precedence value
0427   03F3 59 15               .WORD   PSUB            ; FPREG = <last> - FPREG
0428   03F5             
0429   03F5 7C                  .BYTE   7CH             ; Precedence value
0430   03F6 97 16               .WORD   MULT            ; PPREG = <last> * FPREG
0431   03F8             
0432   03F8 7C                  .BYTE   7CH             ; Precedence value
0433   03F9 F8 16               .WORD   DIV             ; FPREG = <last> / FPREG
0434   03FB             
0435   03FB 7F                  .BYTE   7FH             ; Precedence value
0436   03FC 46 1A               .WORD   POWER           ; FPREG = <last> ^ FPREG
0437   03FE             
0438   03FE 50                  .BYTE   50H             ; Precedence value
0439   03FF 0C 0F               .WORD   PAND            ; FPREG = <last> AND FPREG
0440   0401             
0441   0401 46                  .BYTE   46H             ; Precedence value
0442   0402 0B 0F               .WORD   POR             ; FPREG = <last> OR FPREG
0443   0404             
0444   0404             ; BASIC ERROR CODE LIST
0445   0404             
0446   0404 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
0447   0406 53 4E               .BYTE   "SN"            ; Syntax error
0448   0408 52 47               .BYTE   "RG"            ; RETURN without GOSUB
0449   040A 4F 44               .BYTE   "OD"            ; Out of DATA
0450   040C 46 43               .BYTE   "FC"            ; Illegal function call
0451   040E 4F 56               .BYTE   "OV"            ; Overflow error
0452   0410 4F 4D               .BYTE   "OM"            ; Out of memory
0453   0412 55 4C               .BYTE   "UL"            ; Undefined line
0454   0414 42 53               .BYTE   "BS"            ; Bad subscript
0455   0416 44 44               .BYTE   "DD"            ; Re-DIMensioned array
0456   0418 2F 30               .BYTE   "/0"            ; Division by zero
0457   041A 49 44               .BYTE   "ID"            ; Illegal direct
0458   041C 54 4D               .BYTE   "TM"            ; Type mis-match
0459   041E 4F 53               .BYTE   "OS"            ; Out of string space
0460   0420 4C 53               .BYTE   "LS"            ; String too long
0461   0422 53 54               .BYTE   "ST"            ; String formula too complex
0462   0424 43 4E               .BYTE   "CN"            ; Can't CONTinue
0463   0426 55 46               .BYTE   "UF"            ; Undefined FN function
0464   0428 4D 4F               .BYTE   "MO"            ; Missing operand
0465   042A 48 58               .BYTE   "HX"            ; HEX error
0466   042C 42 4E               .BYTE   "BN"            ; BIN error
0467   042E             
0468   042E             ; INITIALISATION TABLE -------------------------------------------------------
0469   042E             
0470   042E C3 F4 01    INITAB: JP      WARMST          ; Warm start jump
0471   0431 C3 1C 0A            JP      FCERR           ; "USR (X)" jump (Set to Error)
0472   0434 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0473   0436 C9                  RET
0474   0437 D6 00               SUB     0               ; Division support routine
0475   0439 6F                  LD      L,A
0476   043A 7C                  LD      A,H
0477   043B DE 00               SBC     A,0
0478   043D 67                  LD      H,A
0479   043E 78                  LD      A,B
0480   043F DE 00               SBC     A,0
0481   0441 47                  LD      B,A
0482   0442 3E 00               LD      A,0
0483   0444 C9                  RET
0484   0445 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0485   0448 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0486   044C 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0487   0450 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0488   0454 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0489   0458 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0490   045C 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0491   0460 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0492   0464 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0493   0468 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0494   046C DB 00               IN      A,(0)           ; INP (x) skeleton
0495   046E C9                  RET
0496   046F 01                  .BYTE   1               ; POS (x) number (1)
0497   0470 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0498   0471 1C                  .BYTE   28              ; Width for commas (3 columns)
0499   0472 00                  .BYTE   0               ; No nulls after input bytes
0500   0473 00                  .BYTE   0               ; Output enabled (^O off)
0501   0474 14 00               .WORD   20              ; Initial lines counter
0502   0476 14 00               .WORD   20              ; Initial lines number
0503   0478 00 00               .WORD   0               ; Array load/save check sum
0504   047A 00                  .BYTE   0               ; Break not by NMI
0505   047B 00                  .BYTE   0               ; Break flag
0506   047C C3 42 07            JP      TTYLIN          ; Input reflection (set to TTY)
0507   047F C3 00 00            JP      $0000           ; POINT reflection unused
0508   0482 C3 00 00            JP      $0000           ; SET reflection
0509   0485 C3 00 00            JP      $0000          	; RESET reflection
0510   0488 A2 21               .WORD   STLOOK          ; Temp string space
0511   048A FE FF               .WORD   -2              ; Current line number (cold)
0512   048C 3F 21               .WORD   PROGST+1        ; Start of program text
0513   048E             INITBE:                         
0514   048E             
0515   048E             ; END OF INITIALISATION TABLE ---------------------------------------------------
0516   048E             
0517   048E 20 45 72 72 ERRMSG: .BYTE   " Error",0
0517   0492 6F 72 00 
0518   0495 20 69 6E 20 INMSG:  .BYTE   " in ",0
0518   0499 00 
0519   049A             ZERBYT  .EQU    $-1             ; A zero byte
0520   049A 4F 6B 0D 0A OKMSG:  .BYTE   "Ok",CR,LF,0,0
0520   049E 00 00 
0521   04A0 42 72 65 61 BRKMSG: .BYTE   "Break",0
0521   04A4 6B 00 
0522   04A6             
0523   04A6 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0524   04A9 39                  ADD     HL,SP           ; same index as specified
0525   04AA 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0526   04AB 23                  INC     HL              ; Point to index address
0527   04AC FE 81               CP      ZFOR            ; Is it a "FOR" token
0528   04AE C0                  RET     NZ              ; No - exit
0529   04AF 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0530   04B0 23                  INC     HL
0531   04B1 46                  LD      B,(HL)
0532   04B2 23                  INC     HL              ; Point to sign of STEP
0533   04B3 E5                  PUSH    HL              ; Save pointer to sign
0534   04B4 69                  LD      L,C             ; HL = address of "FOR" index
0535   04B5 60                  LD      H,B
0536   04B6 7A                  LD      A,D             ; See if an index was specified
0537   04B7 B3                  OR      E               ; DE = 0 if no index specified
0538   04B8 EB                  EX      DE,HL           ; Specified index into HL
0539   04B9 CA C0 04            JP      Z,INDFND        ; Skip if no index given
0540   04BC EB                  EX      DE,HL           ; Index back into DE
0541   04BD CD C5 07            CALL    CPDEHL          ; Compare index with one given
0542   04C0 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0543   04C3 E1                  POP     HL              ; Restore pointer to sign
0544   04C4 C8                  RET     Z               ; Return if block found
0545   04C5 09                  ADD     HL,BC           ; Point to next block
0546   04C6 C3 AA 04            JP      LOKFOR          ; Keep on looking
0547   04C9             
0548   04C9 CD E3 04    MOVUP:  CALL    ENFMEM          ; See if enough memory
0549   04CC C5          MOVSTR: PUSH    BC              ; Save end of source
0550   04CD E3                  EX      (SP),HL         ; Swap source and dest" end
0551   04CE C1                  POP     BC              ; Get end of destination
0552   04CF CD C5 07    MOVLP:  CALL    CPDEHL          ; See if list moved
0553   04D2 7E                  LD      A,(HL)          ; Get byte
0554   04D3 02                  LD      (BC),A          ; Move it
0555   04D4 C8                  RET     Z               ; Exit if all done
0556   04D5 0B                  DEC     BC              ; Next byte to move to
0557   04D6 2B                  DEC     HL              ; Next byte to move
0558   04D7 C3 CF 04            JP      MOVLP           ; Loop until all bytes moved
0559   04DA             
0560   04DA E5          CHKSTK: PUSH    HL              ; Save code string address
0561   04DB 2A 1F 21            LD      HL,(ARREND)     ; Lowest free memory
0562   04DE 06 00               LD      B,0             ; BC = Number of levels to test
0563   04E0 09                  ADD     HL,BC           ; 2 Bytes for each level
0564   04E1 09                  ADD     HL,BC
0565   04E2 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0566   04E3 E5          ENFMEM: PUSH    HL              ; Save code string address
0567   04E4 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0568   04E6 95                  SUB     L
0569   04E7 6F                  LD      L,A
0570   04E8 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0571   04EA 9C                  SBC     A,H
0572   04EB DA F2 04            JP      C,OMERR         ; Not enough - ?OM Error
0573   04EE 67                  LD      H,A
0574   04EF 39                  ADD     HL,SP           ; Test if stack is overflowed
0575   04F0 E1                  POP     HL              ; Restore code string address
0576   04F1 D8                  RET     C               ; Return if enough mmory
0577   04F2 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0578   04F4 C3 11 05            JP      ERROR
0579   04F7             
0580   04F7 2A 0E 21    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0581   04FA 22 A1 20            LD      (LINEAT),HL     ; Save as current line
0582   04FD 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0583   04FF 01                  .BYTE   01H             ; Skip "LD E,DZ"
0584   0500 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0585   0502 01                  .BYTE   01H             ; Skip "LD E,NF"
0586   0503 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0587   0505 01                  .BYTE   01H             ; Skip "LD E,DD"
0588   0506 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0589   0508 01                  .BYTE   01H             ; Skip "LD E,UF"
0590   0509 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0591   050B 01                  .BYTE   01H             ; Skip "LD E,OV
0592   050C 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0593   050E 01                  .BYTE   01H             ; Skip "LD E,TM"
0594   050F 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0595   0511             
0596   0511 CD 2F 06    ERROR:  CALL    CLREG           ; Clear registers and stack
0597   0514 32 8A 20            LD      (CTLOFG),A      ; Enable output (A is 0)
0598   0517 CD F0 0B            CALL    STTLIN          ; Start new line
0599   051A 21 04 04            LD      HL,ERRORS       ; Point to error codes
0600   051D 57                  LD      D,A             ; D = 0 (A is 0)
0601   051E 3E 3F               LD      A,'?'
0602   0520 CD D6 07            CALL    OUTC            ; Output '?'
0603   0523 19                  ADD     HL,DE           ; Offset to correct error code
0604   0524 7E                  LD      A,(HL)          ; First character
0605   0525 CD D6 07            CALL    OUTC            ; Output it
0606   0528 CD 55 09            CALL    GETCHR          ; Get next character
0607   052B CD D6 07            CALL    OUTC            ; Output it
0608   052E 21 8E 04            LD      HL,ERRMSG       ; "Error" message
0609   0531 CD 9B 12    ERRIN:  CALL    PRS             ; Output message
0610   0534 2A A1 20            LD      HL,(LINEAT)     ; Get line of error
0611   0537 11 FE FF            LD      DE,-2           ; Cold start error if -2
0612   053A CD C5 07            CALL    CPDEHL          ; See if cold start error
0613   053D CA 61 01            JP      Z,CSTART        ; Cold start error - Restart
0614   0540 7C                  LD      A,H             ; Was it a direct error?
0615   0541 A5                  AND     L               ; Line = -1 if direct error
0616   0542 3C                  INC     A
0617   0543 C4 36 19            CALL    NZ,LINEIN       ; No - output line of error
0618   0546 3E                  .BYTE   3EH             ; Skip "POP BC"
0619   0547 C1          POPNOK: POP     BC              ; Drop address in input buffer
0620   0548             
0621   0548 AF          PRNTOK: XOR     A               ; Output "Ok" and get command
0622   0549 32 8A 20            LD      (CTLOFG),A      ; Enable output
0623   054C CD F0 0B            CALL    STTLIN          ; Start new line
0624   054F 21 9A 04            LD      HL,OKMSG        ; "Ok" message
0625   0552 CD 9B 12            CALL    PRS             ; Output "Ok"
0626   0555 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0627   0558 22 A1 20            LD      (LINEAT),HL     ; Save as current line
0628   055B CD 42 07            CALL    GETLIN          ; Get an input line
0629   055E DA 55 05            JP      C,GETCMD        ; Get line again if break
0630   0561 CD 55 09            CALL    GETCHR          ; Get first character
0631   0564 3C                  INC     A               ; Test if end of line
0632   0565 3D                  DEC     A               ; Without affecting Carry
0633   0566 CA 55 05            JP      Z,GETCMD        ; Nothing entered - Get another
0634   0569 F5                  PUSH    AF              ; Save Carry status
0635   056A CD 21 0A            CALL    ATOH            ; Get line number into DE
0636   056D D5                  PUSH    DE              ; Save line number
0637   056E CD 59 06            CALL    CRUNCH          ; Tokenise rest of line
0638   0571 47                  LD      B,A             ; Length of tokenised line
0639   0572 D1                  POP     DE              ; Restore line number
0640   0573 F1                  POP     AF              ; Restore Carry
0641   0574 D2 35 09            JP      NC,EXCUTE       ; No line number - Direct mode
0642   0577 D5                  PUSH    DE              ; Save line number
0643   0578 C5                  PUSH    BC              ; Save length of tokenised line
0644   0579 AF                  XOR     A
0645   057A 32 11 21            LD      (LSTBIN),A      ; Clear last byte input
0646   057D CD 55 09            CALL    GETCHR          ; Get next character
0647   0580 B7                  OR      A               ; Set flags
0648   0581 F5                  PUSH    AF              ; And save them
0649   0582 CD E9 05            CALL    SRCHLN          ; Search for line number in DE
0650   0585 DA 8E 05            JP      C,LINFND        ; Jump if line found
0651   0588 F1                  POP     AF              ; Get status
0652   0589 F5                  PUSH    AF              ; And re-save
0653   058A CA C2 0A            JP      Z,ULERR         ; Nothing after number - Error
0654   058D B7                  OR      A               ; Clear Carry
0655   058E C5          LINFND: PUSH    BC              ; Save address of line in prog
0656   058F D2 A5 05            JP      NC,INEWLN       ; Line not found - Insert new
0657   0592 EB                  EX      DE,HL           ; Next line address in DE
0658   0593 2A 1B 21            LD      HL,(PROGND)     ; End of program
0659   0596 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0660   0597 02                  LD      (BC),A
0661   0598 03                  INC     BC              ; Next destination
0662   0599 13                  INC     DE              ; Next source
0663   059A CD C5 07            CALL    CPDEHL          ; All done?
0664   059D C2 96 05            JP      NZ,SFTPRG       ; More to do
0665   05A0 60                  LD      H,B             ; HL - New end of program
0666   05A1 69                  LD      L,C
0667   05A2 22 1B 21            LD      (PROGND),HL     ; Update end of program
0668   05A5             
0669   05A5 D1          INEWLN: POP     DE              ; Get address of line,
0670   05A6 F1                  POP     AF              ; Get status
0671   05A7 CA CC 05            JP      Z,SETPTR        ; No text - Set up pointers
0672   05AA 2A 1B 21            LD      HL,(PROGND)     ; Get end of program
0673   05AD E3                  EX      (SP),HL         ; Get length of input line
0674   05AE C1                  POP     BC              ; End of program to BC
0675   05AF 09                  ADD     HL,BC           ; Find new end
0676   05B0 E5                  PUSH    HL              ; Save new end
0677   05B1 CD C9 04            CALL    MOVUP           ; Make space for line
0678   05B4 E1                  POP     HL              ; Restore new end
0679   05B5 22 1B 21            LD      (PROGND),HL     ; Update end of program pointer
0680   05B8 EB                  EX      DE,HL           ; Get line to move up in HL
0681   05B9 74                  LD      (HL),H          ; Save MSB
0682   05BA D1                  POP     DE              ; Get new line number
0683   05BB 23                  INC     HL              ; Skip pointer
0684   05BC 23                  INC     HL
0685   05BD 73                  LD      (HL),E          ; Save LSB of line number
0686   05BE 23                  INC     HL
0687   05BF 72                  LD      (HL),D          ; Save MSB of line number
0688   05C0 23                  INC     HL              ; To first byte in line
0689   05C1 11 A6 20            LD      DE,BUFFER       ; Copy buffer to program
0690   05C4 1A          MOVBUF: LD      A,(DE)          ; Get source
0691   05C5 77                  LD      (HL),A          ; Save destinations
0692   05C6 23                  INC     HL              ; Next source
0693   05C7 13                  INC     DE              ; Next destination
0694   05C8 B7                  OR      A               ; Done?
0695   05C9 C2 C4 05            JP      NZ,MOVBUF       ; No - Repeat
0696   05CC CD 15 06    SETPTR: CALL    RUNFST          ; Set line pointers
0697   05CF 23                  INC     HL              ; To LSB of pointer
0698   05D0 EB                  EX      DE,HL           ; Address to DE
0699   05D1 62          PTRLP:  LD      H,D             ; Address to HL
0700   05D2 6B                  LD      L,E
0701   05D3 7E                  LD      A,(HL)          ; Get LSB of pointer
0702   05D4 23                  INC     HL              ; To MSB of pointer
0703   05D5 B6                  OR      (HL)            ; Compare with MSB pointer
0704   05D6 CA 55 05            JP      Z,GETCMD        ; Get command line if end
0705   05D9 23                  INC     HL              ; To LSB of line number
0706   05DA 23                  INC     HL              ; Skip line number
0707   05DB 23                  INC     HL              ; Point to first byte in line
0708   05DC AF                  XOR     A               ; Looking for 00 byte
0709   05DD BE          FNDEND: CP      (HL)            ; Found end of line?
0710   05DE 23                  INC     HL              ; Move to next byte
0711   05DF C2 DD 05            JP      NZ,FNDEND       ; No - Keep looking
0712   05E2 EB                  EX      DE,HL           ; Next line address to HL
0713   05E3 73                  LD      (HL),E          ; Save LSB of pointer
0714   05E4 23                  INC     HL
0715   05E5 72                  LD      (HL),D          ; Save MSB of pointer
0716   05E6 C3 D1 05            JP      PTRLP           ; Do next line
0717   05E9             
0718   05E9 2A A3 20    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0719   05EC 44          SRCHLP: LD      B,H             ; BC = Address to look at
0720   05ED 4D                  LD      C,L
0721   05EE 7E                  LD      A,(HL)          ; Get address of next line
0722   05EF 23                  INC     HL
0723   05F0 B6                  OR      (HL)            ; End of program found?
0724   05F1 2B                  DEC     HL
0725   05F2 C8                  RET     Z               ; Yes - Line not found
0726   05F3 23                  INC     HL
0727   05F4 23                  INC     HL
0728   05F5 7E                  LD      A,(HL)          ; Get LSB of line number
0729   05F6 23                  INC     HL
0730   05F7 66                  LD      H,(HL)          ; Get MSB of line number
0731   05F8 6F                  LD      L,A
0732   05F9 CD C5 07            CALL    CPDEHL          ; Compare with line in DE
0733   05FC 60                  LD      H,B             ; HL = Start of this line
0734   05FD 69                  LD      L,C
0735   05FE 7E                  LD      A,(HL)          ; Get LSB of next line address
0736   05FF 23                  INC     HL
0737   0600 66                  LD      H,(HL)          ; Get MSB of next line address
0738   0601 6F                  LD      L,A             ; Next line to HL
0739   0602 3F                  CCF
0740   0603 C8                  RET     Z               ; Lines found - Exit
0741   0604 3F                  CCF
0742   0605 D0                  RET     NC              ; Line not found,at line after
0743   0606 C3 EC 05            JP      SRCHLP          ; Keep looking
0744   0609             
0745   0609 C0          NEW:    RET     NZ              ; Return if any more on line
0746   060A 2A A3 20    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0747   060D AF                  XOR     A               ; Set program area to empty
0748   060E 77                  LD      (HL),A          ; Save LSB = 00
0749   060F 23                  INC     HL
0750   0610 77                  LD      (HL),A          ; Save MSB = 00
0751   0611 23                  INC     HL
0752   0612 22 1B 21            LD      (PROGND),HL     ; Set program end
0753   0615             
0754   0615 2A A3 20    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0755   0618 2B                  DEC     HL
0756   0619             
0757   0619 22 13 21    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0758   061C 2A F4 20            LD      HL,(LSTRAM)     ; Get end of RAM
0759   061F 22 08 21            LD      (STRBOT),HL     ; Clear string space
0760   0622 AF                  XOR     A
0761   0623 CD 65 09            CALL    RESTOR          ; Reset DATA pointers
0762   0626 2A 1B 21            LD      HL,(PROGND)     ; Get end of program
0763   0629 22 1D 21            LD      (VAREND),HL     ; Clear variables
0764   062C 22 1F 21            LD      (ARREND),HL     ; Clear arrays
0765   062F             
0766   062F C1          CLREG:  POP     BC              ; Save return address
0767   0630 2A 9F 20            LD      HL,(STRSPC)     ; Get end of working RAN
0768   0633 F9                  LD      SP,HL           ; Set stack
0769   0634 21 F8 20            LD      HL,TMSTPL       ; Temporary string pool
0770   0637 22 F6 20            LD      (TMSTPT),HL     ; Reset temporary string ptr
0771   063A AF                  XOR     A               ; A = 00
0772   063B 6F                  LD      L,A             ; HL = 0000
0773   063C 67                  LD      H,A
0774   063D 22 19 21            LD      (CONTAD),HL     ; No CONTinue
0775   0640 32 10 21            LD      (FORFLG),A      ; Clear FOR flag
0776   0643 22 23 21            LD      (FNRGNM),HL     ; Clear FN argument
0777   0646 E5                  PUSH    HL              ; HL = 0000
0778   0647 C5                  PUSH    BC              ; Put back return
0779   0648 2A 13 21    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0780   064B C9                  RET                     ; Return to execution driver
0781   064C             
0782   064C 3E 3F       PROMPT: LD      A,'?'           ; '?'
0783   064E CD D6 07            CALL    OUTC            ; Output character
0784   0651 3E 20               LD      A,' '           ; Space
0785   0653 CD D6 07            CALL    OUTC            ; Output character
0786   0656 C3 93 20            JP      RINPUT          ; Get input line
0787   0659             
0788   0659 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0789   065A 32 F3 20            LD      (DATFLG),A      ; Reset literal flag
0790   065D 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0791   065F 11 A6 20            LD      DE,BUFFER       ; Start of input buffer
0792   0662 7E          CRNCLP: LD      A,(HL)          ; Get byte
0793   0663 FE 20               CP      ' '             ; Is it a space?
0794   0665 CA E1 06            JP      Z,MOVDIR        ; Yes - Copy direct
0795   0668 47                  LD      B,A             ; Save character
0796   0669 FE 22               CP      '"'             ; Is it a quote?
0797   066B CA 01 07            JP      Z,CPYLIT        ; Yes - Copy literal string
0798   066E B7                  OR      A               ; Is it end of buffer?
0799   066F CA 08 07            JP      Z,ENDBUF        ; Yes - End buffer
0800   0672 3A F3 20            LD      A,(DATFLG)      ; Get data type
0801   0675 B7                  OR      A               ; Literal?
0802   0676 7E                  LD      A,(HL)          ; Get byte to copy
0803   0677 C2 E1 06            JP      NZ,MOVDIR       ; Literal - Copy direct
0804   067A FE 3F               CP      '?'             ; Is it '?' short for PRINT
0805   067C 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0806   067E CA E1 06            JP      Z,MOVDIR        ; Yes - replace it
0807   0681 7E                  LD      A,(HL)          ; Get byte again
0808   0682 FE 30               CP      '0'             ; Is it less than '0'
0809   0684 DA 8C 06            JP      C,FNDWRD        ; Yes - Look for reserved words
0810   0687 FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0811   0689 DA E1 06            JP      C,MOVDIR        ; Yes - copy it direct
0812   068C D5          FNDWRD: PUSH    DE              ; Look for reserved words
0813   068D 11 85 02            LD      DE,WORDS-1      ; Point to table
0814   0690 C5                  PUSH    BC              ; Save count
0815   0691 01 DD 06            LD      BC,RETNAD       ; Where to return to
0816   0694 C5                  PUSH    BC              ; Save return address
0817   0695 06 7F               LD      B,ZEND-1        ; First token value -1
0818   0697 7E                  LD      A,(HL)          ; Get byte
0819   0698 FE 61               CP      'a'             ; Less than 'a' ?
0820   069A DA A5 06            JP      C,SEARCH        ; Yes - search for words
0821   069D FE 7B               CP      'z'+1           ; Greater than 'z' ?
0822   069F D2 A5 06            JP      NC,SEARCH       ; Yes - search for words
0823   06A2 E6 5F               AND     01011111B       ; Force upper case
0824   06A4 77                  LD      (HL),A          ; Replace byte
0825   06A5 4E          SEARCH: LD      C,(HL)          ; Search for a word
0826   06A6 EB                  EX      DE,HL
0827   06A7 23          GETNXT: INC     HL              ; Get next reserved word
0828   06A8 B6                  OR      (HL)            ; Start of word?
0829   06A9 F2 A7 06            JP      P,GETNXT        ; No - move on
0830   06AC 04                  INC     B               ; Increment token value
0831   06AD 7E                  LD      A, (HL)         ; Get byte from table
0832   06AE E6 7F               AND     01111111B       ; Strip bit 7
0833   06B0 C8                  RET     Z               ; Return if end of list
0834   06B1 B9                  CP      C               ; Same character as in buffer?
0835   06B2 C2 A7 06            JP      NZ,GETNXT       ; No - get next word
0836   06B5 EB                  EX      DE,HL
0837   06B6 E5                  PUSH    HL              ; Save start of word
0838   06B7             
0839   06B7 13          NXTBYT: INC     DE              ; Look through rest of word
0840   06B8 1A                  LD      A,(DE)          ; Get byte from table
0841   06B9 B7                  OR      A               ; End of word ?
0842   06BA FA D9 06            JP      M,MATCH         ; Yes - Match found
0843   06BD 4F                  LD      C,A             ; Save it
0844   06BE 78                  LD      A,B             ; Get token value
0845   06BF FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0846   06C1 C2 C8 06            JP      NZ,NOSPC        ; No - Don't allow spaces
0847   06C4 CD 55 09            CALL    GETCHR          ; Get next character
0848   06C7 2B                  DEC     HL              ; Cancel increment from GETCHR
0849   06C8 23          NOSPC:  INC     HL              ; Next byte
0850   06C9 7E                  LD      A,(HL)          ; Get byte
0851   06CA FE 61               CP      'a'             ; Less than 'a' ?
0852   06CC DA D1 06            JP      C,NOCHNG        ; Yes - don't change
0853   06CF E6 5F               AND     01011111B       ; Make upper case
0854   06D1 B9          NOCHNG: CP      C               ; Same as in buffer ?
0855   06D2 CA B7 06            JP      Z,NXTBYT        ; Yes - keep testing
0856   06D5 E1                  POP     HL              ; Get back start of word
0857   06D6 C3 A5 06            JP      SEARCH          ; Look at next word
0858   06D9             
0859   06D9 48          MATCH:  LD      C,B             ; Word found - Save token value
0860   06DA F1                  POP     AF              ; Throw away return
0861   06DB EB                  EX      DE,HL
0862   06DC C9                  RET                     ; Return to "RETNAD"
0863   06DD EB          RETNAD: EX      DE,HL           ; Get address in string
0864   06DE 79                  LD      A,C             ; Get token value
0865   06DF C1                  POP     BC              ; Restore buffer length
0866   06E0 D1                  POP     DE              ; Get destination address
0867   06E1 23          MOVDIR: INC     HL              ; Next source in buffer
0868   06E2 12                  LD      (DE),A          ; Put byte in buffer
0869   06E3 13                  INC     DE              ; Move up buffer
0870   06E4 0C                  INC     C               ; Increment length of buffer
0871   06E5 D6 3A               SUB     ':'             ; End of statement?
0872   06E7 CA EF 06            JP      Z,SETLIT        ; Jump if multi-statement line
0873   06EA FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0874   06EC C2 F2 06            JP      NZ,TSTREM       ; No - see if REM
0875   06EF 32 F3 20    SETLIT: LD      (DATFLG),A      ; Set literal flag
0876   06F2 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0877   06F4 C2 62 06            JP      NZ,CRNCLP       ; No - Leave flag
0878   06F7 47                  LD      B,A             ; Copy rest of buffer
0879   06F8 7E          NXTCHR: LD      A,(HL)          ; Get byte
0880   06F9 B7                  OR      A               ; End of line ?
0881   06FA CA 08 07            JP      Z,ENDBUF        ; Yes - Terminate buffer
0882   06FD B8                  CP      B               ; End of statement ?
0883   06FE CA E1 06            JP      Z,MOVDIR        ; Yes - Get next one
0884   0701 23          CPYLIT: INC     HL              ; Move up source string
0885   0702 12                  LD      (DE),A          ; Save in destination
0886   0703 0C                  INC     C               ; Increment length
0887   0704 13                  INC     DE              ; Move up destination
0888   0705 C3 F8 06            JP      NXTCHR          ; Repeat
0889   0708             
0890   0708 21 A5 20    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0891   070B 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0892   070C 13                  INC     DE
0893   070D 12                  LD      (DE),A          ; A = 00
0894   070E 13                  INC     DE
0895   070F 12                  LD      (DE),A          ; A = 00
0896   0710 C9                  RET
0897   0711             
0898   0711 3A 89 20    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0899   0714 B7                  OR      A               ; Is it zero?
0900   0715 3E 00               LD      A,0             ; Zero A - Leave flags
0901   0717 32 89 20            LD      (NULFLG),A      ; Zero null flag
0902   071A C2 25 07            JP      NZ,ECHDEL       ; Set - Echo it
0903   071D 05                  DEC     B               ; Decrement length
0904   071E CA 42 07            JP      Z,GETLIN        ; Get line again if empty
0905   0721 CD D6 07            CALL    OUTC            ; Output null character
0906   0724 3E                  .BYTE   3EH             ; Skip "DEC B"
0907   0725 05          ECHDEL: DEC     B               ; Count bytes in buffer
0908   0726 2B                  DEC     HL              ; Back space buffer
0909   0727 CA 39 07            JP      Z,OTKLN         ; No buffer - Try again
0910   072A 7E                  LD      A,(HL)          ; Get deleted byte
0911   072B CD D6 07            CALL    OUTC            ; Echo it
0912   072E C3 4B 07            JP      MORINP          ; Get more input
0913   0731             
0914   0731 05          DELCHR: DEC     B               ; Count bytes in buffer
0915   0732 2B                  DEC     HL              ; Back space buffer
0916   0733 CD D6 07            CALL    OUTC            ; Output character in A
0917   0736 C2 4B 07            JP      NZ,MORINP       ; Not end - Get more
0918   0739 CD D6 07    OTKLN:  CALL    OUTC            ; Output character in A
0919   073C CD FD 0B    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0920   073F C3 42 07            JP      TTYLIN          ; Get line again
0921   0742             
0922   0742             GETLIN:
0923   0742 21 A6 20    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0924   0745 06 01               LD      B,1             ; Set buffer as empty
0925   0747 AF                  XOR     A
0926   0748 32 89 20            LD      (NULFLG),A      ; Clear null flag
0927   074B CD 00 08    MORINP: CALL    CLOTST          ; Get character and test ^O
0928   074E 4F                  LD      C,A             ; Save character in C
0929   074F FE 7F               CP      DEL             ; Delete character?
0930   0751 CA 11 07            JP      Z,DODEL         ; Yes - Process it
0931   0754 3A 89 20            LD      A,(NULFLG)      ; Get null flag
0932   0757 B7                  OR      A               ; Test null flag status
0933   0758 CA 64 07            JP      Z,PROCES        ; Reset - Process character
0934   075B 3E 00               LD      A,0             ; Set a null
0935   075D CD D6 07            CALL    OUTC            ; Output null
0936   0760 AF                  XOR     A               ; Clear A
0937   0761 32 89 20            LD      (NULFLG),A      ; Reset null flag
0938   0764 79          PROCES: LD      A,C             ; Get character
0939   0765 FE 07               CP      CTRLG           ; Bell?
0940   0767 CA A8 07            JP      Z,PUTCTL        ; Yes - Save it
0941   076A FE 03               CP      CTRLC           ; Is it control "C"?
0942   076C CC FD 0B            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0943   076F 37                  SCF                     ; Flag break
0944   0770 C8                  RET     Z               ; Return if control "C"
0945   0771 FE 0D               CP      CR              ; Is it enter?
0946   0773 CA F8 0B            JP      Z,ENDINP        ; Yes - Terminate input
0947   0776 FE 15               CP      CTRLU           ; Is it control "U"?
0948   0778 CA 3C 07            JP      Z,KILIN         ; Yes - Get another line
0949   077B FE 40               CP      '@'             ; Is it "kill line"?
0950   077D CA 39 07            JP      Z,OTKLN         ; Yes - Kill line
0951   0780 FE 5F               CP      '_'             ; Is it delete?
0952   0782 CA 31 07            JP      Z,DELCHR        ; Yes - Delete character
0953   0785 FE 08               CP      BKSP            ; Is it backspace?
0954   0787 CA 31 07            JP      Z,DELCHR        ; Yes - Delete character
0955   078A FE 12               CP      CTRLR           ; Is it control "R"?
0956   078C C2 A3 07            JP      NZ,PUTBUF       ; No - Put in buffer
0957   078F C5                  PUSH    BC              ; Save buffer length
0958   0790 D5                  PUSH    DE              ; Save DE
0959   0791 E5                  PUSH    HL              ; Save buffer address
0960   0792 36 00               LD      (HL),0          ; Mark end of buffer
0961   0794 CD AD 1D            CALL    OUTNCR          ; Output and do CRLF
0962   0797 21 A6 20            LD      HL,BUFFER       ; Point to buffer start
0963   079A CD 9B 12            CALL    PRS             ; Output buffer
0964   079D E1                  POP     HL              ; Restore buffer address
0965   079E D1                  POP     DE              ; Restore DE
0966   079F C1                  POP     BC              ; Restore buffer length
0967   07A0 C3 4B 07            JP      MORINP          ; Get another character
0968   07A3             
0969   07A3 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0970   07A5 DA 4B 07            JP      C,MORINP        ; Yes - Ignore
0971   07A8 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0972   07A9 FE 49               CP      72+1            ; Test for line overflow
0973   07AB 3E 07               LD      A,CTRLG         ; Set a bell
0974   07AD D2 BD 07            JP      NC,OUTNBS       ; Ring bell if buffer full
0975   07B0 79                  LD      A,C             ; Get character
0976   07B1 71                  LD      (HL),C          ; Save in buffer
0977   07B2 32 11 21            LD      (LSTBIN),A      ; Save last input byte
0978   07B5 23                  INC     HL              ; Move up buffer
0979   07B6 04                  INC     B               ; Increment length
0980   07B7 CD D6 07    OUTIT:  CALL    OUTC            ; Output the character entered
0981   07BA C3 4B 07            JP      MORINP          ; Get another character
0982   07BD             
0983   07BD CD D6 07    OUTNBS: CALL    OUTC            ; Output bell and back over it
0984   07C0 3E 08               LD      A,BKSP          ; Set back space
0985   07C2 C3 B7 07            JP      OUTIT           ; Output it and get more
0986   07C5             
0987   07C5 7C          CPDEHL: LD      A,H             ; Get H
0988   07C6 92                  SUB     D               ; Compare with D
0989   07C7 C0                  RET     NZ              ; Different - Exit
0990   07C8 7D                  LD      A,L             ; Get L
0991   07C9 93                  SUB     E               ; Compare with E
0992   07CA C9                  RET                     ; Return status
0993   07CB             
0994   07CB 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
0995   07CC E3                  EX      (SP),HL         ; Address of test byte
0996   07CD BE                  CP      (HL)            ; Same as in code string?
0997   07CE 23                  INC     HL              ; Return address
0998   07CF E3                  EX      (SP),HL         ; Put it back
0999   07D0 CA 55 09            JP      Z,GETCHR        ; Yes - Get next character
1000   07D3 C3 FD 04            JP      SNERR           ; Different - ?SN Error
1001   07D6             
1002   07D6 F5          OUTC:   PUSH    AF              ; Save character
1003   07D7 3A 8A 20            LD      A,(CTLOFG)      ; Get control "O" flag
1004   07DA B7                  OR      A               ; Is it set?
1005   07DB C2 D0 12            JP      NZ,POPAF        ; Yes - don't output
1006   07DE F1                  POP     AF              ; Restore character
1007   07DF C5                  PUSH    BC              ; Save buffer length
1008   07E0 F5                  PUSH    AF              ; Save character
1009   07E1 FE 20               CP      ' '             ; Is it a control code?
1010   07E3 DA FA 07            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1011   07E6 3A 87 20            LD      A,(LWIDTH)      ; Get line width
1012   07E9 47                  LD      B,A             ; To B
1013   07EA 3A F0 20            LD      A,(CURPOS)      ; Get cursor position
1014   07ED 04                  INC     B               ; Width 255?
1015   07EE CA F6 07            JP      Z,INCLEN        ; Yes - No width limit
1016   07F1 05                  DEC     B               ; Restore width
1017   07F2 B8                  CP      B               ; At end of line?
1018   07F3 CC FD 0B            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1019   07F6 3C          INCLEN: INC     A               ; Move on one character
1020   07F7 32 F0 20            LD      (CURPOS),A      ; Save new position
1021   07FA F1          DINPOS: POP     AF              ; Restore character
1022   07FB C1                  POP     BC              ; Restore buffer length
1023   07FC CD 96 1D            CALL    MONOUT          ; Send it
1024   07FF C9                  RET
1025   0800             
1026   0800 CD 5A 1C    CLOTST: CALL    GETINP          ; Get input character
1027   0803 E6 7F               AND     01111111B       ; Strip bit 7
1028   0805 FE 0F               CP      CTRLO           ; Is it control "O"?
1029   0807 C0                  RET     NZ              ; No don't flip flag
1030   0808 3A 8A 20            LD      A,(CTLOFG)      ; Get flag
1031   080B 2F                  CPL                     ; Flip it
1032   080C 32 8A 20            LD      (CTLOFG),A      ; Put it back
1033   080F AF                  XOR     A               ; Null character
1034   0810 C9                  RET
1035   0811             
1036   0811 CD 21 0A    LIST:   CALL    ATOH            ; ASCII number to DE
1037   0814 C0                  RET     NZ              ; Return if anything extra
1038   0815 C1                  POP     BC              ; Rubbish - Not needed
1039   0816 CD E9 05            CALL    SRCHLN          ; Search for line number in DE
1040   0819 C5                  PUSH    BC              ; Save address of line
1041   081A CD 67 08            CALL    SETLIN          ; Set up lines counter
1042   081D E1          LISTLP: POP     HL              ; Restore address of line
1043   081E 4E                  LD      C,(HL)          ; Get LSB of next line
1044   081F 23                  INC     HL
1045   0820 46                  LD      B,(HL)          ; Get MSB of next line
1046   0821 23                  INC     HL
1047   0822 78                  LD      A,B             ; BC = 0 (End of program)?
1048   0823 B1                  OR      C
1049   0824 CA 48 05            JP      Z,PRNTOK        ; Yes - Go to command mode
1050   0827 CD 70 08            CALL    COUNT           ; Count lines
1051   082A CD 80 09            CALL    TSTBRK          ; Test for break key
1052   082D C5                  PUSH    BC              ; Save address of next line
1053   082E CD FD 0B            CALL    PRNTCRLF        ; Output CRLF
1054   0831 5E                  LD      E,(HL)          ; Get LSB of line number
1055   0832 23                  INC     HL
1056   0833 56                  LD      D,(HL)          ; Get MSB of line number
1057   0834 23                  INC     HL
1058   0835 E5                  PUSH    HL              ; Save address of line start
1059   0836 EB                  EX      DE,HL           ; Line number to HL
1060   0837 CD 3E 19            CALL    PRNTHL          ; Output line number in decimal
1061   083A 3E 20               LD      A,' '           ; Space after line number
1062   083C E1                  POP     HL              ; Restore start of line address
1063   083D CD D6 07    LSTLP2: CALL    OUTC            ; Output character in A
1064   0840 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1065   0841 B7                  OR      A               ; End of line?
1066   0842 23                  INC     HL              ; To next byte in line
1067   0843 CA 1D 08            JP      Z,LISTLP        ; Yes - get next line
1068   0846 F2 3D 08            JP      P,LSTLP2        ; No token - output it
1069   0849 D6 7F               SUB     ZEND-1          ; Find and output word
1070   084B 4F                  LD      C,A             ; Token offset+1 to C
1071   084C 11 86 02            LD      DE,WORDS        ; Reserved word list
1072   084F 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1073   0850 13                  INC     DE              ; Move on to next
1074   0851 B7                  OR      A               ; Is it start of word?
1075   0852 F2 4F 08            JP      P,FNDTOK        ; No - Keep looking for word
1076   0855 0D                  DEC     C               ; Count words
1077   0856 C2 4F 08            JP      NZ,FNDTOK       ; Not there - keep looking
1078   0859 E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1079   085B CD D6 07            CALL    OUTC            ; Output first character
1080   085E 1A                  LD      A,(DE)          ; Get next character
1081   085F 13                  INC     DE              ; Move on to next
1082   0860 B7                  OR      A               ; Is it end of word?
1083   0861 F2 59 08            JP      P,OUTWRD        ; No - output the rest
1084   0864 C3 40 08            JP      LSTLP3          ; Next byte in line
1085   0867             
1086   0867 E5          SETLIN: PUSH    HL              ; Set up LINES counter
1087   0868 2A 8D 20            LD      HL,(LINESN)     ; Get LINES number
1088   086B 22 8B 20            LD      (LINESC),HL     ; Save in LINES counter
1089   086E E1                  POP     HL
1090   086F C9                  RET
1091   0870             
1092   0870 E5          COUNT:  PUSH    HL              ; Save code string address
1093   0871 D5                  PUSH    DE
1094   0872 2A 8B 20            LD      HL,(LINESC)     ; Get LINES counter
1095   0875 11 FF FF            LD      DE,-1
1096   0878 ED 5A               ADC     HL,DE           ; Decrement
1097   087A 22 8B 20            LD      (LINESC),HL     ; Put it back
1098   087D D1                  POP     DE
1099   087E E1                  POP     HL              ; Restore code string address
1100   087F F0                  RET     P               ; Return if more lines to go
1101   0880 E5                  PUSH    HL              ; Save code string address
1102   0881 2A 8D 20            LD      HL,(LINESN)     ; Get LINES number
1103   0884 22 8B 20            LD      (LINESC),HL     ; Reset LINES counter
1104   0887 CD 5A 1C            CALL    GETINP          ; Get input character
1105   088A FE 03               CP      CTRLC           ; Is it control "C"?
1106   088C CA 93 08            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1107   088F E1                  POP     HL              ; Restore code string address
1108   0890 C3 70 08            JP      COUNT           ; Keep on counting
1109   0893             
1110   0893 2A 8D 20    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1111   0896 22 8B 20            LD      (LINESC),HL     ; Reset LINES counter
1112   0899 C3 F7 01            JP      BRKRET          ; Go and output "Break"
1113   089C             
1114   089C 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1115   089E 32 10 21            LD      (FORFLG),A      ; Save "FOR" flag
1116   08A1 CD 03 0B            CALL    LET             ; Set up initial index
1117   08A4 C1                  POP     BC              ; Drop RETurn address
1118   08A5 E5                  PUSH    HL              ; Save code string address
1119   08A6 CD EC 0A            CALL    DATA            ; Get next statement address
1120   08A9 22 0C 21            LD      (LOOPST),HL     ; Save it for start of loop
1121   08AC 21 02 00            LD      HL,2            ; Offset for "FOR" block
1122   08AF 39                  ADD     HL,SP           ; Point to it
1123   08B0 CD AA 04    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1124   08B3 D1                  POP     DE              ; Get code string address
1125   08B4 C2 CC 08            JP      NZ,FORFND       ; No nesting found
1126   08B7 09                  ADD     HL,BC           ; Move into "FOR" block
1127   08B8 D5                  PUSH    DE              ; Save code string address
1128   08B9 2B                  DEC     HL
1129   08BA 56                  LD      D,(HL)          ; Get MSB of loop statement
1130   08BB 2B                  DEC     HL
1131   08BC 5E                  LD      E,(HL)          ; Get LSB of loop statement
1132   08BD 23                  INC     HL
1133   08BE 23                  INC     HL
1134   08BF E5                  PUSH    HL              ; Save block address
1135   08C0 2A 0C 21            LD      HL,(LOOPST)     ; Get address of loop statement
1136   08C3 CD C5 07            CALL    CPDEHL          ; Compare the FOR loops
1137   08C6 E1                  POP     HL              ; Restore block address
1138   08C7 C2 B0 08            JP      NZ,FORSLP       ; Different FORs - Find another
1139   08CA D1                  POP     DE              ; Restore code string address
1140   08CB F9                  LD      SP,HL           ; Remove all nested loops
1141   08CC             
1142   08CC EB          FORFND: EX      DE,HL           ; Code string address to HL
1143   08CD 0E 08               LD      C,8
1144   08CF CD DA 04            CALL    CHKSTK          ; Check for 8 levels of stack
1145   08D2 E5                  PUSH    HL              ; Save code string address
1146   08D3 2A 0C 21            LD      HL,(LOOPST)     ; Get first statement of loop
1147   08D6 E3                  EX      (SP),HL         ; Save and restore code string
1148   08D7 E5                  PUSH    HL              ; Re-save code string address
1149   08D8 2A A1 20            LD      HL,(LINEAT)     ; Get current line number
1150   08DB E3                  EX      (SP),HL         ; Save and restore code string
1151   08DC CD C5 0D            CALL    TSTNUM          ; Make sure it's a number
1152   08DF CD CB 07            CALL    CHKSYN          ; Make sure "TO" is next
1153   08E2 A6                  .BYTE   ZTO          ; "TO" token
1154   08E3 CD C2 0D            CALL    GETNUM          ; Get "TO" expression value
1155   08E6 E5                  PUSH    HL              ; Save code string address
1156   08E7 CD F0 17            CALL    BCDEFP          ; Move "TO" value to BCDE
1157   08EA E1                  POP     HL              ; Restore code string address
1158   08EB C5                  PUSH    BC              ; Save "TO" value in block
1159   08EC D5                  PUSH    DE
1160   08ED 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1161   08F0 51                  LD      D,C             ; C=0
1162   08F1 5A                  LD      E,D             ; D=0
1163   08F2 7E                  LD      A,(HL)          ; Get next byte in code string
1164   08F3 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1165   08F5 3E 01               LD      A,1             ; Sign of step = 1
1166   08F7 C2 08 09            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1167   08FA CD 55 09            CALL    GETCHR          ; Jump over "STEP" token
1168   08FD CD C2 0D            CALL    GETNUM          ; Get step value
1169   0900 E5                  PUSH    HL              ; Save code string address
1170   0901 CD F0 17            CALL    BCDEFP          ; Move STEP to BCDE
1171   0904 CD A4 17            CALL    TSTSGN          ; Test sign of FPREG
1172   0907 E1                  POP     HL              ; Restore code string address
1173   0908 C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1174   0909 D5                  PUSH    DE
1175   090A F5                  PUSH    AF              ; Save sign of STEP
1176   090B 33                  INC     SP              ; Don't save flags
1177   090C E5                  PUSH    HL              ; Save code string address
1178   090D 2A 13 21            LD      HL,(BRKLIN)     ; Get address of index variable
1179   0910 E3                  EX      (SP),HL         ; Save and restore code string
1180   0911 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1181   0913 C5                  PUSH    BC              ; Save it
1182   0914 33                  INC     SP              ; Don't save C
1183   0915             
1184   0915 CD 80 09    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1185   0918 22 13 21            LD      (BRKLIN),HL     ; Save code address for break
1186   091B 7E                  LD      A,(HL)          ; Get next byte in code string
1187   091C FE 3A               CP      ':'             ; Multi statement line?
1188   091E CA 35 09            JP      Z,EXCUTE        ; Yes - Execute it
1189   0921 B7                  OR      A               ; End of line?
1190   0922 C2 FD 04            JP      NZ,SNERR        ; No - Syntax error
1191   0925 23                  INC     HL              ; Point to address of next line
1192   0926 7E                  LD      A,(HL)          ; Get LSB of line pointer
1193   0927 23                  INC     HL
1194   0928 B6                  OR      (HL)            ; Is it zero (End of prog)?
1195   0929 CA A7 09            JP      Z,ENDPRG        ; Yes - Terminate execution
1196   092C 23                  INC     HL              ; Point to line number
1197   092D 5E                  LD      E,(HL)          ; Get LSB of line number
1198   092E 23                  INC     HL
1199   092F 56                  LD      D,(HL)          ; Get MSB of line number
1200   0930 EB                  EX      DE,HL           ; Line number to HL
1201   0931 22 A1 20            LD      (LINEAT),HL     ; Save as current line number
1202   0934 EB                  EX      DE,HL           ; Line number back to DE
1203   0935 CD 55 09    EXCUTE: CALL    GETCHR          ; Get key word
1204   0938 11 15 09            LD      DE,RUNCNT       ; Where to RETurn to
1205   093B D5                  PUSH    DE              ; Save for RETurn
1206   093C C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1207   093D D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1208   093F DA 03 0B            JP      C,LET           ; No - try to assign it
1209   0942 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1210   0944 D2 FD 04            JP      NC,SNERR        ; Not a key word - ?SN Error
1211   0947 07                  RLCA                    ; Double it
1212   0948 4F                  LD      C,A             ; BC = Offset into table
1213   0949 06 00               LD      B,0
1214   094B EB                  EX      DE,HL           ; Save code string address
1215   094C 21 A5 03            LD      HL,WORDTB       ; Keyword address table
1216   094F 09                  ADD     HL,BC           ; Point to routine address
1217   0950 4E                  LD      C,(HL)          ; Get LSB of routine address
1218   0951 23                  INC     HL
1219   0952 46                  LD      B,(HL)          ; Get MSB of routine address
1220   0953 C5                  PUSH    BC              ; Save routine address
1221   0954 EB                  EX      DE,HL           ; Restore code string address
1222   0955             
1223   0955 23          GETCHR: INC     HL              ; Point to next character
1224   0956 7E                  LD      A,(HL)          ; Get next code string byte
1225   0957 FE 3A               CP      ':'             ; Z if ':'
1226   0959 D0                  RET     NC              ; NC if > "9"
1227   095A FE 20               CP      ' '
1228   095C CA 55 09            JP      Z,GETCHR        ; Skip over spaces
1229   095F FE 30               CP      '0'
1230   0961 3F                  CCF                     ; NC if < '0'
1231   0962 3C                  INC     A               ; Test for zero - Leave carry
1232   0963 3D                  DEC     A               ; Z if Null
1233   0964 C9                  RET
1234   0965             
1235   0965 EB          RESTOR: EX      DE,HL           ; Save code string address
1236   0966 2A A3 20            LD      HL,(BASTXT)     ; Point to start of program
1237   0969 CA 7A 09            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1238   096C EB                  EX      DE,HL           ; Restore code string address
1239   096D CD 21 0A            CALL    ATOH            ; Get line number to DE
1240   0970 E5                  PUSH    HL              ; Save code string address
1241   0971 CD E9 05            CALL    SRCHLN          ; Search for line number in DE
1242   0974 60                  LD      H,B             ; HL = Address of line
1243   0975 69                  LD      L,C
1244   0976 D1                  POP     DE              ; Restore code string address
1245   0977 D2 C2 0A            JP      NC,ULERR        ; ?UL Error if not found
1246   097A 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1247   097B 22 21 21    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1248   097E EB                  EX      DE,HL           ; Restore code string address
1249   097F C9                  RET
1250   0980             
1251   0980             
1252   0980 DF          TSTBRK: RST     18H             ; Check input status
1253   0981 C8                  RET     Z               ; No key, go back
1254   0982 D7                  RST     10H             ; Get the key into A
1255   0983 FE 1B               CP      ESC             ; Escape key?
1256   0985 28 11               JR      Z,BRK           ; Yes, break
1257   0987 FE 03               CP      CTRLC           ; <Ctrl-C>
1258   0989 28 0D               JR      Z,BRK           ; Yes, break
1259   098B FE 13               CP      CTRLS           ; Stop scrolling?
1260   098D C0                  RET     NZ              ; Other key, ignore
1261   098E             
1262   098E             
1263   098E D7          STALL:  RST     10H             ; Wait for key
1264   098F FE 11               CP      CTRLQ           ; Resume scrolling?
1265   0991 C8                  RET      Z              ; Release the chokehold
1266   0992 FE 03               CP      CTRLC           ; Second break?
1267   0994 28 07               JR      Z,STOP          ; Break during hold exits prog
1268   0996 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1269   0998             
1270   0998 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1271   099A 32 92 20            LD      (BRKFLG),A      ; Store it
1272   099D             
1273   099D             
1274   099D C0          STOP:   RET     NZ              ; Exit if anything else
1275   099E F6                  .BYTE   0F6H            ; Flag "STOP"
1276   099F C0          PEND:   RET     NZ              ; Exit if anything else
1277   09A0 22 13 21            LD      (BRKLIN),HL     ; Save point of break
1278   09A3 21                  .BYTE   21H             ; Skip "OR 11111111B"
1279   09A4 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1280   09A6 C1                  POP     BC              ; Return not needed and more
1281   09A7 2A A1 20    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1282   09AA F5                  PUSH    AF              ; Save STOP / END status
1283   09AB 7D                  LD      A,L             ; Is it direct break?
1284   09AC A4                  AND     H
1285   09AD 3C                  INC     A               ; Line is -1 if direct break
1286   09AE CA BA 09            JP      Z,NOLIN         ; Yes - No line number
1287   09B1 22 17 21            LD      (ERRLIN),HL     ; Save line of break
1288   09B4 2A 13 21            LD      HL,(BRKLIN)     ; Get point of break
1289   09B7 22 19 21            LD      (CONTAD),HL     ; Save point to CONTinue
1290   09BA AF          NOLIN:  XOR     A
1291   09BB 32 8A 20            LD      (CTLOFG),A      ; Enable output
1292   09BE CD F0 0B            CALL    STTLIN          ; Start a new line
1293   09C1 F1                  POP     AF              ; Restore STOP / END status
1294   09C2 21 A0 04            LD      HL,BRKMSG       ; "Break" message
1295   09C5 C2 31 05            JP      NZ,ERRIN        ; "in line" wanted?
1296   09C8 C3 48 05            JP      PRNTOK          ; Go to command mode
1297   09CB             
1298   09CB 2A 19 21    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1299   09CE 7C                  LD      A,H             ; Is it zero?
1300   09CF B5                  OR      L
1301   09D0 1E 20               LD      E,CN            ; ?CN Error
1302   09D2 CA 11 05            JP      Z,ERROR         ; Yes - output "?CN Error"
1303   09D5 EB                  EX      DE,HL           ; Save code string address
1304   09D6 2A 17 21            LD      HL,(ERRLIN)     ; Get line of last break
1305   09D9 22 A1 20            LD      (LINEAT),HL     ; Set up current line number
1306   09DC EB                  EX      DE,HL           ; Restore code string address
1307   09DD C9                  RET                     ; CONTinue where left off
1308   09DE             
1309   09DE CD 23 15    NULL:   CALL    GETINT          ; Get integer 0-255
1310   09E1 C0                  RET     NZ              ; Return if bad value
1311   09E2 32 86 20            LD      (NULLS),A       ; Set nulls number
1312   09E5 C9                  RET
1313   09E6             
1314   09E6             
1315   09E6 E5          ACCSUM: PUSH    HL              ; Save address in array
1316   09E7 2A 8F 20            LD      HL,(CHKSUM)     ; Get check sum
1317   09EA 06 00               LD      B,0             ; BC - Value of byte
1318   09EC 4F                  LD      C,A
1319   09ED 09                  ADD     HL,BC           ; Add byte to check sum
1320   09EE 22 8F 20            LD      (CHKSUM),HL     ; Re-save check sum
1321   09F1 E1                  POP     HL              ; Restore address in array
1322   09F2 C9                  RET
1323   09F3             
1324   09F3 7E          CHKLTR: LD      A,(HL)          ; Get byte
1325   09F4 FE 41               CP      'A'             ; < 'a' ?
1326   09F6 D8                  RET     C               ; Carry set if not letter
1327   09F7 FE 5B               CP      'Z'+1           ; > 'z' ?
1328   09F9 3F                  CCF
1329   09FA C9                  RET                     ; Carry set if not letter
1330   09FB             
1331   09FB CD 55 09    FPSINT: CALL    GETCHR          ; Get next character
1332   09FE CD C2 0D    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1333   0A01 CD A4 17    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1334   0A04 FA 1C 0A            JP      M,FCERR         ; Negative - ?FC Error
1335   0A07 3A 2C 21    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1336   0A0A FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1337   0A0C DA 4C 18            JP      C,FPINT         ; Yes - convert it
1338   0A0F 01 80 90            LD      BC,9080H        ; BCDE = -32768
1339   0A12 11 00 00            LD      DE,0000
1340   0A15 E5                  PUSH    HL              ; Save code string address
1341   0A16 CD 1F 18            CALL    CMPNUM          ; Compare FPREG with BCDE
1342   0A19 E1                  POP     HL              ; Restore code string address
1343   0A1A 51                  LD      D,C             ; MSB to D
1344   0A1B C8                  RET     Z               ; Return if in range
1345   0A1C 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1346   0A1E C3 11 05            JP      ERROR           ; Output error-
1347   0A21             
1348   0A21 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1349   0A22 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1350   0A25 CD 55 09    GTLNLP: CALL    GETCHR          ; Get next character
1351   0A28 D0                  RET     NC              ; Exit if not a digit
1352   0A29 E5                  PUSH    HL              ; Save code string address
1353   0A2A F5                  PUSH    AF              ; Save digit
1354   0A2B 21 98 19            LD      HL,65529/10     ; Largest number 65529
1355   0A2E CD C5 07            CALL    CPDEHL          ; Number in range?
1356   0A31 DA FD 04            JP      C,SNERR         ; No - ?SN Error
1357   0A34 62                  LD      H,D             ; HL = Number
1358   0A35 6B                  LD      L,E
1359   0A36 19                  ADD     HL,DE           ; Times 2
1360   0A37 29                  ADD     HL,HL           ; Times 4
1361   0A38 19                  ADD     HL,DE           ; Times 5
1362   0A39 29                  ADD     HL,HL           ; Times 10
1363   0A3A F1                  POP     AF              ; Restore digit
1364   0A3B D6 30               SUB     '0'             ; Make it 0 to 9
1365   0A3D 5F                  LD      E,A             ; DE = Value of digit
1366   0A3E 16 00               LD      D,0
1367   0A40 19                  ADD     HL,DE           ; Add to number
1368   0A41 EB                  EX      DE,HL           ; Number to DE
1369   0A42 E1                  POP     HL              ; Restore code string address
1370   0A43 C3 25 0A            JP      GTLNLP          ; Go to next character
1371   0A46             
1372   0A46 CA 19 06    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1373   0A49 CD FE 09            CALL    POSINT          ; Get integer 0 to 32767 to DE
1374   0A4C 2B                  DEC     HL              ; Cancel increment
1375   0A4D CD 55 09            CALL    GETCHR          ; Get next character
1376   0A50 E5                  PUSH    HL              ; Save code string address
1377   0A51 2A F4 20            LD      HL,(LSTRAM)     ; Get end of RAM
1378   0A54 CA 69 0A            JP      Z,STORED        ; No value given - Use stored
1379   0A57 E1                  POP     HL              ; Restore code string address
1380   0A58 CD CB 07            CALL    CHKSYN          ; Check for comma
1381   0A5B 2C                  .BYTE      ','
1382   0A5C D5                  PUSH    DE              ; Save number
1383   0A5D CD FE 09            CALL    POSINT          ; Get integer 0 to 32767
1384   0A60 2B                  DEC     HL              ; Cancel increment
1385   0A61 CD 55 09            CALL    GETCHR          ; Get next character
1386   0A64 C2 FD 04            JP      NZ,SNERR        ; ?SN Error if more on line
1387   0A67 E3                  EX      (SP),HL         ; Save code string address
1388   0A68 EB                  EX      DE,HL           ; Number to DE
1389   0A69 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1390   0A6A 93                  SUB     E               ; Subtract LSB of string space
1391   0A6B 5F                  LD      E,A             ; Save LSB
1392   0A6C 7C                  LD      A,H             ; Get MSB of new RAM top
1393   0A6D 9A                  SBC     A,D             ; Subtract MSB of string space
1394   0A6E 57                  LD      D,A             ; Save MSB
1395   0A6F DA F2 04            JP      C,OMERR         ; ?OM Error if not enough mem
1396   0A72 E5                  PUSH    HL              ; Save RAM top
1397   0A73 2A 1B 21            LD      HL,(PROGND)     ; Get program end
1398   0A76 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1399   0A79 09                  ADD     HL,BC           ; Get lowest address
1400   0A7A CD C5 07            CALL    CPDEHL          ; Enough memory?
1401   0A7D D2 F2 04            JP      NC,OMERR        ; No - ?OM Error
1402   0A80 EB                  EX      DE,HL           ; RAM top to HL
1403   0A81 22 9F 20            LD      (STRSPC),HL     ; Set new string space
1404   0A84 E1                  POP     HL              ; End of memory to use
1405   0A85 22 F4 20            LD      (LSTRAM),HL     ; Set new top of RAM
1406   0A88 E1                  POP     HL              ; Restore code string address
1407   0A89 C3 19 06            JP      INTVAR          ; Initialise variables
1408   0A8C             
1409   0A8C CA 15 06    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1410   0A8F CD 19 06            CALL    INTVAR          ; Initialise variables
1411   0A92 01 15 09            LD      BC,RUNCNT       ; Execution driver loop
1412   0A95 C3 A8 0A            JP      RUNLIN          ; RUN from line number
1413   0A98             
1414   0A98 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1415   0A9A CD DA 04            CALL    CHKSTK          ; Check for 3 levels of stack
1416   0A9D C1                  POP     BC              ; Get return address
1417   0A9E E5                  PUSH    HL              ; Save code string for RETURN
1418   0A9F E5                  PUSH    HL              ; And for GOSUB routine
1419   0AA0 2A A1 20            LD      HL,(LINEAT)     ; Get current line
1420   0AA3 E3                  EX      (SP),HL         ; Into stack - Code string out
1421   0AA4 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1422   0AA6 F5                  PUSH    AF              ; Save token
1423   0AA7 33                  INC     SP              ; Don't save flags
1424   0AA8             
1425   0AA8 C5          RUNLIN: PUSH    BC              ; Save return address
1426   0AA9 CD 21 0A    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1427   0AAC CD EE 0A            CALL    REM             ; Get end of line
1428   0AAF E5                  PUSH    HL              ; Save end of line
1429   0AB0 2A A1 20            LD      HL,(LINEAT)     ; Get current line
1430   0AB3 CD C5 07            CALL    CPDEHL          ; Line after current?
1431   0AB6 E1                  POP     HL              ; Restore end of line
1432   0AB7 23                  INC     HL              ; Start of next line
1433   0AB8 DC EC 05            CALL    C,SRCHLP        ; Line is after current line
1434   0ABB D4 E9 05            CALL    NC,SRCHLN       ; Line is before current line
1435   0ABE 60                  LD      H,B             ; Set up code string address
1436   0ABF 69                  LD      L,C
1437   0AC0 2B                  DEC     HL              ; Incremented after
1438   0AC1 D8                  RET     C               ; Line found
1439   0AC2 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1440   0AC4 C3 11 05            JP      ERROR           ; Output error message
1441   0AC7             
1442   0AC7 C0          RETURN: RET     NZ              ; Return if not just RETURN
1443   0AC8 16 FF               LD      D,-1            ; Flag "GOSUB" search
1444   0ACA CD A6 04            CALL    BAKSTK          ; Look "GOSUB" block
1445   0ACD F9                  LD      SP,HL           ; Kill all FORs in subroutine
1446   0ACE FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1447   0AD0 1E 04               LD      E,RG            ; ?RG Error
1448   0AD2 C2 11 05            JP      NZ,ERROR        ; Error if no "GOSUB" found
1449   0AD5 E1                  POP     HL              ; Get RETURN line number
1450   0AD6 22 A1 20            LD      (LINEAT),HL     ; Save as current
1451   0AD9 23                  INC     HL              ; Was it from direct statement?
1452   0ADA 7C                  LD      A,H
1453   0ADB B5                  OR      L               ; Return to line
1454   0ADC C2 E6 0A            JP      NZ,RETLIN       ; No - Return to line
1455   0ADF 3A 11 21            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1456   0AE2 B7                  OR      A               ; If so buffer is corrupted
1457   0AE3 C2 47 05            JP      NZ,POPNOK       ; Yes - Go to command mode
1458   0AE6 21 15 09    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1459   0AE9 E3                  EX      (SP),HL         ; Into stack - Code string out
1460   0AEA 3E                  .BYTE      3EH             ; Skip "POP HL"
1461   0AEB E1          NXTDTA: POP     HL              ; Restore code string address
1462   0AEC             
1463   0AEC 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1464   0AEE 0E 00       REM:    LD      C,0             ; 00  End of statement
1465   0AF0 06 00               LD      B,0
1466   0AF2 79          NXTSTL: LD      A,C             ; Statement and byte
1467   0AF3 48                  LD      C,B
1468   0AF4 47                  LD      B,A             ; Statement end byte
1469   0AF5 7E          NXTSTT: LD      A,(HL)          ; Get byte
1470   0AF6 B7                  OR      A               ; End of line?
1471   0AF7 C8                  RET     Z               ; Yes - Exit
1472   0AF8 B8                  CP      B               ; End of statement?
1473   0AF9 C8                  RET     Z               ; Yes - Exit
1474   0AFA 23                  INC     HL              ; Next byte
1475   0AFB FE 22               CP      '"'             ; Literal string?
1476   0AFD CA F2 0A            JP      Z,NXTSTL        ; Yes - Look for another '"'
1477   0B00 C3 F5 0A            JP      NXTSTT          ; Keep looking
1478   0B03             
1479   0B03 CD B8 0F    LET:    CALL    GETVAR          ; Get variable name
1480   0B06 CD CB 07            CALL    CHKSYN          ; Make sure "=" follows
1481   0B09 B4                  .BYTE      ZEQUAL          ; "=" token
1482   0B0A D5                  PUSH    DE              ; Save address of variable
1483   0B0B 3A F2 20            LD      A,(TYPE)        ; Get data type
1484   0B0E F5                  PUSH    AF              ; Save type
1485   0B0F CD D4 0D            CALL    EVAL            ; Evaluate expression
1486   0B12 F1                  POP     AF              ; Restore type
1487   0B13 E3                  EX      (SP),HL         ; Save code - Get var addr
1488   0B14 22 13 21            LD      (BRKLIN),HL     ; Save address of variable
1489   0B17 1F                  RRA                     ; Adjust type
1490   0B18 CD C7 0D            CALL    CHKTYP          ; Check types are the same
1491   0B1B CA 56 0B            JP      Z,LETNUM        ; Numeric - Move value
1492   0B1E E5          LETSTR: PUSH    HL              ; Save address of string var
1493   0B1F 2A 29 21            LD      HL,(FPREG)      ; Pointer to string entry
1494   0B22 E5                  PUSH    HL              ; Save it on stack
1495   0B23 23                  INC     HL              ; Skip over length
1496   0B24 23                  INC     HL
1497   0B25 5E                  LD      E,(HL)          ; LSB of string address
1498   0B26 23                  INC     HL
1499   0B27 56                  LD      D,(HL)          ; MSB of string address
1500   0B28 2A A3 20            LD      HL,(BASTXT)     ; Point to start of program
1501   0B2B CD C5 07            CALL    CPDEHL          ; Is string before program?
1502   0B2E D2 45 0B            JP      NC,CRESTR       ; Yes - Create string entry
1503   0B31 2A 9F 20            LD      HL,(STRSPC)     ; Point to string space
1504   0B34 CD C5 07            CALL    CPDEHL          ; Is string literal in program?
1505   0B37 D1                  POP     DE              ; Restore address of string
1506   0B38 D2 4D 0B            JP      NC,MVSTPT       ; Yes - Set up pointer
1507   0B3B 21 04 21            LD      HL,TMPSTR       ; Temporary string pool
1508   0B3E CD C5 07            CALL    CPDEHL          ; Is string in temporary pool?
1509   0B41 D2 4D 0B            JP      NC,MVSTPT       ; No - Set up pointer
1510   0B44 3E                  .BYTE   3EH             ; Skip "POP DE"
1511   0B45 D1          CRESTR: POP     DE              ; Restore address of string
1512   0B46 CD FC 13            CALL    BAKTMP          ; Back to last tmp-str entry
1513   0B49 EB                  EX      DE,HL           ; Address of string entry
1514   0B4A CD 35 12            CALL    SAVSTR          ; Save string in string area
1515   0B4D CD FC 13    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1516   0B50 E1                  POP     HL              ; Get string pointer
1517   0B51 CD FF 17            CALL    DETHL4          ; Move string pointer to var
1518   0B54 E1                  POP     HL              ; Restore code string address
1519   0B55 C9                  RET
1520   0B56             
1521   0B56 E5          LETNUM: PUSH    HL              ; Save address of variable
1522   0B57 CD FC 17            CALL    FPTHL           ; Move value to variable
1523   0B5A D1                  POP     DE              ; Restore address of variable
1524   0B5B E1                  POP     HL              ; Restore code string address
1525   0B5C C9                  RET
1526   0B5D             
1527   0B5D CD 23 15    ON:     CALL    GETINT          ; Get integer 0-255
1528   0B60 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1529   0B61 47                  LD      B,A             ; Save in B
1530   0B62 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1531   0B64 CA 6C 0B            JP      Z,ONGO          ; Yes - Find line number
1532   0B67 CD CB 07            CALL    CHKSYN          ; Make sure it's "GOTO"
1533   0B6A 88                  .BYTE   ZGOTO           ; "GOTO" token
1534   0B6B 2B                  DEC     HL              ; Cancel increment
1535   0B6C 4B          ONGO:   LD      C,E             ; Integer of branch value
1536   0B6D 0D          ONGOLP: DEC     C               ; Count branches
1537   0B6E 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1538   0B6F CA 3D 09            JP      Z,ONJMP         ; Go to that line if right one
1539   0B72 CD 22 0A            CALL    GETLN           ; Get line number to DE
1540   0B75 FE 2C               CP      ','             ; Another line number?
1541   0B77 C0                  RET     NZ              ; No - Drop through
1542   0B78 C3 6D 0B            JP      ONGOLP          ; Yes - loop
1543   0B7B             
1544   0B7B CD D4 0D    IF:     CALL    EVAL            ; Evaluate expression
1545   0B7E 7E                  LD      A,(HL)          ; Get token
1546   0B7F FE 88               CP      ZGOTO           ; "GOTO" token?
1547   0B81 CA 89 0B            JP      Z,IFGO          ; Yes - Get line
1548   0B84 CD CB 07            CALL    CHKSYN          ; Make sure it's "THEN"
1549   0B87 A9                  .BYTE      ZTHEN           ; "THEN" token
1550   0B88 2B                  DEC     HL              ; Cancel increment
1551   0B89 CD C5 0D    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1552   0B8C CD A4 17            CALL    TSTSGN          ; Test state of expression
1553   0B8F CA EE 0A            JP      Z,REM           ; False - Drop through
1554   0B92 CD 55 09            CALL    GETCHR          ; Get next character
1555   0B95 DA A9 0A            JP      C,GOTO          ; Number - GOTO that line
1556   0B98 C3 3C 09            JP      IFJMP           ; Otherwise do statement
1557   0B9B             
1558   0B9B 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1559   0B9C CD 55 09            CALL    GETCHR          ; Get next character
1560   0B9F CA FD 0B    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1561   0BA2 C8          PRNTLP: RET     Z               ; End of list - Exit
1562   0BA3 FE A5               CP      ZTAB            ; "TAB(" token?
1563   0BA5 CA 30 0C            JP      Z,DOTAB         ; Yes - Do TAB routine
1564   0BA8 FE A8               CP      ZSPC            ; "SPC(" token?
1565   0BAA CA 30 0C            JP      Z,DOTAB         ; Yes - Do SPC routine
1566   0BAD E5                  PUSH    HL              ; Save code string address
1567   0BAE FE 2C               CP      ','             ; Comma?
1568   0BB0 CA 19 0C            JP      Z,DOCOM         ; Yes - Move to next zone
1569   0BB3 FE 3B               CP      59 ;";"         ; Semi-colon?
1570   0BB5 CA 53 0C            JP      Z,NEXITM        ; Do semi-colon routine
1571   0BB8 C1                  POP     BC              ; Code string address to BC
1572   0BB9 CD D4 0D            CALL    EVAL            ; Evaluate expression
1573   0BBC E5                  PUSH    HL              ; Save code string address
1574   0BBD 3A F2 20            LD      A,(TYPE)        ; Get variable type
1575   0BC0 B7                  OR      A               ; Is it a string variable?
1576   0BC1 C2 E9 0B            JP      NZ,PRNTST       ; Yes - Output string contents
1577   0BC4 CD 49 19            CALL    NUMASC          ; Convert number to text
1578   0BC7 CD 59 12            CALL    CRTST           ; Create temporary string
1579   0BCA 36 20               LD      (HL),' '        ; Followed by a space
1580   0BCC 2A 29 21            LD      HL,(FPREG)      ; Get length of output
1581   0BCF 34                  INC     (HL)            ; Plus 1 for the space
1582   0BD0 2A 29 21            LD      HL,(FPREG)      ; < Not needed >
1583   0BD3 3A 87 20            LD      A,(LWIDTH)      ; Get width of line
1584   0BD6 47                  LD      B,A             ; To B
1585   0BD7 04                  INC     B               ; Width 255 (No limit)?
1586   0BD8 CA E5 0B            JP      Z,PRNTNB        ; Yes - Output number string
1587   0BDB 04                  INC     B               ; Adjust it
1588   0BDC 3A F0 20            LD      A,(CURPOS)      ; Get cursor position
1589   0BDF 86                  ADD     A,(HL)          ; Add length of string
1590   0BE0 3D                  DEC     A               ; Adjust it
1591   0BE1 B8                  CP      B               ; Will output fit on this line?
1592   0BE2 D4 FD 0B            CALL    NC,PRNTCRLF     ; No - CRLF first
1593   0BE5 CD 9E 12    PRNTNB: CALL    PRS1            ; Output string at (HL)
1594   0BE8 AF                  XOR     A               ; Skip CALL by setting 'z' flag
1595   0BE9 C4 9E 12    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1596   0BEC E1                  POP     HL              ; Restore code string address
1597   0BED C3 9B 0B            JP      MRPRNT          ; See if more to PRINT
1598   0BF0             
1599   0BF0 3A F0 20    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1600   0BF3 B7                  OR      A               ; Already at start?
1601   0BF4 C8                  RET     Z               ; Yes - Do nothing
1602   0BF5 C3 FD 0B            JP      PRNTCRLF        ; Start a new line
1603   0BF8             
1604   0BF8 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1605   0BFA 21 A5 20            LD      HL,BUFFER-1     ; Point to buffer
1606   0BFD 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1607   0BFF CD D6 07            CALL    OUTC            ; Output character
1608   0C02 3E 0A               LD      A,LF            ; Load a LF
1609   0C04 CD D6 07            CALL    OUTC            ; Output character
1610   0C07 AF          DONULL: XOR     A               ; Set to position 0
1611   0C08 32 F0 20            LD      (CURPOS),A      ; Store it
1612   0C0B 3A 86 20            LD      A,(NULLS)       ; Get number of nulls
1613   0C0E 3D          NULLP:  DEC     A               ; Count them
1614   0C0F C8                  RET     Z               ; Return if done
1615   0C10 F5                  PUSH    AF              ; Save count
1616   0C11 AF                  XOR     A               ; Load a null
1617   0C12 CD D6 07            CALL    OUTC            ; Output it
1618   0C15 F1                  POP     AF              ; Restore count
1619   0C16 C3 0E 0C            JP      NULLP           ; Keep counting
1620   0C19             
1621   0C19 3A 88 20    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1622   0C1C 47                  LD      B,A             ; Save in B
1623   0C1D 3A F0 20            LD      A,(CURPOS)      ; Get current position
1624   0C20 B8                  CP      B               ; Within the limit?
1625   0C21 D4 FD 0B            CALL    NC,PRNTCRLF     ; No - output CRLF
1626   0C24 D2 53 0C            JP      NC,NEXITM       ; Get next item
1627   0C27 D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1628   0C29 D2 27 0C            JP      NC,ZONELP       ; Repeat if more zones
1629   0C2C 2F                  CPL                     ; Number of spaces to output
1630   0C2D C3 48 0C            JP      ASPCS           ; Output them
1631   0C30             
1632   0C30 F5          DOTAB:  PUSH    AF              ; Save token
1633   0C31 CD 20 15            CALL    FNDNUM          ; Evaluate expression
1634   0C34 CD CB 07            CALL    CHKSYN          ; Make sure ")" follows
1635   0C37 29                  .BYTE   ")"
1636   0C38 2B                  DEC     HL              ; Back space on to ")"
1637   0C39 F1                  POP     AF              ; Restore token
1638   0C3A D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1639   0C3C E5                  PUSH    HL              ; Save code string address
1640   0C3D CA 43 0C            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1641   0C40 3A F0 20            LD      A,(CURPOS)      ; Get current position
1642   0C43 2F          DOSPC:  CPL                     ; Number of spaces to print to
1643   0C44 83                  ADD     A,E             ; Total number to print
1644   0C45 D2 53 0C            JP      NC,NEXITM       ; TAB < Current POS(X)
1645   0C48 3C          ASPCS:  INC     A               ; Output A spaces
1646   0C49 47                  LD      B,A             ; Save number to print
1647   0C4A 3E 20               LD      A,' '           ; Space
1648   0C4C CD D6 07    SPCLP:  CALL    OUTC            ; Output character in A
1649   0C4F 05                  DEC     B               ; Count them
1650   0C50 C2 4C 0C            JP      NZ,SPCLP        ; Repeat if more
1651   0C53 E1          NEXITM: POP     HL              ; Restore code string address
1652   0C54 CD 55 09            CALL    GETCHR          ; Get next character
1653   0C57 C3 A2 0B            JP      PRNTLP          ; More to print
1654   0C5A             
1655   0C5A 3F 52 65 64 REDO:   .BYTE   "?Redo from start",CR,LF,0
1655   0C5E 6F 20 66 72 
1655   0C62 6F 6D 20 73 
1655   0C66 74 61 72 74 
1655   0C6A 0D 0A 00 
1656   0C6D             
1657   0C6D 3A 12 21    BADINP: LD      A,(READFG)      ; READ or INPUT?
1658   0C70 B7                  OR      A
1659   0C71 C2 F7 04            JP      NZ,DATSNR       ; READ - ?SN Error
1660   0C74 C1                  POP     BC              ; Throw away code string addr
1661   0C75 21 5A 0C            LD      HL,REDO         ; "Redo from start" message
1662   0C78 CD 9B 12            CALL    PRS             ; Output string
1663   0C7B C3 48 06            JP      DOAGN           ; Do last INPUT again
1664   0C7E             
1665   0C7E CD 06 12    INPUT:  CALL    IDTEST          ; Test for illegal direct
1666   0C81 7E                  LD      A,(HL)          ; Get character after "INPUT"
1667   0C82 FE 22               CP      '"'             ; Is there a prompt string?
1668   0C84 3E 00               LD      A,0             ; Clear A and leave flags
1669   0C86 32 8A 20            LD      (CTLOFG),A      ; Enable output
1670   0C89 C2 98 0C            JP      NZ,NOPMPT       ; No prompt - get input
1671   0C8C CD 5A 12            CALL    QTSTR           ; Get string terminated by '"'
1672   0C8F CD CB 07            CALL    CHKSYN          ; Check for ';' after prompt
1673   0C92 3B                  .BYTE   ';'
1674   0C93 E5                  PUSH    HL              ; Save code string address
1675   0C94 CD 9E 12            CALL    PRS1            ; Output prompt string
1676   0C97 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1677   0C98 E5          NOPMPT: PUSH    HL              ; Save code string address
1678   0C99 CD 4C 06            CALL    PROMPT          ; Get input with "? " prompt
1679   0C9C C1                  POP     BC              ; Restore code string address
1680   0C9D DA A4 09            JP      C,INPBRK        ; Break pressed - Exit
1681   0CA0 23                  INC     HL              ; Next byte
1682   0CA1 7E                  LD      A,(HL)          ; Get it
1683   0CA2 B7                  OR      A               ; End of line?
1684   0CA3 2B                  DEC     HL              ; Back again
1685   0CA4 C5                  PUSH    BC              ; Re-save code string address
1686   0CA5 CA EB 0A            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1687   0CA8 36 2C               LD      (HL),','        ; Store comma as separator
1688   0CAA C3 B2 0C            JP      NXTITM          ; Get next item
1689   0CAD             
1690   0CAD E5          READ:   PUSH    HL              ; Save code string address
1691   0CAE 2A 21 21            LD      HL,(NXTDAT)     ; Next DATA statement
1692   0CB1 F6                  .BYTE   0F6H            ; Flag "READ"
1693   0CB2 AF          NXTITM: XOR     A               ; Flag "INPUT"
1694   0CB3 32 12 21            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1695   0CB6 E3                  EX      (SP),HL         ; Get code str' , Save pointer
1696   0CB7 C3 BE 0C            JP      GTVLUS          ; Get values
1697   0CBA             
1698   0CBA CD CB 07    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1699   0CBD 2C                  .BYTE      ','
1700   0CBE CD B8 0F    GTVLUS: CALL    GETVAR          ; Get variable name
1701   0CC1 E3                  EX      (SP),HL         ; Save code str" , Get pointer
1702   0CC2 D5                  PUSH    DE              ; Save variable address
1703   0CC3 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1704   0CC4 FE 2C               CP      ','             ; Comma?
1705   0CC6 CA E6 0C            JP      Z,ANTVLU        ; Yes - Get another value
1706   0CC9 3A 12 21            LD      A,(READFG)      ; Is it READ?
1707   0CCC B7                  OR      A
1708   0CCD C2 53 0D            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1709   0CD0 3E 3F               LD      A,'?'           ; More INPUT needed
1710   0CD2 CD D6 07            CALL    OUTC            ; Output character
1711   0CD5 CD 4C 06            CALL    PROMPT          ; Get INPUT with prompt
1712   0CD8 D1                  POP     DE              ; Variable address
1713   0CD9 C1                  POP     BC              ; Code string address
1714   0CDA DA A4 09            JP      C,INPBRK        ; Break pressed
1715   0CDD 23                  INC     HL              ; Point to next DATA byte
1716   0CDE 7E                  LD      A,(HL)          ; Get byte
1717   0CDF B7                  OR      A               ; Is it zero (No input) ?
1718   0CE0 2B                  DEC     HL              ; Back space INPUT pointer
1719   0CE1 C5                  PUSH    BC              ; Save code string address
1720   0CE2 CA EB 0A            JP      Z,NXTDTA        ; Find end of buffer
1721   0CE5 D5                  PUSH    DE              ; Save variable address
1722   0CE6 3A F2 20    ANTVLU: LD      A,(TYPE)        ; Check data type
1723   0CE9 B7                  OR      A               ; Is it numeric?
1724   0CEA CA 10 0D            JP      Z,INPBIN        ; Yes - Convert to binary
1725   0CED CD 55 09            CALL    GETCHR          ; Get next character
1726   0CF0 57                  LD      D,A             ; Save input character
1727   0CF1 47                  LD      B,A             ; Again
1728   0CF2 FE 22               CP      '"'             ; Start of literal sting?
1729   0CF4 CA 04 0D            JP      Z,STRENT        ; Yes - Create string entry
1730   0CF7 3A 12 21            LD      A,(READFG)      ; "READ" or "INPUT" ?
1731   0CFA B7                  OR      A
1732   0CFB 57                  LD      D,A             ; Save 00 if "INPUT"
1733   0CFC CA 01 0D            JP      Z,ITMSEP        ; "INPUT" - End with 00
1734   0CFF 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1735   0D01 06 2C       ITMSEP: LD      B,','           ; Item separator
1736   0D03 2B                  DEC     HL              ; Back space for DTSTR
1737   0D04 CD 5D 12    STRENT: CALL    DTSTR           ; Get string terminated by D
1738   0D07 EB                  EX      DE,HL           ; String address to DE
1739   0D08 21 1B 0D            LD      HL,LTSTND       ; Where to go after LETSTR
1740   0D0B E3                  EX      (SP),HL         ; Save HL , get input pointer
1741   0D0C D5                  PUSH    DE              ; Save address of string
1742   0D0D C3 1E 0B            JP      LETSTR          ; Assign string to variable
1743   0D10             
1744   0D10 CD 55 09    INPBIN: CALL    GETCHR          ; Get next character
1745   0D13 CD AB 18            CALL    ASCTFP          ; Convert ASCII to FP number
1746   0D16 E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1747   0D17 CD FC 17            CALL    FPTHL           ; Move FPREG to variable
1748   0D1A E1                  POP     HL              ; Restore input pointer
1749   0D1B 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1750   0D1C CD 55 09            CALL    GETCHR          ; Get next character
1751   0D1F CA 27 0D            JP      Z,MORDT         ; End of line - More needed?
1752   0D22 FE 2C               CP      ','             ; Another value?
1753   0D24 C2 6D 0C            JP      NZ,BADINP       ; No - Bad input
1754   0D27 E3          MORDT:  EX      (SP),HL         ; Get code string address
1755   0D28 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1756   0D29 CD 55 09            CALL    GETCHR          ; Get next character
1757   0D2C C2 BA 0C            JP      NZ,NEDMOR       ; More needed - Get it
1758   0D2F D1                  POP     DE              ; Restore DATA pointer
1759   0D30 3A 12 21            LD      A,(READFG)      ; "READ" or "INPUT" ?
1760   0D33 B7                  OR      A
1761   0D34 EB                  EX      DE,HL           ; DATA pointer to HL
1762   0D35 C2 7B 09            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1763   0D38 D5                  PUSH    DE              ; Save code string address
1764   0D39 B6                  OR      (HL)            ; More input given?
1765   0D3A 21 42 0D            LD      HL,EXTIG        ; "?Extra ignored" message
1766   0D3D C4 9B 12            CALL    NZ,PRS          ; Output string if extra given
1767   0D40 E1                  POP     HL              ; Restore code string address
1768   0D41 C9                  RET
1769   0D42             
1770   0D42 3F 45 78 74 EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1770   0D46 72 61 20 69 
1770   0D4A 67 6E 6F 72 
1770   0D4E 65 64 0D 0A 
1770   0D52 00 
1771   0D53             
1772   0D53 CD EC 0A    FDTLP:  CALL    DATA            ; Get next statement
1773   0D56 B7                  OR      A               ; End of line?
1774   0D57 C2 6C 0D            JP      NZ,FANDT        ; No - See if DATA statement
1775   0D5A 23                  INC     HL
1776   0D5B 7E                  LD      A,(HL)          ; End of program?
1777   0D5C 23                  INC     HL
1778   0D5D B6                  OR      (HL)            ; 00 00 Ends program
1779   0D5E 1E 06               LD      E,OD            ; ?OD Error
1780   0D60 CA 11 05            JP      Z,ERROR         ; Yes - Out of DATA
1781   0D63 23                  INC     HL
1782   0D64 5E                  LD      E,(HL)          ; LSB of line number
1783   0D65 23                  INC     HL
1784   0D66 56                  LD      D,(HL)          ; MSB of line number
1785   0D67 EB                  EX      DE,HL
1786   0D68 22 0E 21            LD      (DATLIN),HL     ; Set line of current DATA item
1787   0D6B EB                  EX      DE,HL
1788   0D6C CD 55 09    FANDT:  CALL    GETCHR          ; Get next character
1789   0D6F FE 83               CP      ZDATA           ; "DATA" token
1790   0D71 C2 53 0D            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1791   0D74 C3 E6 0C            JP      ANTVLU          ; Found - Convert input
1792   0D77             
1793   0D77 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1794   0D7A C4 B8 0F    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1795   0D7D 22 13 21            LD      (BRKLIN),HL     ; Save code string address
1796   0D80 CD A6 04            CALL    BAKSTK          ; Look for "FOR" block
1797   0D83 C2 03 05            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1798   0D86 F9                  LD      SP,HL           ; Clear nested loops
1799   0D87 D5                  PUSH    DE              ; Save index address
1800   0D88 7E                  LD      A,(HL)          ; Get sign of STEP
1801   0D89 23                  INC     HL
1802   0D8A F5                  PUSH    AF              ; Save sign of STEP
1803   0D8B D5                  PUSH    DE              ; Save index address
1804   0D8C CD E2 17            CALL    PHLTFP          ; Move index value to FPREG
1805   0D8F E3                  EX      (SP),HL         ; Save address of TO value
1806   0D90 E5                  PUSH    HL              ; Save address of index
1807   0D91 CD 4F 15            CALL    ADDPHL          ; Add STEP to index value
1808   0D94 E1                  POP     HL              ; Restore address of index
1809   0D95 CD FC 17            CALL    FPTHL           ; Move value to index variable
1810   0D98 E1                  POP     HL              ; Restore address of TO value
1811   0D99 CD F3 17            CALL    LOADFP          ; Move TO value to BCDE
1812   0D9C E5                  PUSH    HL              ; Save address of line of FOR
1813   0D9D CD 1F 18            CALL    CMPNUM          ; Compare index with TO value
1814   0DA0 E1                  POP     HL              ; Restore address of line num
1815   0DA1 C1                  POP     BC              ; Address of sign of STEP
1816   0DA2 90                  SUB     B               ; Compare with expected sign
1817   0DA3 CD F3 17            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1818   0DA6 CA B2 0D            JP      Z,KILFOR        ; Loop finished - Terminate it
1819   0DA9 EB                  EX      DE,HL           ; Loop statement line number
1820   0DAA 22 A1 20            LD      (LINEAT),HL     ; Set loop line number
1821   0DAD 69                  LD      L,C             ; Set code string to loop
1822   0DAE 60                  LD      H,B
1823   0DAF C3 11 09            JP      PUTFID          ; Put back "FOR" and continue
1824   0DB2             
1825   0DB2 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1826   0DB3 2A 13 21            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1827   0DB6 7E                  LD      A,(HL)          ; Get next byte in code string
1828   0DB7 FE 2C               CP      ','             ; More NEXTs ?
1829   0DB9 C2 15 09            JP      NZ,RUNCNT       ; No - Do next statement
1830   0DBC CD 55 09            CALL    GETCHR          ; Position to index name
1831   0DBF CD 7A 0D            CALL    NEXT1           ; Re-enter NEXT routine
1832   0DC2             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1833   0DC2             
1834   0DC2 CD D4 0D    GETNUM: CALL    EVAL            ; Get a numeric expression
1835   0DC5 F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1836   0DC6 37          TSTSTR: SCF                     ; Set carry (string)
1837   0DC7 3A F2 20    CHKTYP: LD      A,(TYPE)        ; Check types match
1838   0DCA 8F                  ADC     A,A             ; Expected + actual
1839   0DCB B7                  OR      A               ; Clear carry , set parity
1840   0DCC E8                  RET     PE              ; Even parity - Types match
1841   0DCD C3 0F 05            JP      TMERR           ; Different types - Error
1842   0DD0             
1843   0DD0 CD CB 07    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1844   0DD3 28                  .BYTE   "("
1845   0DD4 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1846   0DD5 16 00               LD      D,0             ; Precedence value
1847   0DD7 D5          EVAL1:  PUSH    DE              ; Save precedence
1848   0DD8 0E 01               LD      C,1
1849   0DDA CD DA 04            CALL    CHKSTK          ; Check for 1 level of stack
1850   0DDD CD 4B 0E            CALL    OPRND           ; Get next expression value
1851   0DE0 22 15 21    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1852   0DE3 2A 15 21    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1853   0DE6 C1                  POP     BC              ; Precedence value and operator
1854   0DE7 78                  LD      A,B             ; Get precedence value
1855   0DE8 FE 78               CP      78H             ; "AND" or "OR" ?
1856   0DEA D4 C5 0D            CALL    NC,TSTNUM       ; No - Make sure it's a number
1857   0DED 7E                  LD      A,(HL)          ; Get next operator / function
1858   0DEE 16 00               LD      D,0             ; Clear Last relation
1859   0DF0 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1860   0DF2 DA 0C 0E            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1861   0DF5 FE 03               CP      ZLTH+1-ZGTR     ; < = >
1862   0DF7 D2 0C 0E            JP      NC,FOPRND       ; Function - Call it
1863   0DFA FE 01               CP      ZEQUAL-ZGTR     ; "="
1864   0DFC 17                  RLA                     ; <- Test for legal
1865   0DFD AA                  XOR     D               ; <- combinations of < = >
1866   0DFE BA                  CP      D               ; <- by combining last token
1867   0DFF 57                  LD      D,A             ; <- with current one
1868   0E00 DA FD 04            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1869   0E03 22 0A 21            LD      (CUROPR),HL     ; Save address of current token
1870   0E06 CD 55 09            CALL    GETCHR          ; Get next character
1871   0E09 C3 F0 0D            JP      RLTLP           ; Treat the two as one
1872   0E0C             
1873   0E0C 7A          FOPRND: LD      A,D             ; < = > found ?
1874   0E0D B7                  OR      A
1875   0E0E C2 33 0F            JP      NZ,TSTRED       ; Yes - Test for reduction
1876   0E11 7E                  LD      A,(HL)          ; Get operator token
1877   0E12 22 0A 21            LD      (CUROPR),HL     ; Save operator address
1878   0E15 D6 AC               SUB     ZPLUS           ; Operator or function?
1879   0E17 D8                  RET     C               ; Neither - Exit
1880   0E18 FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1881   0E1A D0                  RET     NC              ; No - Exit
1882   0E1B 5F                  LD      E,A             ; Coded operator
1883   0E1C 3A F2 20            LD      A,(TYPE)        ; Get data type
1884   0E1F 3D                  DEC     A               ; FF = numeric , 00 = string
1885   0E20 B3                  OR      E               ; Combine with coded operator
1886   0E21 7B                  LD      A,E             ; Get coded operator
1887   0E22 CA 91 13            JP      Z,CONCAT        ; String concatenation
1888   0E25 07                  RLCA                    ; Times 2
1889   0E26 83                  ADD     A,E             ; Times 3
1890   0E27 5F                  LD      E,A             ; To DE (D is 0)
1891   0E28 21 EF 03            LD      HL,PRITAB       ; Precedence table
1892   0E2B 19                  ADD     HL,DE           ; To the operator concerned
1893   0E2C 78                  LD      A,B             ; Last operator precedence
1894   0E2D 56                  LD      D,(HL)          ; Get evaluation precedence
1895   0E2E BA                  CP      D               ; Compare with eval precedence
1896   0E2F D0                  RET     NC              ; Exit if higher precedence
1897   0E30 23                  INC     HL              ; Point to routine address
1898   0E31 CD C5 0D            CALL    TSTNUM          ; Make sure it's a number
1899   0E34             
1900   0E34 C5          STKTHS: PUSH    BC              ; Save last precedence & token
1901   0E35 01 E3 0D            LD      BC,EVAL3        ; Where to go on prec' break
1902   0E38 C5                  PUSH    BC              ; Save on stack for return
1903   0E39 43                  LD      B,E             ; Save operator
1904   0E3A 4A                  LD      C,D             ; Save precedence
1905   0E3B CD D5 17            CALL    STAKFP          ; Move value to stack
1906   0E3E 58                  LD      E,B             ; Restore operator
1907   0E3F 51                  LD      D,C             ; Restore precedence
1908   0E40 4E                  LD      C,(HL)          ; Get LSB of routine address
1909   0E41 23                  INC     HL
1910   0E42 46                  LD      B,(HL)          ; Get MSB of routine address
1911   0E43 23                  INC     HL
1912   0E44 C5                  PUSH    BC              ; Save routine address
1913   0E45 2A 0A 21            LD      HL,(CUROPR)     ; Address of current operator
1914   0E48 C3 D7 0D            JP      EVAL1           ; Loop until prec' break
1915   0E4B             
1916   0E4B AF          OPRND:  XOR     A               ; Get operand routine
1917   0E4C 32 F2 20            LD      (TYPE),A        ; Set numeric expected
1918   0E4F CD 55 09            CALL    GETCHR          ; Get next character
1919   0E52 1E 24               LD      E,MO            ; ?MO Error
1920   0E54 CA 11 05            JP      Z,ERROR         ; No operand - Error
1921   0E57 DA AB 18            JP      C,ASCTFP        ; Number - Get value
1922   0E5A CD F3 09            CALL    CHKLTR          ; See if a letter
1923   0E5D D2 B2 0E            JP      NC,CONVAR       ; Letter - Find variable
1924   0E60 FE 26               CP		'&'				; &H = HEX, &B = BINARY
1925   0E62 20 12               JR		NZ, NOTAMP
1926   0E64 CD 55 09            CALL    GETCHR          ; Get next character
1927   0E67 FE 48               CP      'H'             ; Hex number indicated? [function added]
1928   0E69 CA EF 1C            JP      Z,HEXTFP        ; Convert Hex to FPREG
1929   0E6C FE 42               CP      'B'             ; Binary number indicated? [function added]
1930   0E6E CA 5F 1D            JP      Z,BINTFP        ; Convert Bin to FPREG
1931   0E71 1E 02               LD      E,SN            ; If neither then a ?SN Error
1932   0E73 CA 11 05            JP      Z,ERROR         ; 
1933   0E76 FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1934   0E78 CA 4B 0E            JP      Z,OPRND         ; Yes - Look for operand
1935   0E7B FE 2E               CP      '.'             ; '.' ?
1936   0E7D CA AB 18            JP      Z,ASCTFP        ; Yes - Create FP number
1937   0E80 FE AD               CP      ZMINUS          ; '-' Token ?
1938   0E82 CA A1 0E            JP      Z,MINUS         ; Yes - Do minus
1939   0E85 FE 22               CP      '"'             ; Literal string ?
1940   0E87 CA 5A 12            JP      Z,QTSTR         ; Get string terminated by '"'
1941   0E8A FE AA               CP      ZNOT            ; "NOT" Token ?
1942   0E8C CA 93 0F            JP      Z,EVNOT         ; Yes - Eval NOT expression
1943   0E8F FE A7               CP      ZFN             ; "FN" Token ?
1944   0E91 CA BE 11            JP      Z,DOFN          ; Yes - Do FN routine
1945   0E94 D6 B6               SUB     ZSGN            ; Is it a function?
1946   0E96 D2 C3 0E            JP      NC,FNOFST       ; Yes - Evaluate function
1947   0E99 CD D0 0D    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1948   0E9C CD CB 07            CALL    CHKSYN          ; Make sure ")" follows
1949   0E9F 29                  .BYTE   ")"
1950   0EA0 C9                  RET
1951   0EA1             
1952   0EA1 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1953   0EA3 CD D7 0D            CALL    EVAL1           ; Evaluate until prec' break
1954   0EA6 2A 15 21            LD      HL,(NXTOPR)     ; Get next operator address
1955   0EA9 E5                  PUSH    HL              ; Save next operator address
1956   0EAA CD CD 17            CALL    INVSGN          ; Negate value
1957   0EAD CD C5 0D    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1958   0EB0 E1                  POP     HL              ; Restore next operator address
1959   0EB1 C9                  RET
1960   0EB2             
1961   0EB2 CD B8 0F    CONVAR: CALL    GETVAR          ; Get variable address to DE
1962   0EB5 E5          FRMEVL: PUSH    HL              ; Save code string address
1963   0EB6 EB                  EX      DE,HL           ; Variable address to HL
1964   0EB7 22 29 21            LD      (FPREG),HL      ; Save address of variable
1965   0EBA 3A F2 20            LD      A,(TYPE)        ; Get type
1966   0EBD B7                  OR      A               ; Numeric?
1967   0EBE CC E2 17            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1968   0EC1 E1                  POP     HL              ; Restore code string address
1969   0EC2 C9                  RET
1970   0EC3             
1971   0EC3 06 00       FNOFST: LD      B,0             ; Get address of function
1972   0EC5 07                  RLCA                    ; Double function offset
1973   0EC6 4F                  LD      C,A             ; BC = Offset in function table
1974   0EC7 C5                  PUSH    BC              ; Save adjusted token value
1975   0EC8 CD 55 09            CALL    GETCHR          ; Get next character
1976   0ECB 79                  LD      A,C             ; Get adjusted token value
1977   0ECC FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1978   0ECE DA EA 0E            JP      C,FNVAL         ; No - Do function
1979   0ED1 CD D0 0D            CALL    OPNPAR          ; Evaluate expression  (X,...
1980   0ED4 CD CB 07            CALL    CHKSYN          ; Make sure ',' follows
1981   0ED7 2C                  .BYTE      ','
1982   0ED8 CD C6 0D            CALL    TSTSTR          ; Make sure it's a string
1983   0EDB EB                  EX      DE,HL           ; Save code string address
1984   0EDC 2A 29 21            LD      HL,(FPREG)      ; Get address of string
1985   0EDF E3                  EX      (SP),HL         ; Save address of string
1986   0EE0 E5                  PUSH    HL              ; Save adjusted token value
1987   0EE1 EB                  EX      DE,HL           ; Restore code string address
1988   0EE2 CD 23 15            CALL    GETINT          ; Get integer 0-255
1989   0EE5 EB                  EX      DE,HL           ; Save code string address
1990   0EE6 E3                  EX      (SP),HL         ; Save integer,HL = adj' token
1991   0EE7 C3 F2 0E            JP      GOFUNC          ; Jump to string function
1992   0EEA             
1993   0EEA CD 99 0E    FNVAL:  CALL    EVLPAR          ; Evaluate expression
1994   0EED E3                  EX      (SP),HL         ; HL = Adjusted token value
1995   0EEE 11 AD 0E            LD      DE,RETNUM       ; Return number from function
1996   0EF1 D5                  PUSH    DE              ; Save on stack
1997   0EF2 01 4E 02    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1998   0EF5 09                  ADD     HL,BC           ; Point to right address
1999   0EF6 4E                  LD      C,(HL)          ; Get LSB of address
2000   0EF7 23                  INC     HL              ;
2001   0EF8 66                  LD      H,(HL)          ; Get MSB of address
2002   0EF9 69                  LD      L,C             ; Address to HL
2003   0EFA E9                  JP      (HL)            ; Jump to function
2004   0EFB             
2005   0EFB 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2006   0EFC FE AD               CP      ZMINUS          ; '-' token ?
2007   0EFE C8                  RET     Z               ; Yes - Return
2008   0EFF FE 2D               CP      '-'             ; '-' ASCII ?
2009   0F01 C8                  RET     Z               ; Yes - Return
2010   0F02 14                  INC     D               ; Inc to flag positive exponent
2011   0F03 FE 2B               CP      '+'             ; '+' ASCII ?
2012   0F05 C8                  RET     Z               ; Yes - Return
2013   0F06 FE AC               CP      ZPLUS           ; '+' token ?
2014   0F08 C8                  RET     Z               ; Yes - Return
2015   0F09 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2016   0F0A C9                  RET                     ; Return "NZ"
2017   0F0B             
2018   0F0B F6          POR:    .BYTE      0F6H            ; Flag "OR"
2019   0F0C AF          PAND:   XOR     A               ; Flag "AND"
2020   0F0D F5                  PUSH    AF              ; Save "AND" / "OR" flag
2021   0F0E CD C5 0D            CALL    TSTNUM          ; Make sure it's a number
2022   0F11 CD 07 0A            CALL    DEINT           ; Get integer -32768 to 32767
2023   0F14 F1                  POP     AF              ; Restore "AND" / "OR" flag
2024   0F15 EB                  EX      DE,HL           ; <- Get last
2025   0F16 C1                  POP     BC              ; <-  value
2026   0F17 E3                  EX      (SP),HL         ; <-  from
2027   0F18 EB                  EX      DE,HL           ; <-  stack
2028   0F19 CD E5 17            CALL    FPBCDE          ; Move last value to FPREG
2029   0F1C F5                  PUSH    AF              ; Save "AND" / "OR" flag
2030   0F1D CD 07 0A            CALL    DEINT           ; Get integer -32768 to 32767
2031   0F20 F1                  POP     AF              ; Restore "AND" / "OR" flag
2032   0F21 C1                  POP     BC              ; Get value
2033   0F22 79                  LD      A,C             ; Get LSB
2034   0F23 21 7C 11            LD      HL,ACPASS       ; Address of save AC as current
2035   0F26 C2 2E 0F            JP      NZ,POR1         ; Jump if OR
2036   0F29 A3                  AND     E               ; "AND" LSBs
2037   0F2A 4F                  LD      C,A             ; Save LSB
2038   0F2B 78                  LD      A,B             ; Get MBS
2039   0F2C A2                  AND     D               ; "AND" MSBs
2040   0F2D E9                  JP      (HL)            ; Save AC as current (ACPASS)
2041   0F2E             
2042   0F2E B3          POR1:   OR      E               ; "OR" LSBs
2043   0F2F 4F                  LD      C,A             ; Save LSB
2044   0F30 78                  LD      A,B             ; Get MSB
2045   0F31 B2                  OR      D               ; "OR" MSBs
2046   0F32 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2047   0F33             
2048   0F33 21 45 0F    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2049   0F36 3A F2 20            LD      A,(TYPE)        ; Get data type
2050   0F39 1F                  RRA                     ; Carry set = string
2051   0F3A 7A                  LD      A,D             ; Get last precedence value
2052   0F3B 17                  RLA                     ; Times 2 plus carry
2053   0F3C 5F                  LD      E,A             ; To E
2054   0F3D 16 64               LD      D,64H           ; Relational precedence
2055   0F3F 78                  LD      A,B             ; Get current precedence
2056   0F40 BA                  CP      D               ; Compare with last
2057   0F41 D0                  RET     NC              ; Eval if last was rel' or log'
2058   0F42 C3 34 0E            JP      STKTHS          ; Stack this one and get next
2059   0F45             
2060   0F45 47 0F       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2061   0F47 79          CMPLG1: LD      A,C             ; Get data type
2062   0F48 B7                  OR      A
2063   0F49 1F                  RRA
2064   0F4A C1                  POP     BC              ; Get last expression to BCDE
2065   0F4B D1                  POP     DE
2066   0F4C F5                  PUSH    AF              ; Save status
2067   0F4D CD C7 0D            CALL    CHKTYP          ; Check that types match
2068   0F50 21 89 0F            LD      HL,CMPRES       ; Result to comparison
2069   0F53 E5                  PUSH    HL              ; Save for RETurn
2070   0F54 CA 1F 18            JP      Z,CMPNUM        ; Compare values if numeric
2071   0F57 AF                  XOR     A               ; Compare two strings
2072   0F58 32 F2 20            LD      (TYPE),A        ; Set type to numeric
2073   0F5B D5                  PUSH    DE              ; Save string name
2074   0F5C CD DE 13            CALL    GSTRCU          ; Get current string
2075   0F5F 7E                  LD      A,(HL)          ; Get length of string
2076   0F60 23                  INC     HL
2077   0F61 23                  INC     HL
2078   0F62 4E                  LD      C,(HL)          ; Get LSB of address
2079   0F63 23                  INC     HL
2080   0F64 46                  LD      B,(HL)          ; Get MSB of address
2081   0F65 D1                  POP     DE              ; Restore string name
2082   0F66 C5                  PUSH    BC              ; Save address of string
2083   0F67 F5                  PUSH    AF              ; Save length of string
2084   0F68 CD E2 13            CALL    GSTRDE          ; Get second string
2085   0F6B CD F3 17            CALL    LOADFP          ; Get address of second string
2086   0F6E F1                  POP     AF              ; Restore length of string 1
2087   0F6F 57                  LD      D,A             ; Length to D
2088   0F70 E1                  POP     HL              ; Restore address of string 1
2089   0F71 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2090   0F72 B2                  OR      D               ; Bytes of string 1 to do
2091   0F73 C8                  RET     Z               ; Exit if all bytes compared
2092   0F74 7A                  LD      A,D             ; Get bytes of string 1 to do
2093   0F75 D6 01               SUB     1
2094   0F77 D8                  RET     C               ; Exit if end of string 1
2095   0F78 AF                  XOR     A
2096   0F79 BB                  CP      E               ; Bytes of string 2 to do
2097   0F7A 3C                  INC     A
2098   0F7B D0                  RET     NC              ; Exit if end of string 2
2099   0F7C 15                  DEC     D               ; Count bytes in string 1
2100   0F7D 1D                  DEC     E               ; Count bytes in string 2
2101   0F7E 0A                  LD      A,(BC)          ; Byte in string 2
2102   0F7F BE                  CP      (HL)            ; Compare to byte in string 1
2103   0F80 23                  INC     HL              ; Move up string 1
2104   0F81 03                  INC     BC              ; Move up string 2
2105   0F82 CA 71 0F            JP      Z,CMPSTR        ; Same - Try next bytes
2106   0F85 3F                  CCF                     ; Flag difference (">" or "<")
2107   0F86 C3 AF 17            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2108   0F89             
2109   0F89 3C          CMPRES: INC     A               ; Increment current value
2110   0F8A 8F                  ADC     A,A             ; Double plus carry
2111   0F8B C1                  POP     BC              ; Get other value
2112   0F8C A0                  AND     B               ; Combine them
2113   0F8D C6 FF               ADD     A,-1            ; Carry set if different
2114   0F8F 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2115   0F90 C3 B6 17            JP      FLGREL          ; Set current value & continue
2116   0F93             
2117   0F93 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2118   0F95 CD D7 0D            CALL    EVAL1           ; Eval until precedence break
2119   0F98 CD C5 0D            CALL    TSTNUM          ; Make sure it's a number
2120   0F9B CD 07 0A            CALL    DEINT           ; Get integer -32768 - 32767
2121   0F9E 7B                  LD      A,E             ; Get LSB
2122   0F9F 2F                  CPL                     ; Invert LSB
2123   0FA0 4F                  LD      C,A             ; Save "NOT" of LSB
2124   0FA1 7A                  LD      A,D             ; Get MSB
2125   0FA2 2F                  CPL                     ; Invert MSB
2126   0FA3 CD 7C 11            CALL    ACPASS          ; Save AC as current
2127   0FA6 C1                  POP     BC              ; Clean up stack
2128   0FA7 C3 E3 0D            JP      EVAL3           ; Continue evaluation
2129   0FAA             
2130   0FAA 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2131   0FAB CD 55 09            CALL    GETCHR          ; Get next character
2132   0FAE C8                  RET     Z               ; End of DIM statement
2133   0FAF CD CB 07            CALL    CHKSYN          ; Make sure ',' follows
2134   0FB2 2C                  .BYTE      ','
2135   0FB3 01 AA 0F    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2136   0FB6 C5                  PUSH    BC              ; Save on stack
2137   0FB7 F6                  .BYTE      0F6H            ; Flag "Create" variable
2138   0FB8 AF          GETVAR: XOR     A               ; Find variable address,to DE
2139   0FB9 32 F1 20            LD      (LCRFLG),A      ; Set locate / create flag
2140   0FBC 46                  LD      B,(HL)          ; Get First byte of name
2141   0FBD CD F3 09    GTFNAM: CALL    CHKLTR          ; See if a letter
2142   0FC0 DA FD 04            JP      C,SNERR         ; ?SN Error if not a letter
2143   0FC3 AF                  XOR     A
2144   0FC4 4F                  LD      C,A             ; Clear second byte of name
2145   0FC5 32 F2 20            LD      (TYPE),A        ; Set type to numeric
2146   0FC8 CD 55 09            CALL    GETCHR          ; Get next character
2147   0FCB DA D4 0F            JP      C,SVNAM2        ; Numeric - Save in name
2148   0FCE CD F3 09            CALL    CHKLTR          ; See if a letter
2149   0FD1 DA E1 0F            JP      C,CHARTY        ; Not a letter - Check type
2150   0FD4 4F          SVNAM2: LD      C,A             ; Save second byte of name
2151   0FD5 CD 55 09    ENDNAM: CALL    GETCHR          ; Get next character
2152   0FD8 DA D5 0F            JP      C,ENDNAM        ; Numeric - Get another
2153   0FDB CD F3 09            CALL    CHKLTR          ; See if a letter
2154   0FDE D2 D5 0F            JP      NC,ENDNAM       ; Letter - Get another
2155   0FE1 D6 24       CHARTY: SUB     '$'             ; String variable?
2156   0FE3 C2 F0 0F            JP      NZ,NOTSTR       ; No - Numeric variable
2157   0FE6 3C                  INC     A               ; A = 1 (string type)
2158   0FE7 32 F2 20            LD      (TYPE),A        ; Set type to string
2159   0FEA 0F                  RRCA                    ; A = 80H , Flag for string
2160   0FEB 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2161   0FEC 4F                  LD      C,A             ; Resave second byte on name
2162   0FED CD 55 09            CALL    GETCHR          ; Get next character
2163   0FF0 3A 10 21    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2164   0FF3 3D                  DEC     A
2165   0FF4 CA 9D 10            JP      Z,ARLDSV        ; Yes - Get array name
2166   0FF7 F2 00 10            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2167   0FFA 7E                  LD      A,(HL)          ; Get byte again
2168   0FFB D6 28               SUB     '('             ; Subscripted variable?
2169   0FFD CA 75 10            JP      Z,SBSCPT        ; Yes - Sort out subscript
2170   1000             
2171   1000 AF          NSCFOR: XOR     A               ; Simple variable
2172   1001 32 10 21            LD      (FORFLG),A      ; Clear "FOR" flag
2173   1004 E5                  PUSH    HL              ; Save code string address
2174   1005 50                  LD      D,B             ; DE = Variable name to find
2175   1006 59                  LD      E,C
2176   1007 2A 23 21            LD      HL,(FNRGNM)     ; FN argument name
2177   100A CD C5 07            CALL    CPDEHL          ; Is it the FN argument?
2178   100D 11 25 21            LD      DE,FNARG        ; Point to argument value
2179   1010 CA E5 16            JP      Z,POPHRT        ; Yes - Return FN argument value
2180   1013 2A 1D 21            LD      HL,(VAREND)     ; End of variables
2181   1016 EB                  EX      DE,HL           ; Address of end of search
2182   1017 2A 1B 21            LD      HL,(PROGND)     ; Start of variables address
2183   101A CD C5 07    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2184   101D CA 33 10            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2185   1020 79                  LD      A,C             ; Get second byte of name
2186   1021 96                  SUB     (HL)            ; Compare with name in list
2187   1022 23                  INC     HL              ; Move on to first byte
2188   1023 C2 28 10            JP      NZ,FNTHR        ; Different - Find another
2189   1026 78                  LD      A,B             ; Get first byte of name
2190   1027 96                  SUB     (HL)            ; Compare with name in list
2191   1028 23          FNTHR:  INC     HL              ; Move on to LSB of value
2192   1029 CA 67 10            JP      Z,RETADR        ; Found - Return address
2193   102C 23                  INC     HL              ; <- Skip
2194   102D 23                  INC     HL              ; <- over
2195   102E 23                  INC     HL              ; <- F.P.
2196   102F 23                  INC     HL              ; <- value
2197   1030 C3 1A 10            JP      FNDVAR          ; Keep looking
2198   1033             
2199   1033 E1          CFEVAL: POP     HL              ; Restore code string address
2200   1034 E3                  EX      (SP),HL         ; Get return address
2201   1035 D5                  PUSH    DE              ; Save address of variable
2202   1036 11 B5 0E            LD      DE,FRMEVL       ; Return address in EVAL
2203   1039 CD C5 07            CALL    CPDEHL          ; Called from EVAL ?
2204   103C D1                  POP     DE              ; Restore address of variable
2205   103D CA 6A 10            JP      Z,RETNUL        ; Yes - Return null variable
2206   1040 E3                  EX      (SP),HL         ; Put back return
2207   1041 E5                  PUSH    HL              ; Save code string address
2208   1042 C5                  PUSH    BC              ; Save variable name
2209   1043 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2210   1046 2A 1F 21            LD      HL,(ARREND)     ; End of arrays
2211   1049 E5                  PUSH    HL              ; Save end of arrays
2212   104A 09                  ADD     HL,BC           ; Move up 6 bytes
2213   104B C1                  POP     BC              ; Source address in BC
2214   104C E5                  PUSH    HL              ; Save new end address
2215   104D CD C9 04            CALL    MOVUP           ; Move arrays up
2216   1050 E1                  POP     HL              ; Restore new end address
2217   1051 22 1F 21            LD      (ARREND),HL     ; Set new end address
2218   1054 60                  LD      H,B             ; End of variables to HL
2219   1055 69                  LD      L,C
2220   1056 22 1D 21            LD      (VAREND),HL     ; Set new end address
2221   1059             
2222   1059 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2223   105A 36 00               LD      (HL),0          ; Zero byte in variable
2224   105C CD C5 07            CALL    CPDEHL          ; Done them all?
2225   105F C2 59 10            JP      NZ,ZEROLP       ; No - Keep on going
2226   1062 D1                  POP     DE              ; Get variable name
2227   1063 73                  LD      (HL),E          ; Store second character
2228   1064 23                  INC     HL
2229   1065 72                  LD      (HL),D          ; Store first character
2230   1066 23                  INC     HL
2231   1067 EB          RETADR: EX      DE,HL           ; Address of variable in DE
2232   1068 E1                  POP     HL              ; Restore code string address
2233   1069 C9                  RET
2234   106A             
2235   106A 32 2C 21    RETNUL: LD      (FPEXP),A       ; Set result to zero
2236   106D 21 99 04            LD      HL,ZERBYT       ; Also set a null string
2237   1070 22 29 21            LD      (FPREG),HL      ; Save for EVAL
2238   1073 E1                  POP     HL              ; Restore code string address
2239   1074 C9                  RET
2240   1075             
2241   1075 E5          SBSCPT: PUSH    HL              ; Save code string address
2242   1076 2A F1 20            LD      HL,(LCRFLG)     ; Locate/Create and Type
2243   1079 E3                  EX      (SP),HL         ; Save and get code string
2244   107A 57                  LD      D,A             ; Zero number of dimensions
2245   107B D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2246   107C C5                  PUSH    BC              ; Save array name
2247   107D CD FB 09            CALL    FPSINT          ; Get subscript (0-32767)
2248   1080 C1                  POP     BC              ; Restore array name
2249   1081 F1                  POP     AF              ; Get number of dimensions
2250   1082 EB                  EX      DE,HL
2251   1083 E3                  EX      (SP),HL         ; Save subscript value
2252   1084 E5                  PUSH    HL              ; Save LCRFLG and TYPE
2253   1085 EB                  EX      DE,HL
2254   1086 3C                  INC     A               ; Count dimensions
2255   1087 57                  LD      D,A             ; Save in D
2256   1088 7E                  LD      A,(HL)          ; Get next byte in code string
2257   1089 FE 2C               CP      ','             ; Comma (more to come)?
2258   108B CA 7B 10            JP      Z,SCPTLP        ; Yes - More subscripts
2259   108E CD CB 07            CALL    CHKSYN          ; Make sure ")" follows
2260   1091 29                  .BYTE      ")"
2261   1092 22 15 21            LD      (NXTOPR),HL     ; Save code string address
2262   1095 E1                  POP     HL              ; Get LCRFLG and TYPE
2263   1096 22 F1 20            LD      (LCRFLG),HL     ; Restore Locate/create & type
2264   1099 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2265   109B D5                  PUSH    DE              ; Save number of dimensions (D)
2266   109C 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2267   109D             
2268   109D E5          ARLDSV: PUSH    HL              ; Save code string address
2269   109E F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2270   109F 2A 1D 21            LD      HL,(VAREND)     ; Start of arrays
2271   10A2 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2272   10A3 19          FNDARY: ADD     HL,DE           ; Move to next array start
2273   10A4 EB                  EX      DE,HL
2274   10A5 2A 1F 21            LD      HL,(ARREND)     ; End of arrays
2275   10A8 EB                  EX      DE,HL           ; Current array pointer
2276   10A9 CD C5 07            CALL    CPDEHL          ; End of arrays found?
2277   10AC CA D5 10            JP      Z,CREARY        ; Yes - Create array
2278   10AF 7E                  LD      A,(HL)          ; Get second byte of name
2279   10B0 B9                  CP      C               ; Compare with name given
2280   10B1 23                  INC     HL              ; Move on
2281   10B2 C2 B7 10            JP      NZ,NXTARY       ; Different - Find next array
2282   10B5 7E                  LD      A,(HL)          ; Get first byte of name
2283   10B6 B8                  CP      B               ; Compare with name given
2284   10B7 23          NXTARY: INC     HL              ; Move on
2285   10B8 5E                  LD      E,(HL)          ; Get LSB of next array address
2286   10B9 23                  INC     HL
2287   10BA 56                  LD      D,(HL)          ; Get MSB of next array address
2288   10BB 23                  INC     HL
2289   10BC C2 A3 10            JP      NZ,FNDARY       ; Not found - Keep looking
2290   10BF 3A F1 20            LD      A,(LCRFLG)      ; Found Locate or Create it?
2291   10C2 B7                  OR      A
2292   10C3 C2 06 05            JP      NZ,DDERR        ; Create - ?DD Error
2293   10C6 F1                  POP     AF              ; Locate - Get number of dim'ns
2294   10C7 44                  LD      B,H             ; BC Points to array dim'ns
2295   10C8 4D                  LD      C,L
2296   10C9 CA E5 16            JP      Z,POPHRT        ; Jump if array load/save
2297   10CC 96                  SUB     (HL)            ; Same number of dimensions?
2298   10CD CA 33 11            JP      Z,FINDEL        ; Yes - Find element
2299   10D0 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2300   10D2 C3 11 05            JP      ERROR           ; Output error
2301   10D5             
2302   10D5 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2303   10D8 F1                  POP     AF              ; Array to save or 0 dim'ns?
2304   10D9 CA 1C 0A            JP      Z,FCERR         ; Yes - ?FC Error
2305   10DC 71                  LD      (HL),C          ; Save second byte of name
2306   10DD 23                  INC     HL
2307   10DE 70                  LD      (HL),B          ; Save first byte of name
2308   10DF 23                  INC     HL
2309   10E0 4F                  LD      C,A             ; Number of dimensions to C
2310   10E1 CD DA 04            CALL    CHKSTK          ; Check if enough memory
2311   10E4 23                  INC     HL              ; Point to number of dimensions
2312   10E5 23                  INC     HL
2313   10E6 22 0A 21            LD      (CUROPR),HL     ; Save address of pointer
2314   10E9 71                  LD      (HL),C          ; Set number of dimensions
2315   10EA 23                  INC     HL
2316   10EB 3A F1 20            LD      A,(LCRFLG)      ; Locate of Create?
2317   10EE 17                  RLA                     ; Carry set = Create
2318   10EF 79                  LD      A,C             ; Get number of dimensions
2319   10F0 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2320   10F3 D2 F8 10            JP      NC,DEFSIZ       ; Locate - Set default size
2321   10F6 C1                  POP     BC              ; Get specified dimension size
2322   10F7 03                  INC     BC              ; Include zero element
2323   10F8 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2324   10F9 23                  INC     HL
2325   10FA 70                  LD      (HL),B          ; Save MSB of dimension size
2326   10FB 23                  INC     HL
2327   10FC F5                  PUSH    AF              ; Save num' of dim'ns an status
2328   10FD E5                  PUSH    HL              ; Save address of dim'n size
2329   10FE CD 90 18            CALL    MLDEBC          ; Multiply DE by BC to find
2330   1101 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2331   1102 E1                  POP     HL              ; Restore address of dimension
2332   1103 F1                  POP     AF              ; Restore number of dimensions
2333   1104 3D                  DEC     A               ; Count them
2334   1105 C2 F0 10            JP      NZ,CRARLP       ; Do next dimension if more
2335   1108 F5                  PUSH    AF              ; Save locate/create flag
2336   1109 42                  LD      B,D             ; MSB of memory needed
2337   110A 4B                  LD      C,E             ; LSB of memory needed
2338   110B EB                  EX      DE,HL
2339   110C 19                  ADD     HL,DE           ; Add bytes to array start
2340   110D DA F2 04            JP      C,OMERR         ; Too big - Error
2341   1110 CD E3 04            CALL    ENFMEM          ; See if enough memory
2342   1113 22 1F 21            LD      (ARREND),HL     ; Save new end of array
2343   1116             
2344   1116 2B          ZERARY: DEC     HL              ; Back through array data
2345   1117 36 00               LD      (HL),0          ; Set array element to zero
2346   1119 CD C5 07            CALL    CPDEHL          ; All elements zeroed?
2347   111C C2 16 11            JP      NZ,ZERARY       ; No - Keep on going
2348   111F 03                  INC     BC              ; Number of bytes + 1
2349   1120 57                  LD      D,A             ; A=0
2350   1121 2A 0A 21            LD      HL,(CUROPR)     ; Get address of array
2351   1124 5E                  LD      E,(HL)          ; Number of dimensions
2352   1125 EB                  EX      DE,HL           ; To HL
2353   1126 29                  ADD     HL,HL           ; Two bytes per dimension size
2354   1127 09                  ADD     HL,BC           ; Add number of bytes
2355   1128 EB                  EX      DE,HL           ; Bytes needed to DE
2356   1129 2B                  DEC     HL
2357   112A 2B                  DEC     HL
2358   112B 73                  LD      (HL),E          ; Save LSB of bytes needed
2359   112C 23                  INC     HL
2360   112D 72                  LD      (HL),D          ; Save MSB of bytes needed
2361   112E 23                  INC     HL
2362   112F F1                  POP     AF              ; Locate / Create?
2363   1130 DA 57 11            JP      C,ENDDIM        ; A is 0 , End if create
2364   1133 47          FINDEL: LD      B,A             ; Find array element
2365   1134 4F                  LD      C,A
2366   1135 7E                  LD      A,(HL)          ; Number of dimensions
2367   1136 23                  INC     HL
2368   1137 16                  .BYTE      16H             ; Skip "POP HL"
2369   1138 E1          FNDELP: POP     HL              ; Address of next dim' size
2370   1139 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2371   113A 23                  INC     HL
2372   113B 56                  LD      D,(HL)          ; Get MSB of dim'n size
2373   113C 23                  INC     HL
2374   113D E3                  EX      (SP),HL         ; Save address - Get index
2375   113E F5                  PUSH    AF              ; Save number of dim'ns
2376   113F CD C5 07            CALL    CPDEHL          ; Dimension too large?
2377   1142 D2 D0 10            JP      NC,BSERR        ; Yes - ?BS Error
2378   1145 E5                  PUSH    HL              ; Save index
2379   1146 CD 90 18            CALL    MLDEBC          ; Multiply previous by size
2380   1149 D1                  POP     DE              ; Index supplied to DE
2381   114A 19                  ADD     HL,DE           ; Add index to pointer
2382   114B F1                  POP     AF              ; Number of dimensions
2383   114C 3D                  DEC     A               ; Count them
2384   114D 44                  LD      B,H             ; MSB of pointer
2385   114E 4D                  LD      C,L             ; LSB of pointer
2386   114F C2 38 11            JP      NZ,FNDELP       ; More - Keep going
2387   1152 29                  ADD     HL,HL           ; 4 Bytes per element
2388   1153 29                  ADD     HL,HL
2389   1154 C1                  POP     BC              ; Start of array
2390   1155 09                  ADD     HL,BC           ; Point to element
2391   1156 EB                  EX      DE,HL           ; Address of element to DE
2392   1157 2A 15 21    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2393   115A C9                  RET
2394   115B             
2395   115B 2A 1F 21    FRE:    LD      HL,(ARREND)     ; Start of free memory
2396   115E EB                  EX      DE,HL           ; To DE
2397   115F 21 00 00            LD      HL,0            ; End of free memory
2398   1162 39                  ADD     HL,SP           ; Current stack value
2399   1163 3A F2 20            LD      A,(TYPE)        ; Dummy argument type
2400   1166 B7                  OR      A
2401   1167 CA 77 11            JP      Z,FRENUM        ; Numeric - Free variable space
2402   116A CD DE 13            CALL    GSTRCU          ; Current string to pool
2403   116D CD DE 12            CALL    GARBGE          ; Garbage collection
2404   1170 2A 9F 20            LD      HL,(STRSPC)     ; Bottom of string space in use
2405   1173 EB                  EX      DE,HL           ; To DE
2406   1174 2A 08 21            LD      HL,(STRBOT)     ; Bottom of string space
2407   1177 7D          FRENUM: LD      A,L             ; Get LSB of end
2408   1178 93                  SUB     E               ; Subtract LSB of beginning
2409   1179 4F                  LD      C,A             ; Save difference if C
2410   117A 7C                  LD      A,H             ; Get MSB of end
2411   117B 9A                  SBC     A,D             ; Subtract MSB of beginning
2412   117C 41          ACPASS: LD      B,C             ; Return integer AC
2413   117D 50          ABPASS: LD      D,B             ; Return integer AB
2414   117E 1E 00               LD      E,0
2415   1180 21 F2 20            LD      HL,TYPE         ; Point to type
2416   1183 73                  LD      (HL),E          ; Set type to numeric
2417   1184 06 90               LD      B,80H+16        ; 16 bit integer
2418   1186 C3 BB 17            JP      RETINT          ; Return the integr
2419   1189             
2420   1189 3A F0 20    POS:    LD      A,(CURPOS)      ; Get cursor position
2421   118C 47          PASSA:  LD      B,A             ; Put A into AB
2422   118D AF                  XOR     A               ; Zero A
2423   118E C3 7D 11            JP      ABPASS          ; Return integer AB
2424   1191             
2425   1191 CD 14 12    DEF:    CALL    CHEKFN          ; Get "FN" and name
2426   1194 CD 06 12            CALL    IDTEST          ; Test for illegal direct
2427   1197 01 EC 0A            LD      BC,DATA         ; To get next statement
2428   119A C5                  PUSH    BC              ; Save address for RETurn
2429   119B D5                  PUSH    DE              ; Save address of function ptr
2430   119C CD CB 07            CALL    CHKSYN          ; Make sure "(" follows
2431   119F 28                  .BYTE      "("
2432   11A0 CD B8 0F            CALL    GETVAR          ; Get argument variable name
2433   11A3 E5                  PUSH    HL              ; Save code string address
2434   11A4 EB                  EX      DE,HL           ; Argument address to HL
2435   11A5 2B                  DEC     HL
2436   11A6 56                  LD      D,(HL)          ; Get first byte of arg name
2437   11A7 2B                  DEC     HL
2438   11A8 5E                  LD      E,(HL)          ; Get second byte of arg name
2439   11A9 E1                  POP     HL              ; Restore code string address
2440   11AA CD C5 0D            CALL    TSTNUM          ; Make sure numeric argument
2441   11AD CD CB 07            CALL    CHKSYN          ; Make sure ")" follows
2442   11B0 29                  .BYTE      ")"
2443   11B1 CD CB 07            CALL    CHKSYN          ; Make sure "=" follows
2444   11B4 B4                  .BYTE      ZEQUAL          ; "=" token
2445   11B5 44                  LD      B,H             ; Code string address to BC
2446   11B6 4D                  LD      C,L
2447   11B7 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2448   11B8 71                  LD      (HL),C          ; Save LSB of FN code string
2449   11B9 23                  INC     HL
2450   11BA 70                  LD      (HL),B          ; Save MSB of FN code string
2451   11BB C3 53 12            JP      SVSTAD          ; Save address and do function
2452   11BE             
2453   11BE CD 14 12    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2454   11C1 D5                  PUSH    DE              ; Save function pointer address
2455   11C2 CD 99 0E            CALL    EVLPAR          ; Evaluate expression in "()"
2456   11C5 CD C5 0D            CALL    TSTNUM          ; Make sure numeric result
2457   11C8 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2458   11C9 5E                  LD      E,(HL)          ; Get LSB of FN code string
2459   11CA 23                  INC     HL
2460   11CB 56                  LD      D,(HL)          ; Get MSB of FN code string
2461   11CC 23                  INC     HL
2462   11CD 7A                  LD      A,D             ; And function DEFined?
2463   11CE B3                  OR      E
2464   11CF CA 09 05            JP      Z,UFERR         ; No - ?UF Error
2465   11D2 7E                  LD      A,(HL)          ; Get LSB of argument address
2466   11D3 23                  INC     HL
2467   11D4 66                  LD      H,(HL)          ; Get MSB of argument address
2468   11D5 6F                  LD      L,A             ; HL = Arg variable address
2469   11D6 E5                  PUSH    HL              ; Save it
2470   11D7 2A 23 21            LD      HL,(FNRGNM)     ; Get old argument name
2471   11DA E3                  EX      (SP),HL ;       ; Save old , Get new
2472   11DB 22 23 21            LD      (FNRGNM),HL     ; Set new argument name
2473   11DE 2A 27 21            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2474   11E1 E5                  PUSH    HL              ; Save it
2475   11E2 2A 25 21            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2476   11E5 E5                  PUSH    HL              ; Save it
2477   11E6 21 25 21            LD      HL,FNARG        ; HL = Value of argument
2478   11E9 D5                  PUSH    DE              ; Save FN code string address
2479   11EA CD FC 17            CALL    FPTHL           ; Move FPREG to argument
2480   11ED E1                  POP     HL              ; Get FN code string address
2481   11EE CD C2 0D            CALL    GETNUM          ; Get value from function
2482   11F1 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2483   11F2 CD 55 09            CALL    GETCHR          ; Get next character
2484   11F5 C2 FD 04            JP      NZ,SNERR        ; Bad character in FN - Error
2485   11F8 E1                  POP     HL              ; Get MSB,EXP of old arg
2486   11F9 22 25 21            LD      (FNARG),HL      ; Restore it
2487   11FC E1                  POP     HL              ; Get LSB,NLSB of old arg
2488   11FD 22 27 21            LD      (FNARG+2),HL    ; Restore it
2489   1200 E1                  POP     HL              ; Get name of old arg
2490   1201 22 23 21            LD      (FNRGNM),HL     ; Restore it
2491   1204 E1                  POP     HL              ; Restore code string address
2492   1205 C9                  RET
2493   1206             
2494   1206 E5          IDTEST: PUSH    HL              ; Save code string address
2495   1207 2A A1 20            LD      HL,(LINEAT)     ; Get current line number
2496   120A 23                  INC     HL              ; -1 means direct statement
2497   120B 7C                  LD      A,H
2498   120C B5                  OR      L
2499   120D E1                  POP     HL              ; Restore code string address
2500   120E C0                  RET     NZ              ; Return if in program
2501   120F 1E 16               LD      E,ID            ; ?ID Error
2502   1211 C3 11 05            JP      ERROR
2503   1214             
2504   1214 CD CB 07    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2505   1217 A7                  .BYTE      ZFN             ; "FN" token
2506   1218 3E 80               LD      A,80H
2507   121A 32 10 21            LD      (FORFLG),A      ; Flag FN name to find
2508   121D B6                  OR      (HL)            ; FN name has bit 7 set
2509   121E 47                  LD      B,A             ; in first byte of name
2510   121F CD BD 0F            CALL    GTFNAM          ; Get FN name
2511   1222 C3 C5 0D            JP      TSTNUM          ; Make sure numeric function
2512   1225             
2513   1225 CD C5 0D    STR:    CALL    TSTNUM          ; Make sure it's a number
2514   1228 CD 49 19            CALL    NUMASC          ; Turn number into text
2515   122B CD 59 12    STR1:   CALL    CRTST           ; Create string entry for it
2516   122E CD DE 13            CALL    GSTRCU          ; Current string to pool
2517   1231 01 39 14            LD      BC,TOPOOL       ; Save in string pool
2518   1234 C5                  PUSH    BC              ; Save address on stack
2519   1235             
2520   1235 7E          SAVSTR: LD      A,(HL)          ; Get string length
2521   1236 23                  INC     HL
2522   1237 23                  INC     HL
2523   1238 E5                  PUSH    HL              ; Save pointer to string
2524   1239 CD B4 12            CALL    TESTR           ; See if enough string space
2525   123C E1                  POP     HL              ; Restore pointer to string
2526   123D 4E                  LD      C,(HL)          ; Get LSB of address
2527   123E 23                  INC     HL
2528   123F 46                  LD      B,(HL)          ; Get MSB of address
2529   1240 CD 4D 12            CALL    CRTMST          ; Create string entry
2530   1243 E5                  PUSH    HL              ; Save pointer to MSB of addr
2531   1244 6F                  LD      L,A             ; Length of string
2532   1245 CD D1 13            CALL    TOSTRA          ; Move to string area
2533   1248 D1                  POP     DE              ; Restore pointer to MSB
2534   1249 C9                  RET
2535   124A             
2536   124A CD B4 12    MKTMST: CALL    TESTR           ; See if enough string space
2537   124D 21 04 21    CRTMST: LD      HL,TMPSTR       ; Temporary string
2538   1250 E5                  PUSH    HL              ; Save it
2539   1251 77                  LD      (HL),A          ; Save length of string
2540   1252 23                  INC     HL
2541   1253 23          SVSTAD: INC     HL
2542   1254 73                  LD      (HL),E          ; Save LSB of address
2543   1255 23                  INC     HL
2544   1256 72                  LD      (HL),D          ; Save MSB of address
2545   1257 E1                  POP     HL              ; Restore pointer
2546   1258 C9                  RET
2547   1259             
2548   1259 2B          CRTST:  DEC     HL              ; DEC - INCed after
2549   125A 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2550   125C 50                  LD      D,B             ; Quote to D
2551   125D E5          DTSTR:  PUSH    HL              ; Save start
2552   125E 0E FF               LD      C,-1            ; Set counter to -1
2553   1260 23          QTSTLP: INC     HL              ; Move on
2554   1261 7E                  LD      A,(HL)          ; Get byte
2555   1262 0C                  INC     C               ; Count bytes
2556   1263 B7                  OR      A               ; End of line?
2557   1264 CA 6F 12            JP      Z,CRTSTE        ; Yes - Create string entry
2558   1267 BA                  CP      D               ; Terminator D found?
2559   1268 CA 6F 12            JP      Z,CRTSTE        ; Yes - Create string entry
2560   126B B8                  CP      B               ; Terminator B found?
2561   126C C2 60 12            JP      NZ,QTSTLP       ; No - Keep looking
2562   126F FE 22       CRTSTE: CP      '"'             ; End with '"'?
2563   1271 CC 55 09            CALL    Z,GETCHR        ; Yes - Get next character
2564   1274 E3                  EX      (SP),HL         ; Starting quote
2565   1275 23                  INC     HL              ; First byte of string
2566   1276 EB                  EX      DE,HL           ; To DE
2567   1277 79                  LD      A,C             ; Get length
2568   1278 CD 4D 12            CALL    CRTMST          ; Create string entry
2569   127B 11 04 21    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2570   127E 2A F6 20            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2571   1281 22 29 21            LD      (FPREG),HL      ; Save address of string ptr
2572   1284 3E 01               LD      A,1
2573   1286 32 F2 20            LD      (TYPE),A        ; Set type to string
2574   1289 CD FF 17            CALL    DETHL4          ; Move string to pool
2575   128C CD C5 07            CALL    CPDEHL          ; Out of string pool?
2576   128F 22 F6 20            LD      (TMSTPT),HL     ; Save new pointer
2577   1292 E1                  POP     HL              ; Restore code string address
2578   1293 7E                  LD      A,(HL)          ; Get next code byte
2579   1294 C0                  RET     NZ              ; Return if pool OK
2580   1295 1E 1E               LD      E,ST            ; ?ST Error
2581   1297 C3 11 05            JP      ERROR           ; String pool overflow
2582   129A             
2583   129A 23          PRNUMS: INC     HL              ; Skip leading space
2584   129B CD 59 12    PRS:    CALL    CRTST           ; Create string entry for it
2585   129E CD DE 13    PRS1:   CALL    GSTRCU          ; Current string to pool
2586   12A1 CD F3 17            CALL    LOADFP          ; Move string block to BCDE
2587   12A4 1C                  INC     E               ; Length + 1
2588   12A5 1D          PRSLP:  DEC     E               ; Count characters
2589   12A6 C8                  RET     Z               ; End of string
2590   12A7 0A                  LD      A,(BC)          ; Get byte to output
2591   12A8 CD D6 07            CALL    OUTC            ; Output character in A
2592   12AB FE 0D               CP      CR              ; Return?
2593   12AD CC 07 0C            CALL    Z,DONULL        ; Yes - Do nulls
2594   12B0 03                  INC     BC              ; Next byte in string
2595   12B1 C3 A5 12            JP      PRSLP           ; More characters to output
2596   12B4             
2597   12B4 B7          TESTR:  OR      A               ; Test if enough room
2598   12B5 0E                  .BYTE      0EH             ; No garbage collection done
2599   12B6 F1          GRBDON: POP     AF              ; Garbage collection done
2600   12B7 F5                  PUSH    AF              ; Save status
2601   12B8 2A 9F 20            LD      HL,(STRSPC)     ; Bottom of string space in use
2602   12BB EB                  EX      DE,HL           ; To DE
2603   12BC 2A 08 21            LD      HL,(STRBOT)     ; Bottom of string area
2604   12BF 2F                  CPL                     ; Negate length (Top down)
2605   12C0 4F                  LD      C,A             ; -Length to BC
2606   12C1 06 FF               LD      B,-1            ; BC = -ve length of string
2607   12C3 09                  ADD     HL,BC           ; Add to bottom of space in use
2608   12C4 23                  INC     HL              ; Plus one for 2's complement
2609   12C5 CD C5 07            CALL    CPDEHL          ; Below string RAM area?
2610   12C8 DA D2 12            JP      C,TESTOS        ; Tidy up if not done else err
2611   12CB 22 08 21            LD      (STRBOT),HL     ; Save new bottom of area
2612   12CE 23                  INC     HL              ; Point to first byte of string
2613   12CF EB                  EX      DE,HL           ; Address to DE
2614   12D0 F1          POPAF:  POP     AF              ; Throw away status push
2615   12D1 C9                  RET
2616   12D2             
2617   12D2 F1          TESTOS: POP     AF              ; Garbage collect been done?
2618   12D3 1E 1A               LD      E,OS            ; ?OS Error
2619   12D5 CA 11 05            JP      Z,ERROR         ; Yes - Not enough string apace
2620   12D8 BF                  CP      A               ; Flag garbage collect done
2621   12D9 F5                  PUSH    AF              ; Save status
2622   12DA 01 B6 12            LD      BC,GRBDON       ; Garbage collection done
2623   12DD C5                  PUSH    BC              ; Save for RETurn
2624   12DE 2A F4 20    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2625   12E1 22 08 21    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2626   12E4 21 00 00            LD      HL,0
2627   12E7 E5                  PUSH    HL              ; Flag no string found
2628   12E8 2A 9F 20            LD      HL,(STRSPC)     ; Get bottom of string space
2629   12EB E5                  PUSH    HL              ; Save bottom of string space
2630   12EC 21 F8 20            LD      HL,TMSTPL       ; Temporary string pool
2631   12EF EB          GRBLP:  EX      DE,HL
2632   12F0 2A F6 20            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2633   12F3 EB                  EX      DE,HL
2634   12F4 CD C5 07            CALL    CPDEHL          ; Temporary string pool done?
2635   12F7 01 EF 12            LD      BC,GRBLP        ; Loop until string pool done
2636   12FA C2 43 13            JP      NZ,STPOOL       ; No - See if in string area
2637   12FD 2A 1B 21            LD      HL,(PROGND)     ; Start of simple variables
2638   1300 EB          SMPVAR: EX      DE,HL
2639   1301 2A 1D 21            LD      HL,(VAREND)     ; End of simple variables
2640   1304 EB                  EX      DE,HL
2641   1305 CD C5 07            CALL    CPDEHL          ; All simple strings done?
2642   1308 CA 16 13            JP      Z,ARRLP         ; Yes - Do string arrays
2643   130B 7E                  LD      A,(HL)          ; Get type of variable
2644   130C 23                  INC     HL
2645   130D 23                  INC     HL
2646   130E B7                  OR      A               ; "S" flag set if string
2647   130F CD 46 13            CALL    STRADD          ; See if string in string area
2648   1312 C3 00 13            JP      SMPVAR          ; Loop until simple ones done
2649   1315             
2650   1315 C1          GNXARY: POP     BC              ; Scrap address of this array
2651   1316 EB          ARRLP:  EX      DE,HL
2652   1317 2A 1F 21            LD      HL,(ARREND)     ; End of string arrays
2653   131A EB                  EX      DE,HL
2654   131B CD C5 07            CALL    CPDEHL          ; All string arrays done?
2655   131E CA 6C 13            JP      Z,SCNEND        ; Yes - Move string if found
2656   1321 CD F3 17            CALL    LOADFP          ; Get array name to BCDE
2657   1324 7B                  LD      A,E             ; Get type of array     
2658   1325 E5                  PUSH    HL              ; Save address of num of dim'ns
2659   1326 09                  ADD     HL,BC           ; Start of next array
2660   1327 B7                  OR      A               ; Test type of array
2661   1328 F2 15 13            JP      P,GNXARY        ; Numeric array - Ignore it
2662   132B 22 0A 21            LD      (CUROPR),HL     ; Save address of next array
2663   132E E1                  POP     HL              ; Get address of num of dim'ns
2664   132F 4E                  LD      C,(HL)          ; BC = Number of dimensions
2665   1330 06 00               LD      B,0
2666   1332 09                  ADD     HL,BC           ; Two bytes per dimension size
2667   1333 09                  ADD     HL,BC
2668   1334 23                  INC     HL              ; Plus one for number of dim'ns
2669   1335 EB          GRBARY: EX      DE,HL
2670   1336 2A 0A 21            LD      HL,(CUROPR)     ; Get address of next array
2671   1339 EB                  EX      DE,HL
2672   133A CD C5 07            CALL    CPDEHL          ; Is this array finished?
2673   133D CA 16 13            JP      Z,ARRLP         ; Yes - Get next one
2674   1340 01 35 13            LD      BC,GRBARY       ; Loop until array all done
2675   1343 C5          STPOOL: PUSH    BC              ; Save return address
2676   1344 F6 80               OR      80H             ; Flag string type
2677   1346 7E          STRADD: LD      A,(HL)          ; Get string length
2678   1347 23                  INC     HL
2679   1348 23                  INC     HL
2680   1349 5E                  LD      E,(HL)          ; Get LSB of string address
2681   134A 23                  INC     HL
2682   134B 56                  LD      D,(HL)          ; Get MSB of string address
2683   134C 23                  INC     HL
2684   134D F0                  RET     P               ; Not a string - Return
2685   134E B7                  OR      A               ; Set flags on string length
2686   134F C8                  RET     Z               ; Null string - Return
2687   1350 44                  LD      B,H             ; Save variable pointer
2688   1351 4D                  LD      C,L
2689   1352 2A 08 21            LD      HL,(STRBOT)     ; Bottom of new area
2690   1355 CD C5 07            CALL    CPDEHL          ; String been done?
2691   1358 60                  LD      H,B             ; Restore variable pointer
2692   1359 69                  LD      L,C
2693   135A D8                  RET     C               ; String done - Ignore
2694   135B E1                  POP     HL              ; Return address
2695   135C E3                  EX      (SP),HL         ; Lowest available string area
2696   135D CD C5 07            CALL    CPDEHL          ; String within string area?
2697   1360 E3                  EX      (SP),HL         ; Lowest available string area
2698   1361 E5                  PUSH    HL              ; Re-save return address
2699   1362 60                  LD      H,B             ; Restore variable pointer
2700   1363 69                  LD      L,C
2701   1364 D0                  RET     NC              ; Outside string area - Ignore
2702   1365 C1                  POP     BC              ; Get return , Throw 2 away
2703   1366 F1                  POP     AF              ; 
2704   1367 F1                  POP     AF              ; 
2705   1368 E5                  PUSH    HL              ; Save variable pointer
2706   1369 D5                  PUSH    DE              ; Save address of current
2707   136A C5                  PUSH    BC              ; Put back return address
2708   136B C9                  RET                     ; Go to it
2709   136C             
2710   136C D1          SCNEND: POP     DE              ; Addresses of strings
2711   136D E1                  POP     HL              ; 
2712   136E 7D                  LD      A,L             ; HL = 0 if no more to do
2713   136F B4                  OR      H
2714   1370 C8                  RET     Z               ; No more to do - Return
2715   1371 2B                  DEC     HL
2716   1372 46                  LD      B,(HL)          ; MSB of address of string
2717   1373 2B                  DEC     HL
2718   1374 4E                  LD      C,(HL)          ; LSB of address of string
2719   1375 E5                  PUSH    HL              ; Save variable address
2720   1376 2B                  DEC     HL
2721   1377 2B                  DEC     HL
2722   1378 6E                  LD      L,(HL)          ; HL = Length of string
2723   1379 26 00               LD      H,0
2724   137B 09                  ADD     HL,BC           ; Address of end of string+1
2725   137C 50                  LD      D,B             ; String address to DE
2726   137D 59                  LD      E,C
2727   137E 2B                  DEC     HL              ; Last byte in string
2728   137F 44                  LD      B,H             ; Address to BC
2729   1380 4D                  LD      C,L
2730   1381 2A 08 21            LD      HL,(STRBOT)     ; Current bottom of string area
2731   1384 CD CC 04            CALL    MOVSTR          ; Move string to new address
2732   1387 E1                  POP     HL              ; Restore variable address
2733   1388 71                  LD      (HL),C          ; Save new LSB of address
2734   1389 23                  INC     HL
2735   138A 70                  LD      (HL),B          ; Save new MSB of address
2736   138B 69                  LD      L,C             ; Next string area+1 to HL
2737   138C 60                  LD      H,B
2738   138D 2B                  DEC     HL              ; Next string area address
2739   138E C3 E1 12            JP      GARBLP          ; Look for more strings
2740   1391             
2741   1391 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2742   1392 E5                  PUSH    HL              ; 
2743   1393 2A 29 21            LD      HL,(FPREG)      ; Get first string
2744   1396 E3                  EX      (SP),HL         ; Save first string
2745   1397 CD 4B 0E            CALL    OPRND           ; Get second string
2746   139A E3                  EX      (SP),HL         ; Restore first string
2747   139B CD C6 0D            CALL    TSTSTR          ; Make sure it's a string
2748   139E 7E                  LD      A,(HL)          ; Get length of second string
2749   139F E5                  PUSH    HL              ; Save first string
2750   13A0 2A 29 21            LD      HL,(FPREG)      ; Get second string
2751   13A3 E5                  PUSH    HL              ; Save second string
2752   13A4 86                  ADD     A,(HL)          ; Add length of second string
2753   13A5 1E 1C               LD      E,LS            ; ?LS Error
2754   13A7 DA 11 05            JP      C,ERROR         ; String too long - Error
2755   13AA CD 4A 12            CALL    MKTMST          ; Make temporary string
2756   13AD D1                  POP     DE              ; Get second string to DE
2757   13AE CD E2 13            CALL    GSTRDE          ; Move to string pool if needed
2758   13B1 E3                  EX      (SP),HL         ; Get first string
2759   13B2 CD E1 13            CALL    GSTRHL          ; Move to string pool if needed
2760   13B5 E5                  PUSH    HL              ; Save first string
2761   13B6 2A 06 21            LD      HL,(TMPSTR+2)   ; Temporary string address
2762   13B9 EB                  EX      DE,HL           ; To DE
2763   13BA CD C8 13            CALL    SSTSA           ; First string to string area
2764   13BD CD C8 13            CALL    SSTSA           ; Second string to string area
2765   13C0 21 E0 0D            LD      HL,EVAL2        ; Return to evaluation loop
2766   13C3 E3                  EX      (SP),HL         ; Save return,get code string
2767   13C4 E5                  PUSH    HL              ; Save code string address
2768   13C5 C3 7B 12            JP      TSTOPL          ; To temporary string to pool
2769   13C8             
2770   13C8 E1          SSTSA:  POP     HL              ; Return address
2771   13C9 E3                  EX      (SP),HL         ; Get string block,save return
2772   13CA 7E                  LD      A,(HL)          ; Get length of string
2773   13CB 23                  INC     HL
2774   13CC 23                  INC     HL
2775   13CD 4E                  LD      C,(HL)          ; Get LSB of string address
2776   13CE 23                  INC     HL
2777   13CF 46                  LD      B,(HL)          ; Get MSB of string address
2778   13D0 6F                  LD      L,A             ; Length to L
2779   13D1 2C          TOSTRA: INC     L               ; INC - DECed after
2780   13D2 2D          TSALP:  DEC     L               ; Count bytes moved
2781   13D3 C8                  RET     Z               ; End of string - Return
2782   13D4 0A                  LD      A,(BC)          ; Get source
2783   13D5 12                  LD      (DE),A          ; Save destination
2784   13D6 03                  INC     BC              ; Next source
2785   13D7 13                  INC     DE              ; Next destination
2786   13D8 C3 D2 13            JP      TSALP           ; Loop until string moved
2787   13DB             
2788   13DB CD C6 0D    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2789   13DE 2A 29 21    GSTRCU: LD      HL,(FPREG)      ; Get current string
2790   13E1 EB          GSTRHL: EX      DE,HL           ; Save DE
2791   13E2 CD FC 13    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2792   13E5 EB                  EX      DE,HL           ; Restore DE
2793   13E6 C0                  RET     NZ              ; No - Return
2794   13E7 D5                  PUSH    DE              ; Save string
2795   13E8 50                  LD      D,B             ; String block address to DE
2796   13E9 59                  LD      E,C
2797   13EA 1B                  DEC     DE              ; Point to length
2798   13EB 4E                  LD      C,(HL)          ; Get string length
2799   13EC 2A 08 21            LD      HL,(STRBOT)     ; Current bottom of string area
2800   13EF CD C5 07            CALL    CPDEHL          ; Last one in string area?
2801   13F2 C2 FA 13            JP      NZ,POPHL        ; No - Return
2802   13F5 47                  LD      B,A             ; Clear B (A=0)
2803   13F6 09                  ADD     HL,BC           ; Remove string from str' area
2804   13F7 22 08 21            LD      (STRBOT),HL     ; Save new bottom of str' area
2805   13FA E1          POPHL:  POP     HL              ; Restore string
2806   13FB C9                  RET
2807   13FC             
2808   13FC 2A F6 20    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2809   13FF 2B                  DEC     HL              ; Back
2810   1400 46                  LD      B,(HL)          ; Get MSB of address
2811   1401 2B                  DEC     HL              ; Back
2812   1402 4E                  LD      C,(HL)          ; Get LSB of address
2813   1403 2B                  DEC     HL              ; Back
2814   1404 2B                  DEC     HL              ; Back
2815   1405 CD C5 07            CALL    CPDEHL          ; String last in string pool?
2816   1408 C0                  RET     NZ              ; Yes - Leave it
2817   1409 22 F6 20            LD      (TMSTPT),HL     ; Save new string pool top
2818   140C C9                  RET
2819   140D             
2820   140D 01 8C 11    LEN:    LD      BC,PASSA        ; To return integer A
2821   1410 C5                  PUSH    BC              ; Save address
2822   1411 CD DB 13    GETLEN: CALL    GETSTR          ; Get string and its length
2823   1414 AF                  XOR     A
2824   1415 57                  LD      D,A             ; Clear D
2825   1416 32 F2 20            LD      (TYPE),A        ; Set type to numeric
2826   1419 7E                  LD      A,(HL)          ; Get length of string
2827   141A B7                  OR      A               ; Set status flags
2828   141B C9                  RET
2829   141C             
2830   141C 01 8C 11    ASC:    LD      BC,PASSA        ; To return integer A
2831   141F C5                  PUSH    BC              ; Save address
2832   1420 CD 11 14    GTFLNM: CALL    GETLEN          ; Get length of string
2833   1423 CA 1C 0A            JP      Z,FCERR         ; Null string - Error
2834   1426 23                  INC     HL
2835   1427 23                  INC     HL
2836   1428 5E                  LD      E,(HL)          ; Get LSB of address
2837   1429 23                  INC     HL
2838   142A 56                  LD      D,(HL)          ; Get MSB of address
2839   142B 1A                  LD      A,(DE)          ; Get first byte of string
2840   142C C9                  RET
2841   142D             
2842   142D 3E 01       CHR:    LD      A,1             ; One character string
2843   142F CD 4A 12            CALL    MKTMST          ; Make a temporary string
2844   1432 CD 26 15            CALL    MAKINT          ; Make it integer A
2845   1435 2A 06 21            LD      HL,(TMPSTR+2)   ; Get address of string
2846   1438 73                  LD      (HL),E          ; Save character
2847   1439 C1          TOPOOL: POP     BC              ; Clean up stack
2848   143A C3 7B 12            JP      TSTOPL          ; Temporary string to pool
2849   143D             
2850   143D CD D6 14    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2851   1440 AF                  XOR     A               ; Start at first byte in string
2852   1441 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2853   1442 4F                  LD      C,A             ; Starting position in string
2854   1443 E5          MID1:   PUSH    HL              ; Save string block address
2855   1444 7E                  LD      A,(HL)          ; Get length of string
2856   1445 B8                  CP      B               ; Compare with number given
2857   1446 DA 4B 14            JP      C,ALLFOL        ; All following bytes required
2858   1449 78                  LD      A,B             ; Get new length
2859   144A 11                  .BYTE      11H             ; Skip "LD C,0"
2860   144B 0E 00       ALLFOL: LD      C,0             ; First byte of string
2861   144D C5                  PUSH    BC              ; Save position in string
2862   144E CD B4 12            CALL    TESTR           ; See if enough string space
2863   1451 C1                  POP     BC              ; Get position in string
2864   1452 E1                  POP     HL              ; Restore string block address
2865   1453 E5                  PUSH    HL              ; And re-save it
2866   1454 23                  INC     HL
2867   1455 23                  INC     HL
2868   1456 46                  LD      B,(HL)          ; Get LSB of address
2869   1457 23                  INC     HL
2870   1458 66                  LD      H,(HL)          ; Get MSB of address
2871   1459 68                  LD      L,B             ; HL = address of string
2872   145A 06 00               LD      B,0             ; BC = starting address
2873   145C 09                  ADD     HL,BC           ; Point to that byte
2874   145D 44                  LD      B,H             ; BC = source string
2875   145E 4D                  LD      C,L
2876   145F CD 4D 12            CALL    CRTMST          ; Create a string entry
2877   1462 6F                  LD      L,A             ; Length of new string
2878   1463 CD D1 13            CALL    TOSTRA          ; Move string to string area
2879   1466 D1                  POP     DE              ; Clear stack
2880   1467 CD E2 13            CALL    GSTRDE          ; Move to string pool if needed
2881   146A C3 7B 12            JP      TSTOPL          ; Temporary string to pool
2882   146D             
2883   146D CD D6 14    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2884   1470 D1                  POP     DE              ; Get string length
2885   1471 D5                  PUSH    DE              ; And re-save
2886   1472 1A                  LD      A,(DE)          ; Get length
2887   1473 90                  SUB     B               ; Move back N bytes
2888   1474 C3 41 14            JP      RIGHT1          ; Go and get sub-string
2889   1477             
2890   1477 EB          MID:    EX      DE,HL           ; Get code string address
2891   1478 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2892   1479 CD DB 14            CALL    MIDNUM          ; Get number supplied
2893   147C 04                  INC     B               ; Is it character zero?
2894   147D 05                  DEC     B
2895   147E CA 1C 0A            JP      Z,FCERR         ; Yes - Error
2896   1481 C5                  PUSH    BC              ; Save starting position
2897   1482 1E FF               LD      E,255           ; All of string
2898   1484 FE 29               CP      ')'             ; Any length given?
2899   1486 CA 90 14            JP      Z,RSTSTR        ; No - Rest of string
2900   1489 CD CB 07            CALL    CHKSYN          ; Make sure ',' follows
2901   148C 2C                  .BYTE      ','
2902   148D CD 23 15            CALL    GETINT          ; Get integer 0-255
2903   1490 CD CB 07    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2904   1493 29                  .BYTE      ")"
2905   1494 F1                  POP     AF              ; Restore starting position
2906   1495 E3                  EX      (SP),HL         ; Get string,8ave code string
2907   1496 01 43 14            LD      BC,MID1         ; Continuation of MID$ routine
2908   1499 C5                  PUSH    BC              ; Save for return
2909   149A 3D                  DEC     A               ; Starting position-1
2910   149B BE                  CP      (HL)            ; Compare with length
2911   149C 06 00               LD      B,0             ; Zero bytes length
2912   149E D0                  RET     NC              ; Null string if start past end
2913   149F 4F                  LD      C,A             ; Save starting position-1
2914   14A0 7E                  LD      A,(HL)          ; Get length of string
2915   14A1 91                  SUB     C               ; Subtract start
2916   14A2 BB                  CP      E               ; Enough string for it?
2917   14A3 47                  LD      B,A             ; Save maximum length available
2918   14A4 D8                  RET     C               ; Truncate string if needed
2919   14A5 43                  LD      B,E             ; Set specified length
2920   14A6 C9                  RET                     ; Go and create string
2921   14A7             
2922   14A7 CD 11 14    VAL:    CALL    GETLEN          ; Get length of string
2923   14AA CA C4 15            JP      Z,RESZER        ; Result zero
2924   14AD 5F                  LD      E,A             ; Save length
2925   14AE 23                  INC     HL
2926   14AF 23                  INC     HL
2927   14B0 7E                  LD      A,(HL)          ; Get LSB of address
2928   14B1 23                  INC     HL
2929   14B2 66                  LD      H,(HL)          ; Get MSB of address
2930   14B3 6F                  LD      L,A             ; HL = String address
2931   14B4 E5                  PUSH    HL              ; Save string address
2932   14B5 19                  ADD     HL,DE
2933   14B6 46                  LD      B,(HL)          ; Get end of string+1 byte
2934   14B7 72                  LD      (HL),D          ; Zero it to terminate
2935   14B8 E3                  EX      (SP),HL         ; Save string end,get start
2936   14B9 C5                  PUSH    BC              ; Save end+1 byte
2937   14BA 7E                  LD      A,(HL)          ; Get starting byte
2938   14BB FE 24           CP	'$'		; Hex number indicated? [function added]
2939   14BD C2 C5 14        JP	NZ,VAL1
2940   14C0 CD EF 1C        CALL	HEXTFP		; Convert Hex to FPREG
2941   14C3 18 0D           JR	VAL3
2942   14C5 FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
2943   14C7 C2 CF 14        JP	NZ,VAL2
2944   14CA CD 5F 1D        CALL	BINTFP		; Convert Bin to FPREG
2945   14CD 18 03           JR	VAL3
2946   14CF CD AB 18    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2947   14D2 C1          VAL3:   POP     BC              ; Restore end+1 byte
2948   14D3 E1                  POP     HL              ; Restore end+1 address
2949   14D4 70                  LD      (HL),B          ; Put back original byte
2950   14D5 C9                  RET
2951   14D6             
2952   14D6 EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2953   14D7 CD CB 07            CALL    CHKSYN          ; Make sure ")" follows
2954   14DA 29                  .BYTE      ")"
2955   14DB C1          MIDNUM: POP     BC              ; Get return address
2956   14DC D1                  POP     DE              ; Get number supplied
2957   14DD C5                  PUSH    BC              ; Re-save return address
2958   14DE 43                  LD      B,E             ; Number to B
2959   14DF C9                  RET
2960   14E0             
2961   14E0 CD 26 15    INP:    CALL    MAKINT          ; Make it integer A
2962   14E3 32 84 20            LD      (INPORT),A      ; Set input port
2963   14E6 CD 83 20            CALL    INPSUB          ; Get input from port
2964   14E9 C3 8C 11            JP      PASSA           ; Return integer A
2965   14EC             
2966   14EC CD 10 15    POUT:   CALL    SETIO           ; Set up port number
2967   14EF C3 4B 20            JP      OUTSUB          ; Output data and return
2968   14F2             
2969   14F2 CD 10 15    WAIT:   CALL    SETIO           ; Set up port number
2970   14F5 F5                  PUSH    AF              ; Save AND mask
2971   14F6 1E 00               LD      E,0             ; Assume zero if none given
2972   14F8 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2973   14F9 CD 55 09            CALL    GETCHR          ; Get next character
2974   14FC CA 06 15            JP      Z,NOXOR         ; No XOR byte given
2975   14FF CD CB 07            CALL    CHKSYN          ; Make sure ',' follows
2976   1502 2C                  .BYTE      ','
2977   1503 CD 23 15            CALL    GETINT          ; Get integer 0-255 to XOR with
2978   1506 C1          NOXOR:  POP     BC              ; Restore AND mask
2979   1507 CD 83 20    WAITLP: CALL    INPSUB          ; Get input
2980   150A AB                  XOR     E               ; Flip selected bits
2981   150B A0                  AND     B               ; Result non-zero?
2982   150C CA 07 15            JP      Z,WAITLP        ; No = keep waiting
2983   150F C9                  RET
2984   1510             
2985   1510 CD 23 15    SETIO:  CALL    GETINT          ; Get integer 0-255
2986   1513 32 84 20            LD      (INPORT),A      ; Set input port
2987   1516 32 4C 20            LD      (OTPORT),A      ; Set output port
2988   1519 CD CB 07            CALL    CHKSYN          ; Make sure ',' follows
2989   151C 2C                  .BYTE      ','
2990   151D C3 23 15            JP      GETINT          ; Get integer 0-255 and return
2991   1520             
2992   1520 CD 55 09    FNDNUM: CALL    GETCHR          ; Get next character
2993   1523 CD C2 0D    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2994   1526 CD 01 0A    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2995   1529 7A                  LD      A,D             ; Get MSB of number
2996   152A B7                  OR      A               ; Zero?
2997   152B C2 1C 0A            JP      NZ,FCERR        ; No - Error
2998   152E 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2999   152F CD 55 09            CALL    GETCHR          ; Get next character
3000   1532 7B                  LD      A,E             ; Get number to A
3001   1533 C9                  RET
3002   1534             
3003   1534 CD 07 0A    PEEK:   CALL    DEINT           ; Get memory address
3004   1537 1A                  LD      A,(DE)          ; Get byte in memory
3005   1538 C3 8C 11            JP      PASSA           ; Return integer A
3006   153B             
3007   153B CD C2 0D    POKE:   CALL    GETNUM          ; Get memory address
3008   153E CD 07 0A            CALL    DEINT           ; Get integer -32768 to 3276
3009   1541 D5                  PUSH    DE              ; Save memory address
3010   1542 CD CB 07            CALL    CHKSYN          ; Make sure ',' follows
3011   1545 2C                  .BYTE      ','
3012   1546 CD 23 15            CALL    GETINT          ; Get integer 0-255
3013   1549 D1                  POP     DE              ; Restore memory address
3014   154A 12                  LD      (DE),A          ; Load it into memory
3015   154B C9                  RET
3016   154C             
3017   154C 21 22 1A    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3018   154F CD F3 17    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3019   1552 C3 5E 15            JP      FPADD           ; Add BCDE to FPREG
3020   1555             
3021   1555 CD F3 17    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3022   1558 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3023   1559 C1          PSUB:   POP     BC              ; Get FP number from stack
3024   155A D1                  POP     DE
3025   155B CD CD 17    SUBCDE: CALL    INVSGN          ; Negate FPREG
3026   155E 78          FPADD:  LD      A,B             ; Get FP exponent
3027   155F B7                  OR      A               ; Is number zero?
3028   1560 C8                  RET     Z               ; Yes - Nothing to add
3029   1561 3A 2C 21            LD      A,(FPEXP)       ; Get FPREG exponent
3030   1564 B7                  OR      A               ; Is this number zero?
3031   1565 CA E5 17            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3032   1568 90                  SUB     B               ; BCDE number larger?
3033   1569 D2 78 15            JP      NC,NOSWAP       ; No - Don't swap them
3034   156C 2F                  CPL                     ; Two's complement
3035   156D 3C                  INC     A               ;  FP exponent
3036   156E EB                  EX      DE,HL
3037   156F CD D5 17            CALL    STAKFP          ; Put FPREG on stack
3038   1572 EB                  EX      DE,HL
3039   1573 CD E5 17            CALL    FPBCDE          ; Move BCDE to FPREG
3040   1576 C1                  POP     BC              ; Restore number from stack
3041   1577 D1                  POP     DE
3042   1578 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3043   157A D0                  RET     NC              ; Yes - First number is result
3044   157B F5                  PUSH    AF              ; Save number of bits to scale
3045   157C CD 0A 18            CALL    SIGNS           ; Set MSBs & sign of result
3046   157F 67                  LD      H,A             ; Save sign of result
3047   1580 F1                  POP     AF              ; Restore scaling factor
3048   1581 CD 23 16            CALL    SCALE           ; Scale BCDE to same exponent
3049   1584 B4                  OR      H               ; Result to be positive?
3050   1585 21 29 21            LD      HL,FPREG        ; Point to FPREG
3051   1588 F2 9E 15            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3052   158B CD 03 16            CALL    PLUCDE          ; Add FPREG to CDE
3053   158E D2 E4 15            JP      NC,RONDUP       ; No overflow - Round it up
3054   1591 23                  INC     HL              ; Point to exponent
3055   1592 34                  INC     (HL)            ; Increment it
3056   1593 CA 0C 05            JP      Z,OVERR         ; Number overflowed - Error
3057   1596 2E 01               LD      L,1             ; 1 bit to shift right
3058   1598 CD 39 16            CALL    SHRT1           ; Shift result right
3059   159B C3 E4 15            JP      RONDUP          ; Round it up
3060   159E             
3061   159E AF          MINCDE: XOR     A               ; Clear A and carry
3062   159F 90                  SUB     B               ; Negate exponent
3063   15A0 47                  LD      B,A             ; Re-save exponent
3064   15A1 7E                  LD      A,(HL)          ; Get LSB of FPREG
3065   15A2 9B                  SBC     A, E            ; Subtract LSB of BCDE
3066   15A3 5F                  LD      E,A             ; Save LSB of BCDE
3067   15A4 23                  INC     HL
3068   15A5 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3069   15A6 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3070   15A7 57                  LD      D,A             ; Save NMSB of BCDE
3071   15A8 23                  INC     HL
3072   15A9 7E                  LD      A,(HL)          ; Get MSB of FPREG
3073   15AA 99                  SBC     A,C             ; Subtract MSB of BCDE
3074   15AB 4F                  LD      C,A             ; Save MSB of BCDE
3075   15AC DC 0F 16    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3076   15AF             
3077   15AF 68          BNORM:  LD      L,B             ; L = Exponent
3078   15B0 63                  LD      H,E             ; H = LSB
3079   15B1 AF                  XOR     A
3080   15B2 47          BNRMLP: LD      B,A             ; Save bit count
3081   15B3 79                  LD      A,C             ; Get MSB
3082   15B4 B7                  OR      A               ; Is it zero?
3083   15B5 C2 D1 15            JP      NZ,PNORM        ; No - Do it bit at a time
3084   15B8 4A                  LD      C,D             ; MSB = NMSB
3085   15B9 54                  LD      D,H             ; NMSB= LSB
3086   15BA 65                  LD      H,L             ; LSB = VLSB
3087   15BB 6F                  LD      L,A             ; VLSB= 0
3088   15BC 78                  LD      A,B             ; Get exponent
3089   15BD D6 08               SUB     8               ; Count 8 bits
3090   15BF FE E0               CP      -24-8           ; Was number zero?
3091   15C1 C2 B2 15            JP      NZ,BNRMLP       ; No - Keep normalising
3092   15C4 AF          RESZER: XOR     A               ; Result is zero
3093   15C5 32 2C 21    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3094   15C8 C9                  RET
3095   15C9             
3096   15C9 05          NORMAL: DEC     B               ; Count bits
3097   15CA 29                  ADD     HL,HL           ; Shift HL left
3098   15CB 7A                  LD      A,D             ; Get NMSB
3099   15CC 17                  RLA                     ; Shift left with last bit
3100   15CD 57                  LD      D,A             ; Save NMSB
3101   15CE 79                  LD      A,C             ; Get MSB
3102   15CF 8F                  ADC     A,A             ; Shift left with last bit
3103   15D0 4F                  LD      C,A             ; Save MSB
3104   15D1 F2 C9 15    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3105   15D4 78                  LD      A,B             ; Number of bits shifted
3106   15D5 5C                  LD      E,H             ; Save HL in EB
3107   15D6 45                  LD      B,L
3108   15D7 B7                  OR      A               ; Any shifting done?
3109   15D8 CA E4 15            JP      Z,RONDUP        ; No - Round it up
3110   15DB 21 2C 21            LD      HL,FPEXP        ; Point to exponent
3111   15DE 86                  ADD     A,(HL)          ; Add shifted bits
3112   15DF 77                  LD      (HL),A          ; Re-save exponent
3113   15E0 D2 C4 15            JP      NC,RESZER       ; Underflow - Result is zero
3114   15E3 C8                  RET     Z               ; Result is zero
3115   15E4 78          RONDUP: LD      A,B             ; Get VLSB of number
3116   15E5 21 2C 21    RONDB:  LD      HL,FPEXP        ; Point to exponent
3117   15E8 B7                  OR      A               ; Any rounding?
3118   15E9 FC F6 15            CALL    M,FPROND        ; Yes - Round number up
3119   15EC 46                  LD      B,(HL)          ; B = Exponent
3120   15ED 23                  INC     HL
3121   15EE 7E                  LD      A,(HL)          ; Get sign of result
3122   15EF E6 80               AND     10000000B       ; Only bit 7 needed
3123   15F1 A9                  XOR     C               ; Set correct sign
3124   15F2 4F                  LD      C,A             ; Save correct sign in number
3125   15F3 C3 E5 17            JP      FPBCDE          ; Move BCDE to FPREG
3126   15F6             
3127   15F6 1C          FPROND: INC     E               ; Round LSB
3128   15F7 C0                  RET     NZ              ; Return if ok
3129   15F8 14                  INC     D               ; Round NMSB
3130   15F9 C0                  RET     NZ              ; Return if ok
3131   15FA 0C                  INC     C               ; Round MSB
3132   15FB C0                  RET     NZ              ; Return if ok
3133   15FC 0E 80               LD      C,80H           ; Set normal value
3134   15FE 34                  INC     (HL)            ; Increment exponent
3135   15FF C0                  RET     NZ              ; Return if ok
3136   1600 C3 0C 05            JP      OVERR           ; Overflow error
3137   1603             
3138   1603 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3139   1604 83                  ADD     A,E             ; Add LSB of BCDE
3140   1605 5F                  LD      E,A             ; Save LSB of BCDE
3141   1606 23                  INC     HL
3142   1607 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3143   1608 8A                  ADC     A,D             ; Add NMSB of BCDE
3144   1609 57                  LD      D,A             ; Save NMSB of BCDE
3145   160A 23                  INC     HL
3146   160B 7E                  LD      A,(HL)          ; Get MSB of FPREG
3147   160C 89                  ADC     A,C             ; Add MSB of BCDE
3148   160D 4F                  LD      C,A             ; Save MSB of BCDE
3149   160E C9                  RET
3150   160F             
3151   160F 21 2D 21    COMPL:  LD      HL,SGNRES       ; Sign of result
3152   1612 7E                  LD      A,(HL)          ; Get sign of result
3153   1613 2F                  CPL                     ; Negate it
3154   1614 77                  LD      (HL),A          ; Put it back
3155   1615 AF                  XOR     A
3156   1616 6F                  LD      L,A             ; Set L to zero
3157   1617 90                  SUB     B               ; Negate exponent,set carry
3158   1618 47                  LD      B,A             ; Re-save exponent
3159   1619 7D                  LD      A,L             ; Load zero
3160   161A 9B                  SBC     A,E             ; Negate LSB
3161   161B 5F                  LD      E,A             ; Re-save LSB
3162   161C 7D                  LD      A,L             ; Load zero
3163   161D 9A                  SBC     A,D             ; Negate NMSB
3164   161E 57                  LD      D,A             ; Re-save NMSB
3165   161F 7D                  LD      A,L             ; Load zero
3166   1620 99                  SBC     A,C             ; Negate MSB
3167   1621 4F                  LD      C,A             ; Re-save MSB
3168   1622 C9                  RET
3169   1623             
3170   1623 06 00       SCALE:  LD      B,0             ; Clear underflow
3171   1625 D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3172   1627 DA 32 16            JP      C,SHRITE        ; No - Shift right A bits
3173   162A 43                  LD      B,E             ; <- Shift
3174   162B 5A                  LD      E,D             ; <- right
3175   162C 51                  LD      D,C             ; <- eight
3176   162D 0E 00               LD      C,0             ; <- bits
3177   162F C3 25 16            JP      SCALLP          ; More bits to shift
3178   1632             
3179   1632 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3180   1634 6F                  LD      L,A             ; Save bits to shift
3181   1635 AF          SHRLP:  XOR     A               ; Flag for all done
3182   1636 2D                  DEC     L               ; All shifting done?
3183   1637 C8                  RET     Z               ; Yes - Return
3184   1638 79                  LD      A,C             ; Get MSB
3185   1639 1F          SHRT1:  RRA                     ; Shift it right
3186   163A 4F                  LD      C,A             ; Re-save
3187   163B 7A                  LD      A,D             ; Get NMSB
3188   163C 1F                  RRA                     ; Shift right with last bit
3189   163D 57                  LD      D,A             ; Re-save it
3190   163E 7B                  LD      A,E             ; Get LSB
3191   163F 1F                  RRA                     ; Shift right with last bit
3192   1640 5F                  LD      E,A             ; Re-save it
3193   1641 78                  LD      A,B             ; Get underflow
3194   1642 1F                  RRA                     ; Shift right with last bit
3195   1643 47                  LD      B,A             ; Re-save underflow
3196   1644 C3 35 16            JP      SHRLP           ; More bits to do
3197   1647             
3198   1647 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3199   164B             
3200   164B 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3201   164C AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3202   1650 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3203   1654 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3204   1658             
3205   1658 CD A4 17    LOG:    CALL    TSTSGN          ; Test sign of value
3206   165B B7                  OR      A
3207   165C EA 1C 0A            JP      PE,FCERR        ; ?FC Error if <= zero
3208   165F 21 2C 21            LD      HL,FPEXP        ; Point to exponent
3209   1662 7E                  LD      A,(HL)          ; Get exponent
3210   1663 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3211   1666 11 F3 04            LD      DE,04F3H
3212   1669 90                  SUB     B               ; Scale value to be < 1
3213   166A F5                  PUSH    AF              ; Save scale factor
3214   166B 70                  LD      (HL),B          ; Save new exponent
3215   166C D5                  PUSH    DE              ; Save SQR(1/2)
3216   166D C5                  PUSH    BC
3217   166E CD 5E 15            CALL    FPADD           ; Add SQR(1/2) to value
3218   1671 C1                  POP     BC              ; Restore SQR(1/2)
3219   1672 D1                  POP     DE
3220   1673 04                  INC     B               ; Make it SQR(2)
3221   1674 CD FA 16            CALL    DVBCDE          ; Divide by SQR(2)
3222   1677 21 47 16            LD      HL,UNITY        ; Point to 1.
3223   167A CD 55 15            CALL    SUBPHL          ; Subtract FPREG from 1
3224   167D 21 4B 16            LD      HL,LOGTAB       ; Coefficient table
3225   1680 CD EC 1A            CALL    SUMSER          ; Evaluate sum of series
3226   1683 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3227   1686 11 00 00            LD      DE,0000H
3228   1689 CD 5E 15            CALL    FPADD           ; Subtract 0.5 from FPREG
3229   168C F1                  POP     AF              ; Restore scale factor
3230   168D CD 1F 19            CALL    RSCALE          ; Re-scale number
3231   1690 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3232   1693 11 18 72            LD      DE,7218H
3233   1696 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3234   1697             
3235   1697 C1          MULT:   POP     BC              ; Get number from stack
3236   1698 D1                  POP     DE
3237   1699 CD A4 17    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3238   169C C8                  RET     Z               ; Return zero if zero
3239   169D 2E 00               LD      L,0             ; Flag add exponents
3240   169F CD 62 17            CALL    ADDEXP          ; Add exponents
3241   16A2 79                  LD      A,C             ; Get MSB of multiplier
3242   16A3 32 3B 21            LD      (MULVAL),A      ; Save MSB of multiplier
3243   16A6 EB                  EX      DE,HL
3244   16A7 22 3C 21            LD      (MULVAL+1),HL   ; Save rest of multiplier
3245   16AA 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3246   16AD 50                  LD      D,B
3247   16AE 58                  LD      E,B
3248   16AF 21 AF 15            LD      HL,BNORM        ; Address of normalise
3249   16B2 E5                  PUSH    HL              ; Save for return
3250   16B3 21 BB 16            LD      HL,MULT8        ; Address of 8 bit multiply
3251   16B6 E5                  PUSH    HL              ; Save for NMSB,MSB
3252   16B7 E5                  PUSH    HL              ; 
3253   16B8 21 29 21            LD      HL,FPREG        ; Point to number
3254   16BB 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3255   16BC 23                  INC     HL              ; Point to NMSB
3256   16BD B7                  OR      A               ; Test LSB
3257   16BE CA E7 16            JP      Z,BYTSFT        ; Zero - shift to next byte
3258   16C1 E5                  PUSH    HL              ; Save address of number
3259   16C2 2E 08               LD      L,8             ; 8 bits to multiply by
3260   16C4 1F          MUL8LP: RRA                     ; Shift LSB right
3261   16C5 67                  LD      H,A             ; Save LSB
3262   16C6 79                  LD      A,C             ; Get MSB
3263   16C7 D2 D5 16            JP      NC,NOMADD       ; Bit was zero - Don't add
3264   16CA E5                  PUSH    HL              ; Save LSB and count
3265   16CB 2A 3C 21            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3266   16CE 19                  ADD     HL,DE           ; Add NMSB and LSB
3267   16CF EB                  EX      DE,HL           ; Leave sum in DE
3268   16D0 E1                  POP     HL              ; Restore MSB and count
3269   16D1 3A 3B 21            LD      A,(MULVAL)      ; Get MSB of multiplier
3270   16D4 89                  ADC     A,C             ; Add MSB
3271   16D5 1F          NOMADD: RRA                     ; Shift MSB right
3272   16D6 4F                  LD      C,A             ; Re-save MSB
3273   16D7 7A                  LD      A,D             ; Get NMSB
3274   16D8 1F                  RRA                     ; Shift NMSB right
3275   16D9 57                  LD      D,A             ; Re-save NMSB
3276   16DA 7B                  LD      A,E             ; Get LSB
3277   16DB 1F                  RRA                     ; Shift LSB right
3278   16DC 5F                  LD      E,A             ; Re-save LSB
3279   16DD 78                  LD      A,B             ; Get VLSB
3280   16DE 1F                  RRA                     ; Shift VLSB right
3281   16DF 47                  LD      B,A             ; Re-save VLSB
3282   16E0 2D                  DEC     L               ; Count bits multiplied
3283   16E1 7C                  LD      A,H             ; Get LSB of multiplier
3284   16E2 C2 C4 16            JP      NZ,MUL8LP       ; More - Do it
3285   16E5 E1          POPHRT: POP     HL              ; Restore address of number
3286   16E6 C9                  RET
3287   16E7             
3288   16E7 43          BYTSFT: LD      B,E             ; Shift partial product left
3289   16E8 5A                  LD      E,D
3290   16E9 51                  LD      D,C
3291   16EA 4F                  LD      C,A
3292   16EB C9                  RET
3293   16EC             
3294   16EC CD D5 17    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3295   16EF 01 20 84            LD      BC,8420H        ; BCDE = 10.
3296   16F2 11 00 00            LD      DE,0000H
3297   16F5 CD E5 17            CALL    FPBCDE          ; Move 10 to FPREG
3298   16F8             
3299   16F8 C1          DIV:    POP     BC              ; Get number from stack
3300   16F9 D1                  POP     DE
3301   16FA CD A4 17    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3302   16FD CA 00 05            JP      Z,DZERR         ; Error if division by zero
3303   1700 2E FF               LD      L,-1            ; Flag subtract exponents
3304   1702 CD 62 17            CALL    ADDEXP          ; Subtract exponents
3305   1705 34                  INC     (HL)            ; Add 2 to exponent to adjust
3306   1706 34                  INC     (HL)
3307   1707 2B                  DEC     HL              ; Point to MSB
3308   1708 7E                  LD      A,(HL)          ; Get MSB of dividend
3309   1709 32 57 20            LD      (DIV3),A        ; Save for subtraction
3310   170C 2B                  DEC     HL
3311   170D 7E                  LD      A,(HL)          ; Get NMSB of dividend
3312   170E 32 53 20            LD      (DIV2),A        ; Save for subtraction
3313   1711 2B                  DEC     HL
3314   1712 7E                  LD      A,(HL)          ; Get MSB of dividend
3315   1713 32 4F 20            LD      (DIV1),A        ; Save for subtraction
3316   1716 41                  LD      B,C             ; Get MSB
3317   1717 EB                  EX      DE,HL           ; NMSB,LSB to HL
3318   1718 AF                  XOR     A
3319   1719 4F                  LD      C,A             ; Clear MSB of quotient
3320   171A 57                  LD      D,A             ; Clear NMSB of quotient
3321   171B 5F                  LD      E,A             ; Clear LSB of quotient
3322   171C 32 5A 20            LD      (DIV4),A        ; Clear overflow count
3323   171F E5          DIVLP:  PUSH    HL              ; Save divisor
3324   1720 C5                  PUSH    BC
3325   1721 7D                  LD      A,L             ; Get LSB of number
3326   1722 CD 4E 20            CALL    DIVSUP          ; Subt' divisor from dividend
3327   1725 DE 00               SBC     A,0             ; Count for overflows
3328   1727 3F                  CCF
3329   1728 D2 32 17            JP      NC,RESDIV       ; Restore divisor if borrow
3330   172B 32 5A 20            LD      (DIV4),A        ; Re-save overflow count
3331   172E F1                  POP     AF              ; Scrap divisor
3332   172F F1                  POP     AF
3333   1730 37                  SCF                     ; Set carry to
3334   1731 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3335   1732             
3336   1732 C1          RESDIV: POP     BC              ; Restore divisor
3337   1733 E1                  POP     HL
3338   1734 79                  LD      A,C             ; Get MSB of quotient
3339   1735 3C                  INC     A
3340   1736 3D                  DEC     A
3341   1737 1F                  RRA                     ; Bit 0 to bit 7
3342   1738 FA E5 15            JP      M,RONDB         ; Done - Normalise result
3343   173B 17                  RLA                     ; Restore carry
3344   173C 7B                  LD      A,E             ; Get LSB of quotient
3345   173D 17                  RLA                     ; Double it
3346   173E 5F                  LD      E,A             ; Put it back
3347   173F 7A                  LD      A,D             ; Get NMSB of quotient
3348   1740 17                  RLA                     ; Double it
3349   1741 57                  LD      D,A             ; Put it back
3350   1742 79                  LD      A,C             ; Get MSB of quotient
3351   1743 17                  RLA                     ; Double it
3352   1744 4F                  LD      C,A             ; Put it back
3353   1745 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3354   1746 78                  LD      A,B             ; Get MSB of divisor
3355   1747 17                  RLA                     ; Double it
3356   1748 47                  LD      B,A             ; Put it back
3357   1749 3A 5A 20            LD      A,(DIV4)        ; Get VLSB of quotient
3358   174C 17                  RLA                     ; Double it
3359   174D 32 5A 20            LD      (DIV4),A        ; Put it back
3360   1750 79                  LD      A,C             ; Get MSB of quotient
3361   1751 B2                  OR      D               ; Merge NMSB
3362   1752 B3                  OR      E               ; Merge LSB
3363   1753 C2 1F 17            JP      NZ,DIVLP        ; Not done - Keep dividing
3364   1756 E5                  PUSH    HL              ; Save divisor
3365   1757 21 2C 21            LD      HL,FPEXP        ; Point to exponent
3366   175A 35                  DEC     (HL)            ; Divide by 2
3367   175B E1                  POP     HL              ; Restore divisor
3368   175C C2 1F 17            JP      NZ,DIVLP        ; Ok - Keep going
3369   175F C3 0C 05            JP      OVERR           ; Overflow error
3370   1762             
3371   1762 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3372   1763 B7                  OR      A               ; Test it
3373   1764 CA 86 17            JP      Z,OVTST3        ; Zero - Result zero
3374   1767 7D                  LD      A,L             ; Get add/subtract flag
3375   1768 21 2C 21            LD      HL,FPEXP        ; Point to exponent
3376   176B AE                  XOR     (HL)            ; Add or subtract it
3377   176C 80                  ADD     A,B             ; Add the other exponent
3378   176D 47                  LD      B,A             ; Save new exponent
3379   176E 1F                  RRA                     ; Test exponent for overflow
3380   176F A8                  XOR     B
3381   1770 78                  LD      A,B             ; Get exponent
3382   1771 F2 85 17            JP      P,OVTST2        ; Positive - Test for overflow
3383   1774 C6 80               ADD     A,80H           ; Add excess 128
3384   1776 77                  LD      (HL),A          ; Save new exponent
3385   1777 CA E5 16            JP      Z,POPHRT        ; Zero - Result zero
3386   177A CD 0A 18            CALL    SIGNS           ; Set MSBs and sign of result
3387   177D 77                  LD      (HL),A          ; Save new exponent
3388   177E 2B                  DEC     HL              ; Point to MSB
3389   177F C9                  RET
3390   1780             
3391   1780 CD A4 17    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3392   1783 2F                  CPL                     ; Invert sign
3393   1784 E1                  POP     HL              ; Clean up stack
3394   1785 B7          OVTST2: OR      A               ; Test if new exponent zero
3395   1786 E1          OVTST3: POP     HL              ; Clear off return address
3396   1787 F2 C4 15            JP      P,RESZER        ; Result zero
3397   178A C3 0C 05            JP      OVERR           ; Overflow error
3398   178D             
3399   178D CD F0 17    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3400   1790 78                  LD      A,B             ; Get exponent
3401   1791 B7                  OR      A               ; Is it zero?
3402   1792 C8                  RET     Z               ; Yes - Result is zero
3403   1793 C6 02               ADD     A,2             ; Multiply by 4
3404   1795 DA 0C 05            JP      C,OVERR         ; Overflow - ?OV Error
3405   1798 47                  LD      B,A             ; Re-save exponent
3406   1799 CD 5E 15            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3407   179C 21 2C 21            LD      HL,FPEXP        ; Point to exponent
3408   179F 34                  INC     (HL)            ; Double number (Times 10)
3409   17A0 C0                  RET     NZ              ; Ok - Return
3410   17A1 C3 0C 05            JP      OVERR           ; Overflow error
3411   17A4             
3412   17A4 3A 2C 21    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3413   17A7 B7                  OR      A
3414   17A8 C8                  RET     Z               ; RETurn if number is zero
3415   17A9 3A 2B 21            LD      A,(FPREG+2)     ; Get MSB of FPREG
3416   17AC FE                  .BYTE      0FEH            ; Test sign
3417   17AD 2F          RETREL: CPL                     ; Invert sign
3418   17AE 17                  RLA                     ; Sign bit to carry
3419   17AF 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3420   17B0 C0                  RET     NZ              ; Return -1 if negative
3421   17B1 3C                  INC     A               ; Bump to +1
3422   17B2 C9                  RET                     ; Positive - Return +1
3423   17B3             
3424   17B3 CD A4 17    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3425   17B6 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3426   17B8 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3427   17BB 21 2C 21    RETINT: LD      HL,FPEXP        ; Point to exponent
3428   17BE 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3429   17BF 70                  LD      (HL),B          ; Save exponent
3430   17C0 06 00               LD      B,0             ; CDE = integer to normalise
3431   17C2 23                  INC     HL              ; Point to sign of result
3432   17C3 36 80               LD      (HL),80H        ; Set sign of result
3433   17C5 17                  RLA                     ; Carry = sign of integer
3434   17C6 C3 AC 15            JP      CONPOS          ; Set sign of result
3435   17C9             
3436   17C9 CD A4 17    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3437   17CC F0                  RET     P               ; Return if positive
3438   17CD 21 2B 21    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3439   17D0 7E                  LD      A,(HL)          ; Get sign of mantissa
3440   17D1 EE 80               XOR     80H             ; Invert sign of mantissa
3441   17D3 77                  LD      (HL),A          ; Re-save sign of mantissa
3442   17D4 C9                  RET
3443   17D5             
3444   17D5 EB          STAKFP: EX      DE,HL           ; Save code string address
3445   17D6 2A 29 21            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3446   17D9 E3                  EX      (SP),HL         ; Stack them,get return
3447   17DA E5                  PUSH    HL              ; Re-save return
3448   17DB 2A 2B 21            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3449   17DE E3                  EX      (SP),HL         ; Stack them,get return
3450   17DF E5                  PUSH    HL              ; Re-save return
3451   17E0 EB                  EX      DE,HL           ; Restore code string address
3452   17E1 C9                  RET
3453   17E2             
3454   17E2 CD F3 17    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3455   17E5 EB          FPBCDE: EX      DE,HL           ; Save code string address
3456   17E6 22 29 21            LD      (FPREG),HL      ; Save LSB,NLSB of number
3457   17E9 60                  LD      H,B             ; Exponent of number
3458   17EA 69                  LD      L,C             ; MSB of number
3459   17EB 22 2B 21            LD      (FPREG+2),HL    ; Save MSB and exponent
3460   17EE EB                  EX      DE,HL           ; Restore code string address
3461   17EF C9                  RET
3462   17F0             
3463   17F0 21 29 21    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3464   17F3 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3465   17F4 23                  INC     HL
3466   17F5 56                  LD      D,(HL)          ; Get NMSB of number
3467   17F6 23                  INC     HL
3468   17F7 4E                  LD      C,(HL)          ; Get MSB of number
3469   17F8 23                  INC     HL
3470   17F9 46                  LD      B,(HL)          ; Get exponent of number
3471   17FA 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3472   17FB C9                  RET
3473   17FC             
3474   17FC 11 29 21    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3475   17FF 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3476   1801 1A          DETHLB: LD      A,(DE)          ; Get source
3477   1802 77                  LD      (HL),A          ; Save destination
3478   1803 13                  INC     DE              ; Next source
3479   1804 23                  INC     HL              ; Next destination
3480   1805 05                  DEC     B               ; Count bytes
3481   1806 C2 01 18            JP      NZ,DETHLB       ; Loop if more
3482   1809 C9                  RET
3483   180A             
3484   180A 21 2B 21    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3485   180D 7E                  LD      A,(HL)          ; Get MSB
3486   180E 07                  RLCA                    ; Old sign to carry
3487   180F 37                  SCF                     ; Set MSBit
3488   1810 1F                  RRA                     ; Set MSBit of MSB
3489   1811 77                  LD      (HL),A          ; Save new MSB
3490   1812 3F                  CCF                     ; Complement sign
3491   1813 1F                  RRA                     ; Old sign to carry
3492   1814 23                  INC     HL
3493   1815 23                  INC     HL
3494   1816 77                  LD      (HL),A          ; Set sign of result
3495   1817 79                  LD      A,C             ; Get MSB
3496   1818 07                  RLCA                    ; Old sign to carry
3497   1819 37                  SCF                     ; Set MSBit
3498   181A 1F                  RRA                     ; Set MSBit of MSB
3499   181B 4F                  LD      C,A             ; Save MSB
3500   181C 1F                  RRA
3501   181D AE                  XOR     (HL)            ; New sign of result
3502   181E C9                  RET
3503   181F             
3504   181F 78          CMPNUM: LD      A,B             ; Get exponent of number
3505   1820 B7                  OR      A
3506   1821 CA A4 17            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3507   1824 21 AD 17            LD      HL,RETREL       ; Return relation routine
3508   1827 E5                  PUSH    HL              ; Save for return
3509   1828 CD A4 17            CALL    TSTSGN          ; Test sign of FPREG
3510   182B 79                  LD      A,C             ; Get MSB of number
3511   182C C8                  RET     Z               ; FPREG zero - Number's MSB
3512   182D 21 2B 21            LD      HL,FPREG+2      ; MSB of FPREG
3513   1830 AE                  XOR     (HL)            ; Combine signs
3514   1831 79                  LD      A,C             ; Get MSB of number
3515   1832 F8                  RET     M               ; Exit if signs different
3516   1833 CD 39 18            CALL    CMPFP           ; Compare FP numbers
3517   1836 1F                  RRA                     ; Get carry to sign
3518   1837 A9                  XOR     C               ; Combine with MSB of number
3519   1838 C9                  RET
3520   1839             
3521   1839 23          CMPFP:  INC     HL              ; Point to exponent
3522   183A 78                  LD      A,B             ; Get exponent
3523   183B BE                  CP      (HL)            ; Compare exponents
3524   183C C0                  RET     NZ              ; Different
3525   183D 2B                  DEC     HL              ; Point to MBS
3526   183E 79                  LD      A,C             ; Get MSB
3527   183F BE                  CP      (HL)            ; Compare MSBs
3528   1840 C0                  RET     NZ              ; Different
3529   1841 2B                  DEC     HL              ; Point to NMSB
3530   1842 7A                  LD      A,D             ; Get NMSB
3531   1843 BE                  CP      (HL)            ; Compare NMSBs
3532   1844 C0                  RET     NZ              ; Different
3533   1845 2B                  DEC     HL              ; Point to LSB
3534   1846 7B                  LD      A,E             ; Get LSB
3535   1847 96                  SUB     (HL)            ; Compare LSBs
3536   1848 C0                  RET     NZ              ; Different
3537   1849 E1                  POP     HL              ; Drop RETurn
3538   184A E1                  POP     HL              ; Drop another RETurn
3539   184B C9                  RET
3540   184C             
3541   184C 47          FPINT:  LD      B,A             ; <- Move
3542   184D 4F                  LD      C,A             ; <- exponent
3543   184E 57                  LD      D,A             ; <- to all
3544   184F 5F                  LD      E,A             ; <- bits
3545   1850 B7                  OR      A               ; Test exponent
3546   1851 C8                  RET     Z               ; Zero - Return zero
3547   1852 E5                  PUSH    HL              ; Save pointer to number
3548   1853 CD F0 17            CALL    BCDEFP          ; Move FPREG to BCDE
3549   1856 CD 0A 18            CALL    SIGNS           ; Set MSBs & sign of result
3550   1859 AE                  XOR     (HL)            ; Combine with sign of FPREG
3551   185A 67                  LD      H,A             ; Save combined signs
3552   185B FC 70 18            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3553   185E 3E 98               LD      A,80H+24        ; 24 bits
3554   1860 90                  SUB     B               ; Bits to shift
3555   1861 CD 23 16            CALL    SCALE           ; Shift BCDE
3556   1864 7C                  LD      A,H             ; Get combined sign
3557   1865 17                  RLA                     ; Sign to carry
3558   1866 DC F6 15            CALL    C,FPROND        ; Negative - Round number up
3559   1869 06 00               LD      B,0             ; Zero exponent
3560   186B DC 0F 16            CALL    C,COMPL         ; If negative make positive
3561   186E E1                  POP     HL              ; Restore pointer to number
3562   186F C9                  RET
3563   1870             
3564   1870 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3565   1871 7A                  LD      A,D             ; Test LSBs
3566   1872 A3                  AND     E
3567   1873 3C                  INC     A
3568   1874 C0                  RET     NZ              ; Exit if LSBs not FFFF
3569   1875 0B                  DEC     BC              ; Decrement MSBs
3570   1876 C9                  RET
3571   1877             
3572   1877 21 2C 21    INT:    LD      HL,FPEXP        ; Point to exponent
3573   187A 7E                  LD      A,(HL)          ; Get exponent
3574   187B FE 98               CP      80H+24          ; Integer accuracy only?
3575   187D 3A 29 21            LD      A,(FPREG)       ; Get LSB
3576   1880 D0                  RET     NC              ; Yes - Already integer
3577   1881 7E                  LD      A,(HL)          ; Get exponent
3578   1882 CD 4C 18            CALL    FPINT           ; F.P to integer
3579   1885 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3580   1887 7B                  LD      A,E             ; Get LSB of number
3581   1888 F5                  PUSH    AF              ; Save LSB
3582   1889 79                  LD      A,C             ; Get MSB of number
3583   188A 17                  RLA                     ; Sign to carry
3584   188B CD AC 15            CALL    CONPOS          ; Set sign of result
3585   188E F1                  POP     AF              ; Restore LSB of number
3586   188F C9                  RET
3587   1890             
3588   1890 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3589   1893 78                  LD      A,B             ; Test multiplier
3590   1894 B1                  OR      C
3591   1895 C8                  RET     Z               ; Return zero if zero
3592   1896 3E 10               LD      A,16            ; 16 bits
3593   1898 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3594   1899 DA D0 10            JP      C,BSERR         ; ?BS Error if overflow
3595   189C EB                  EX      DE,HL
3596   189D 29                  ADD     HL,HL           ; Shift multiplier left
3597   189E EB                  EX      DE,HL
3598   189F D2 A6 18            JP      NC,NOMLAD       ; Bit was zero - No add
3599   18A2 09                  ADD     HL,BC           ; Add multiplicand
3600   18A3 DA D0 10            JP      C,BSERR         ; ?BS Error if overflow
3601   18A6 3D          NOMLAD: DEC     A               ; Count bits
3602   18A7 C2 98 18            JP      NZ,MLDBLP       ; More
3603   18AA C9                  RET
3604   18AB             
3605   18AB FE 2D       ASCTFP: CP      '-'             ; Negative?
3606   18AD F5                  PUSH    AF              ; Save it and flags
3607   18AE CA B7 18            JP      Z,CNVNUM        ; Yes - Convert number
3608   18B1 FE 2B               CP      '+'             ; Positive?
3609   18B3 CA B7 18            JP      Z,CNVNUM        ; Yes - Convert number
3610   18B6 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3611   18B7 CD C4 15    CNVNUM: CALL    RESZER          ; Set result to zero
3612   18BA 47                  LD      B,A             ; Digits after point counter
3613   18BB 57                  LD      D,A             ; Sign of exponent
3614   18BC 5F                  LD      E,A             ; Exponent of ten
3615   18BD 2F                  CPL
3616   18BE 4F                  LD      C,A             ; Before or after point flag
3617   18BF CD 55 09    MANLP:  CALL    GETCHR          ; Get next character
3618   18C2 DA 08 19            JP      C,ADDIG         ; Digit - Add to number
3619   18C5 FE 2E               CP      '.'
3620   18C7 CA E3 18            JP      Z,DPOINT        ; '.' - Flag point
3621   18CA FE 45               CP      'E'
3622   18CC C2 E7 18            JP      NZ,CONEXP       ; Not 'E' - Scale number
3623   18CF CD 55 09            CALL    GETCHR          ; Get next character
3624   18D2 CD FB 0E            CALL    SGNEXP          ; Get sign of exponent
3625   18D5 CD 55 09    EXPLP:  CALL    GETCHR          ; Get next character
3626   18D8 DA 2A 19            JP      C,EDIGIT        ; Digit - Add to exponent
3627   18DB 14                  INC     D               ; Is sign negative?
3628   18DC C2 E7 18            JP      NZ,CONEXP       ; No - Scale number
3629   18DF AF                  XOR     A
3630   18E0 93                  SUB     E               ; Negate exponent
3631   18E1 5F                  LD      E,A             ; And re-save it
3632   18E2 0C                  INC     C               ; Flag end of number
3633   18E3 0C          DPOINT: INC     C               ; Flag point passed
3634   18E4 CA BF 18            JP      Z,MANLP         ; Zero - Get another digit
3635   18E7 E5          CONEXP: PUSH    HL              ; Save code string address
3636   18E8 7B                  LD      A,E             ; Get exponent
3637   18E9 90                  SUB     B               ; Subtract digits after point
3638   18EA F4 00 19    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3639   18ED F2 F6 18            JP      P,ENDCON        ; Positive - All done
3640   18F0 F5                  PUSH    AF              ; Save number of times to /10
3641   18F1 CD EC 16            CALL    DIV10           ; Divide by 10
3642   18F4 F1                  POP     AF              ; Restore count
3643   18F5 3C                  INC     A               ; Count divides
3644   18F6             
3645   18F6 C2 EA 18    ENDCON: JP      NZ,SCALMI       ; More to do
3646   18F9 D1                  POP     DE              ; Restore code string address
3647   18FA F1                  POP     AF              ; Restore sign of number
3648   18FB CC CD 17            CALL    Z,INVSGN        ; Negative - Negate number
3649   18FE EB                  EX      DE,HL           ; Code string address to HL
3650   18FF C9                  RET
3651   1900             
3652   1900 C8          SCALPL: RET     Z               ; Exit if no scaling needed
3653   1901 F5          MULTEN: PUSH    AF              ; Save count
3654   1902 CD 8D 17            CALL    MLSP10          ; Multiply number by 10
3655   1905 F1                  POP     AF              ; Restore count
3656   1906 3D                  DEC     A               ; Count multiplies
3657   1907 C9                  RET
3658   1908             
3659   1908 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3660   1909 57                  LD      D,A             ; Save digit
3661   190A 78                  LD      A,B             ; Get digits after point
3662   190B 89                  ADC     A,C             ; Add one if after point
3663   190C 47                  LD      B,A             ; Re-save counter
3664   190D C5                  PUSH    BC              ; Save point flags
3665   190E E5                  PUSH    HL              ; Save code string address
3666   190F D5                  PUSH    DE              ; Save digit
3667   1910 CD 8D 17            CALL    MLSP10          ; Multiply number by 10
3668   1913 F1                  POP     AF              ; Restore digit
3669   1914 D6 30               SUB     '0'             ; Make it absolute
3670   1916 CD 1F 19            CALL    RSCALE          ; Re-scale number
3671   1919 E1                  POP     HL              ; Restore code string address
3672   191A C1                  POP     BC              ; Restore point flags
3673   191B D1                  POP     DE              ; Restore sign of exponent
3674   191C C3 BF 18            JP      MANLP           ; Get another digit
3675   191F             
3676   191F CD D5 17    RSCALE: CALL    STAKFP          ; Put number on stack
3677   1922 CD B6 17            CALL    FLGREL          ; Digit to add to FPREG
3678   1925 C1          PADD:   POP     BC              ; Restore number
3679   1926 D1                  POP     DE
3680   1927 C3 5E 15            JP      FPADD           ; Add BCDE to FPREG and return
3681   192A             
3682   192A 7B          EDIGIT: LD      A,E             ; Get digit
3683   192B 07                  RLCA                    ; Times 2
3684   192C 07                  RLCA                    ; Times 4
3685   192D 83                  ADD     A,E             ; Times 5
3686   192E 07                  RLCA                    ; Times 10
3687   192F 86                  ADD     A,(HL)          ; Add next digit
3688   1930 D6 30               SUB     '0'             ; Make it absolute
3689   1932 5F                  LD      E,A             ; Save new digit
3690   1933 C3 D5 18            JP      EXPLP           ; Look for another digit
3691   1936             
3692   1936 E5          LINEIN: PUSH    HL              ; Save code string address
3693   1937 21 95 04            LD      HL,INMSG        ; Output " in "
3694   193A CD 9B 12            CALL    PRS             ; Output string at HL
3695   193D E1                  POP     HL              ; Restore code string address
3696   193E EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3697   193F AF                  XOR     A
3698   1940 06 98               LD      B,80H+24        ; 24 bits
3699   1942 CD BB 17            CALL    RETINT          ; Return the integer
3700   1945 21 9A 12            LD      HL,PRNUMS       ; Print number string
3701   1948 E5                  PUSH    HL              ; Save for return
3702   1949 21 2E 21    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3703   194C E5                  PUSH    HL              ; Save for return
3704   194D CD A4 17            CALL    TSTSGN          ; Test sign of FPREG
3705   1950 36 20               LD      (HL),' '        ; Space at start
3706   1952 F2 57 19            JP      P,SPCFST        ; Positive - Space to start
3707   1955 36 2D               LD      (HL),'-'        ; '-' sign at start
3708   1957 23          SPCFST: INC     HL              ; First byte of number
3709   1958 36 30               LD      (HL),'0'        ; '0' if zero
3710   195A CA 0D 1A            JP      Z,JSTZER        ; Return '0' if zero
3711   195D E5                  PUSH    HL              ; Save buffer address
3712   195E FC CD 17            CALL    M,INVSGN        ; Negate FPREG if negative
3713   1961 AF                  XOR     A               ; Zero A
3714   1962 F5                  PUSH    AF              ; Save it
3715   1963 CD 13 1A            CALL    RNGTST          ; Test number is in range
3716   1966 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3717   1969 11 F8 4F            LD      DE,4FF8H
3718   196C CD 1F 18            CALL    CMPNUM          ; Compare numbers
3719   196F B7                  OR      A
3720   1970 E2 84 19            JP      PO,INRNG        ; > 99999.9 - Sort it out
3721   1973 F1                  POP     AF              ; Restore count
3722   1974 CD 01 19            CALL    MULTEN          ; Multiply by ten
3723   1977 F5                  PUSH    AF              ; Re-save count
3724   1978 C3 66 19            JP      SIXDIG          ; Test it again
3725   197B             
3726   197B CD EC 16    GTSIXD: CALL    DIV10           ; Divide by 10
3727   197E F1                  POP     AF              ; Get count
3728   197F 3C                  INC     A               ; Count divides
3729   1980 F5                  PUSH    AF              ; Re-save count
3730   1981 CD 13 1A            CALL    RNGTST          ; Test number is in range
3731   1984 CD 4C 15    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3732   1987 3C                  INC     A
3733   1988 CD 4C 18            CALL    FPINT           ; F.P to integer
3734   198B CD E5 17            CALL    FPBCDE          ; Move BCDE to FPREG
3735   198E 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3736   1991 F1                  POP     AF              ; Restore count
3737   1992 81                  ADD     A,C             ; 6 digits before point
3738   1993 3C                  INC     A               ; Add one
3739   1994 FA A0 19            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3740   1997 FE 08               CP      6+1+1           ; More than 999999 ?
3741   1999 D2 A0 19            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3742   199C 3C                  INC     A               ; Adjust for exponent
3743   199D 47                  LD      B,A             ; Exponent of number
3744   199E 3E 02               LD      A,2             ; Make it zero after
3745   19A0             
3746   19A0 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3747   19A1 3D                  DEC     A
3748   19A2 E1                  POP     HL              ; Restore buffer address
3749   19A3 F5                  PUSH    AF              ; Save count
3750   19A4 11 26 1A            LD      DE,POWERS       ; Powers of ten
3751   19A7 05                  DEC     B               ; Count digits before point
3752   19A8 C2 B1 19            JP      NZ,DIGTXT       ; Not zero - Do number
3753   19AB 36 2E               LD      (HL),'.'        ; Save point
3754   19AD 23                  INC     HL              ; Move on
3755   19AE 36 30               LD      (HL),'0'        ; Save zero
3756   19B0 23                  INC     HL              ; Move on
3757   19B1 05          DIGTXT: DEC     B               ; Count digits before point
3758   19B2 36 2E               LD      (HL),'.'        ; Save point in case
3759   19B4 CC FA 17            CALL    Z,INCHL         ; Last digit - move on
3760   19B7 C5                  PUSH    BC              ; Save digits before point
3761   19B8 E5                  PUSH    HL              ; Save buffer address
3762   19B9 D5                  PUSH    DE              ; Save powers of ten
3763   19BA CD F0 17            CALL    BCDEFP          ; Move FPREG to BCDE
3764   19BD E1                  POP     HL              ; Powers of ten table
3765   19BE 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3766   19C0 04          TRYAGN: INC     B               ; Count subtractions
3767   19C1 7B                  LD      A,E             ; Get LSB
3768   19C2 96                  SUB     (HL)            ; Subtract LSB
3769   19C3 5F                  LD      E,A             ; Save LSB
3770   19C4 23                  INC     HL
3771   19C5 7A                  LD      A,D             ; Get NMSB
3772   19C6 9E                  SBC     A,(HL)          ; Subtract NMSB
3773   19C7 57                  LD      D,A             ; Save NMSB
3774   19C8 23                  INC     HL
3775   19C9 79                  LD      A,C             ; Get MSB
3776   19CA 9E                  SBC     A,(HL)          ; Subtract MSB
3777   19CB 4F                  LD      C,A             ; Save MSB
3778   19CC 2B                  DEC     HL              ; Point back to start
3779   19CD 2B                  DEC     HL
3780   19CE D2 C0 19            JP      NC,TRYAGN       ; No overflow - Try again
3781   19D1 CD 03 16            CALL    PLUCDE          ; Restore number
3782   19D4 23                  INC     HL              ; Start of next number
3783   19D5 CD E5 17            CALL    FPBCDE          ; Move BCDE to FPREG
3784   19D8 EB                  EX      DE,HL           ; Save point in table
3785   19D9 E1                  POP     HL              ; Restore buffer address
3786   19DA 70                  LD      (HL),B          ; Save digit in buffer
3787   19DB 23                  INC     HL              ; And move on
3788   19DC C1                  POP     BC              ; Restore digit count
3789   19DD 0D                  DEC     C               ; Count digits
3790   19DE C2 B1 19            JP      NZ,DIGTXT       ; More - Do them
3791   19E1 05                  DEC     B               ; Any decimal part?
3792   19E2 CA F1 19            JP      Z,DOEBIT        ; No - Do 'E' bit
3793   19E5 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3794   19E6 7E                  LD      A,(HL)          ; Get character
3795   19E7 FE 30               CP      '0'             ; '0' character?
3796   19E9 CA E5 19            JP      Z,SUPTLZ        ; Yes - Look back for more
3797   19EC FE 2E               CP      '.'             ; A decimal point?
3798   19EE C4 FA 17            CALL    NZ,INCHL        ; Move back over digit
3799   19F1             
3800   19F1 F1          DOEBIT: POP     AF              ; Get 'E' flag
3801   19F2 CA 10 1A            JP      Z,NOENED        ; No 'E' needed - End buffer
3802   19F5 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3803   19F7 23                  INC     HL              ; And move on
3804   19F8 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3805   19FA F2 01 1A            JP      P,OUTEXP        ; Positive - Output exponent
3806   19FD 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3807   19FF 2F                  CPL                     ; Negate exponent
3808   1A00 3C                  INC     A
3809   1A01 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3810   1A03 04          EXPTEN: INC     B               ; Count subtractions
3811   1A04 D6 0A               SUB     10              ; Tens digit
3812   1A06 D2 03 1A            JP      NC,EXPTEN       ; More to do
3813   1A09 C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3814   1A0B 23                  INC     HL              ; Move on
3815   1A0C 70                  LD      (HL),B          ; Save MSB of exponent
3816   1A0D 23          JSTZER: INC     HL              ;
3817   1A0E 77                  LD      (HL),A          ; Save LSB of exponent
3818   1A0F 23                  INC     HL
3819   1A10 71          NOENED: LD      (HL),C          ; Mark end of buffer
3820   1A11 E1                  POP     HL              ; Restore code string address
3821   1A12 C9                  RET
3822   1A13             
3823   1A13 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3824   1A16 11 F7 23            LD      DE,23F7H
3825   1A19 CD 1F 18            CALL    CMPNUM          ; Compare numbers
3826   1A1C B7                  OR      A
3827   1A1D E1                  POP     HL              ; Return address to HL
3828   1A1E E2 7B 19            JP      PO,GTSIXD       ; Too big - Divide by ten
3829   1A21 E9                  JP      (HL)            ; Otherwise return to caller
3830   1A22             
3831   1A22 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3832   1A26             
3833   1A26 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3834   1A29 10 27 00            .BYTE      010H,027H,000H  ;  10000
3835   1A2C E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3836   1A2F 64 00 00            .BYTE      064H,000H,000H  ;    100
3837   1A32 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3838   1A35 01 00 00            .BYTE      001H,000H,000H  ;      1
3839   1A38             
3840   1A38 21 CD 17    NEGAFT: LD  HL,INVSGN           ; Negate result
3841   1A3B E3                  EX      (SP),HL         ; To be done after caller
3842   1A3C E9                  JP      (HL)            ; Return to caller
3843   1A3D             
3844   1A3D CD D5 17    SQR:    CALL    STAKFP          ; Put value on stack
3845   1A40 21 22 1A            LD      HL,HALF         ; Set power to 1/2
3846   1A43 CD E2 17            CALL    PHLTFP          ; Move 1/2 to FPREG
3847   1A46             
3848   1A46 C1          POWER:  POP     BC              ; Get base
3849   1A47 D1                  POP     DE
3850   1A48 CD A4 17            CALL    TSTSGN          ; Test sign of power
3851   1A4B 78                  LD      A,B             ; Get exponent of base
3852   1A4C CA 8B 1A            JP      Z,EXP           ; Make result 1 if zero
3853   1A4F F2 56 1A            JP      P,POWER1        ; Positive base - Ok
3854   1A52 B7                  OR      A               ; Zero to negative power?
3855   1A53 CA 00 05            JP      Z,DZERR         ; Yes - ?/0 Error
3856   1A56 B7          POWER1: OR      A               ; Base zero?
3857   1A57 CA C5 15            JP      Z,SAVEXP        ; Yes - Return zero
3858   1A5A D5                  PUSH    DE              ; Save base
3859   1A5B C5                  PUSH    BC
3860   1A5C 79                  LD      A,C             ; Get MSB of base
3861   1A5D F6 7F               OR      01111111B       ; Get sign status
3862   1A5F CD F0 17            CALL    BCDEFP          ; Move power to BCDE
3863   1A62 F2 73 1A            JP      P,POWER2        ; Positive base - Ok
3864   1A65 D5                  PUSH    DE              ; Save power
3865   1A66 C5                  PUSH    BC
3866   1A67 CD 77 18            CALL    INT             ; Get integer of power
3867   1A6A C1                  POP     BC              ; Restore power
3868   1A6B D1                  POP     DE
3869   1A6C F5                  PUSH    AF              ; MSB of base
3870   1A6D CD 1F 18            CALL    CMPNUM          ; Power an integer?
3871   1A70 E1                  POP     HL              ; Restore MSB of base
3872   1A71 7C                  LD      A,H             ; but don't affect flags
3873   1A72 1F                  RRA                     ; Exponent odd or even?
3874   1A73 E1          POWER2: POP     HL              ; Restore MSB and exponent
3875   1A74 22 2B 21            LD      (FPREG+2),HL    ; Save base in FPREG
3876   1A77 E1                  POP     HL              ; LSBs of base
3877   1A78 22 29 21            LD      (FPREG),HL      ; Save in FPREG
3878   1A7B DC 38 1A            CALL    C,NEGAFT        ; Odd power - Negate result
3879   1A7E CC CD 17            CALL    Z,INVSGN        ; Negative base - Negate it
3880   1A81 D5                  PUSH    DE              ; Save power
3881   1A82 C5                  PUSH    BC
3882   1A83 CD 58 16            CALL    LOG             ; Get LOG of base
3883   1A86 C1                  POP     BC              ; Restore power
3884   1A87 D1                  POP     DE
3885   1A88 CD 99 16            CALL    FPMULT          ; Multiply LOG by power
3886   1A8B             
3887   1A8B CD D5 17    EXP:    CALL    STAKFP          ; Put value on stack
3888   1A8E 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3889   1A91 11 3B AA            LD      DE,0AA3BH
3890   1A94 CD 99 16            CALL    FPMULT          ; Multiply value by 1/LN(2)
3891   1A97 3A 2C 21            LD      A,(FPEXP)       ; Get exponent
3892   1A9A FE 88               CP      80H+8           ; Is it in range?
3893   1A9C D2 80 17            JP      NC,OVTST1       ; No - Test for overflow
3894   1A9F CD 77 18            CALL    INT             ; Get INT of FPREG
3895   1AA2 C6 80               ADD     A,80H           ; For excess 128
3896   1AA4 C6 02               ADD     A,2             ; Exponent > 126?
3897   1AA6 DA 80 17            JP      C,OVTST1        ; Yes - Test for overflow
3898   1AA9 F5                  PUSH    AF              ; Save scaling factor
3899   1AAA 21 47 16            LD      HL,UNITY        ; Point to 1.
3900   1AAD CD 4F 15            CALL    ADDPHL          ; Add 1 to FPREG
3901   1AB0 CD 90 16            CALL    MULLN2          ; Multiply by LN(2)
3902   1AB3 F1                  POP     AF              ; Restore scaling factor
3903   1AB4 C1                  POP     BC              ; Restore exponent
3904   1AB5 D1                  POP     DE
3905   1AB6 F5                  PUSH    AF              ; Save scaling factor
3906   1AB7 CD 5B 15            CALL    SUBCDE          ; Subtract exponent from FPREG
3907   1ABA CD CD 17            CALL    INVSGN          ; Negate result
3908   1ABD 21 CB 1A            LD      HL,EXPTAB       ; Coefficient table
3909   1AC0 CD FB 1A            CALL    SMSER1          ; Sum the series
3910   1AC3 11 00 00            LD      DE,0            ; Zero LSBs
3911   1AC6 C1                  POP     BC              ; Scaling factor
3912   1AC7 4A                  LD      C,D             ; Zero MSB
3913   1AC8 C3 99 16            JP      FPMULT          ; Scale result to correct value
3914   1ACB             
3915   1ACB 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3916   1ACC 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3917   1AD0 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3918   1AD4 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3919   1AD8 E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3920   1ADC 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3921   1AE0 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3922   1AE4 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3923   1AE8 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3924   1AEC             
3925   1AEC CD D5 17    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3926   1AEF 11 97 16            LD      DE,MULT         ; Multiply by "X"
3927   1AF2 D5                  PUSH    DE              ; To be done after
3928   1AF3 E5                  PUSH    HL              ; Save address of table
3929   1AF4 CD F0 17            CALL    BCDEFP          ; Move FPREG to BCDE
3930   1AF7 CD 99 16            CALL    FPMULT          ; Square the value
3931   1AFA E1                  POP     HL              ; Restore address of table
3932   1AFB CD D5 17    SMSER1: CALL    STAKFP          ; Put value on stack
3933   1AFE 7E                  LD      A,(HL)          ; Get number of coefficients
3934   1AFF 23                  INC     HL              ; Point to start of table
3935   1B00 CD E2 17            CALL    PHLTFP          ; Move coefficient to FPREG
3936   1B03 06                  .BYTE      06H             ; Skip "POP AF"
3937   1B04 F1          SUMLP:  POP     AF              ; Restore count
3938   1B05 C1                  POP     BC              ; Restore number
3939   1B06 D1                  POP     DE
3940   1B07 3D                  DEC     A               ; Cont coefficients
3941   1B08 C8                  RET     Z               ; All done
3942   1B09 D5                  PUSH    DE              ; Save number
3943   1B0A C5                  PUSH    BC
3944   1B0B F5                  PUSH    AF              ; Save count
3945   1B0C E5                  PUSH    HL              ; Save address in table
3946   1B0D CD 99 16            CALL    FPMULT          ; Multiply FPREG by BCDE
3947   1B10 E1                  POP     HL              ; Restore address in table
3948   1B11 CD F3 17            CALL    LOADFP          ; Number at HL to BCDE
3949   1B14 E5                  PUSH    HL              ; Save address in table
3950   1B15 CD 5E 15            CALL    FPADD           ; Add coefficient to FPREG
3951   1B18 E1                  POP     HL              ; Restore address in table
3952   1B19 C3 04 1B            JP      SUMLP           ; More coefficients
3953   1B1C             
3954   1B1C CD A4 17    RND:    CALL    TSTSGN          ; Test sign of FPREG
3955   1B1F 21 5E 20            LD      HL,SEED+2       ; Random number seed
3956   1B22 FA 7D 1B            JP      M,RESEED        ; Negative - Re-seed
3957   1B25 21 7F 20            LD      HL,LSTRND       ; Last random number
3958   1B28 CD E2 17            CALL    PHLTFP          ; Move last RND to FPREG
3959   1B2B 21 5E 20            LD      HL,SEED+2       ; Random number seed
3960   1B2E C8                  RET     Z               ; Return if RND(0)
3961   1B2F 86                  ADD     A,(HL)          ; Add (SEED)+2)
3962   1B30 E6 07               AND     00000111B       ; 0 to 7
3963   1B32 06 00               LD      B,0
3964   1B34 77                  LD      (HL),A          ; Re-save seed
3965   1B35 23                  INC     HL              ; Move to coefficient table
3966   1B36 87                  ADD     A,A             ; 4 bytes
3967   1B37 87                  ADD     A,A             ; per entry
3968   1B38 4F                  LD      C,A             ; BC = Offset into table
3969   1B39 09                  ADD     HL,BC           ; Point to coefficient
3970   1B3A CD F3 17            CALL    LOADFP          ; Coefficient to BCDE
3971   1B3D CD 99 16            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3972   1B40 3A 5D 20            LD      A,(SEED+1)      ; Get (SEED+1)
3973   1B43 3C                  INC     A               ; Add 1
3974   1B44 E6 03               AND     00000011B       ; 0 to 3
3975   1B46 06 00               LD      B,0
3976   1B48 FE 01               CP      1               ; Is it zero?
3977   1B4A 88                  ADC     A,B             ; Yes - Make it 1
3978   1B4B 32 5D 20            LD      (SEED+1),A      ; Re-save seed
3979   1B4E 21 81 1B            LD      HL,RNDTAB-4     ; Addition table
3980   1B51 87                  ADD     A,A             ; 4 bytes
3981   1B52 87                  ADD     A,A             ; per entry
3982   1B53 4F                  LD      C,A             ; BC = Offset into table
3983   1B54 09                  ADD     HL,BC           ; Point to value
3984   1B55 CD 4F 15            CALL    ADDPHL          ; Add value to FPREG
3985   1B58 CD F0 17    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3986   1B5B 7B                  LD      A,E             ; Get LSB
3987   1B5C 59                  LD      E,C             ; LSB = MSB
3988   1B5D EE 4F               XOR     01001111B       ; Fiddle around
3989   1B5F 4F                  LD      C,A             ; New MSB
3990   1B60 36 80               LD      (HL),80H        ; Set exponent
3991   1B62 2B                  DEC     HL              ; Point to MSB
3992   1B63 46                  LD      B,(HL)          ; Get MSB
3993   1B64 36 80               LD      (HL),80H        ; Make value -0.5
3994   1B66 21 5C 20            LD      HL,SEED         ; Random number seed
3995   1B69 34                  INC     (HL)            ; Count seed
3996   1B6A 7E                  LD      A,(HL)          ; Get seed
3997   1B6B D6 AB               SUB     171             ; Do it modulo 171
3998   1B6D C2 74 1B            JP      NZ,RND2         ; Non-zero - Ok
3999   1B70 77                  LD      (HL),A          ; Zero seed
4000   1B71 0C                  INC     C               ; Fillde about
4001   1B72 15                  DEC     D               ; with the
4002   1B73 1C                  INC     E               ; number
4003   1B74 CD AF 15    RND2:   CALL    BNORM           ; Normalise number
4004   1B77 21 7F 20            LD      HL,LSTRND       ; Save random number
4005   1B7A C3 FC 17            JP      FPTHL           ; Move FPREG to last and return
4006   1B7D             
4007   1B7D 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4008   1B7E 2B                  DEC     HL
4009   1B7F 77                  LD      (HL),A
4010   1B80 2B                  DEC     HL
4011   1B81 77                  LD      (HL),A
4012   1B82 C3 58 1B            JP      RND1            ; Return RND seed
4013   1B85             
4014   1B85 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4015   1B89 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4016   1B8D 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4017   1B91             
4018   1B91 21 DB 1B    COS:    LD      HL,HALFPI       ; Point to PI/2
4019   1B94 CD 4F 15            CALL    ADDPHL          ; Add it to PPREG
4020   1B97 CD D5 17    SIN:    CALL    STAKFP          ; Put angle on stack
4021   1B9A 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4022   1B9D 11 DB 0F            LD      DE,0FDBH
4023   1BA0 CD E5 17            CALL    FPBCDE          ; Move 2 PI to FPREG
4024   1BA3 C1                  POP     BC              ; Restore angle
4025   1BA4 D1                  POP     DE
4026   1BA5 CD FA 16            CALL    DVBCDE          ; Divide angle by 2 PI
4027   1BA8 CD D5 17            CALL    STAKFP          ; Put it on stack
4028   1BAB CD 77 18            CALL    INT             ; Get INT of result
4029   1BAE C1                  POP     BC              ; Restore number
4030   1BAF D1                  POP     DE
4031   1BB0 CD 5B 15            CALL    SUBCDE          ; Make it 0 <= value < 1
4032   1BB3 21 DF 1B            LD      HL,QUARTR       ; Point to 0.25
4033   1BB6 CD 55 15            CALL    SUBPHL          ; Subtract value from 0.25
4034   1BB9 CD A4 17            CALL    TSTSGN          ; Test sign of value
4035   1BBC 37                  SCF                     ; Flag positive
4036   1BBD F2 C7 1B            JP      P,SIN1          ; Positive - Ok
4037   1BC0 CD 4C 15            CALL    ROUND           ; Add 0.5 to value
4038   1BC3 CD A4 17            CALL    TSTSGN          ; Test sign of value
4039   1BC6 B7                  OR      A               ; Flag negative
4040   1BC7 F5          SIN1:   PUSH    AF              ; Save sign
4041   1BC8 F4 CD 17            CALL    P,INVSGN        ; Negate value if positive
4042   1BCB 21 DF 1B            LD      HL,QUARTR       ; Point to 0.25
4043   1BCE CD 4F 15            CALL    ADDPHL          ; Add 0.25 to value
4044   1BD1 F1                  POP     AF              ; Restore sign
4045   1BD2 D4 CD 17            CALL    NC,INVSGN       ; Negative - Make positive
4046   1BD5 21 E3 1B            LD      HL,SINTAB       ; Coefficient table
4047   1BD8 C3 EC 1A            JP      SUMSER          ; Evaluate sum of series
4048   1BDB             
4049   1BDB DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4050   1BDF             
4051   1BDF 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4052   1BE3             
4053   1BE3 05          SINTAB: .BYTE   5                       ; Table used by SIN
4054   1BE4 BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4055   1BE8 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4056   1BEC 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4057   1BF0 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4058   1BF4 DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4059   1BF8             
4060   1BF8 CD D5 17    TAN:    CALL    STAKFP          ; Put angle on stack
4061   1BFB CD 97 1B            CALL    SIN             ; Get SIN of angle
4062   1BFE C1                  POP     BC              ; Restore angle
4063   1BFF E1                  POP     HL
4064   1C00 CD D5 17            CALL    STAKFP          ; Save SIN of angle
4065   1C03 EB                  EX      DE,HL           ; BCDE = Angle
4066   1C04 CD E5 17            CALL    FPBCDE          ; Angle to FPREG
4067   1C07 CD 91 1B            CALL    COS             ; Get COS of angle
4068   1C0A C3 F8 16            JP      DIV             ; TAN = SIN / COS
4069   1C0D             
4070   1C0D CD A4 17    ATN:    CALL    TSTSGN          ; Test sign of value
4071   1C10 FC 38 1A            CALL    M,NEGAFT        ; Negate result after if -ve
4072   1C13 FC CD 17            CALL    M,INVSGN        ; Negate value if -ve
4073   1C16 3A 2C 21            LD      A,(FPEXP)       ; Get exponent
4074   1C19 FE 81               CP      81H             ; Number less than 1?
4075   1C1B DA 2A 1C            JP      C,ATN1          ; Yes - Get arc tangnt
4076   1C1E 01 00 81            LD      BC,8100H        ; BCDE = 1
4077   1C21 51                  LD      D,C
4078   1C22 59                  LD      E,C
4079   1C23 CD FA 16            CALL    DVBCDE          ; Get reciprocal of number
4080   1C26 21 55 15            LD      HL,SUBPHL       ; Sub angle from PI/2
4081   1C29 E5                  PUSH    HL              ; Save for angle > 1
4082   1C2A 21 34 1C    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4083   1C2D CD EC 1A            CALL    SUMSER          ; Evaluate sum of series
4084   1C30 21 DB 1B            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4085   1C33 C9                  RET                     ; Number > 1 - Sub from PI/2
4086   1C34             
4087   1C34 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4088   1C35 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4089   1C39 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4090   1C3D FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4091   1C41 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4092   1C45 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4093   1C49 C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4094   1C4D E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4095   1C51 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4096   1C55 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4097   1C59             
4098   1C59             
4099   1C59 C9          ARET:   RET                     ; A RETurn instruction
4100   1C5A             
4101   1C5A D7          GETINP: RST	    10H             ;input a character
4102   1C5B C9                  RET
4103   1C5C             
4104   1C5C             CLS: 
4105   1C5C 3E 0C               LD      A,CS            ; ASCII Clear screen
4106   1C5E C3 96 1D            JP      MONOUT          ; Output character
4107   1C61             
4108   1C61 CD 23 15    WIDTH:  CALL    GETINT          ; Get integer 0-255
4109   1C64 7B                  LD      A,E             ; Width to A
4110   1C65 32 87 20            LD      (LWIDTH),A      ; Set width
4111   1C68 C9                  RET
4112   1C69             
4113   1C69 CD C2 0D    LINES:  CALL    GETNUM          ; Get a number
4114   1C6C CD 07 0A            CALL    DEINT           ; Get integer -32768 to 32767
4115   1C6F ED 53 8B 20         LD      (LINESC),DE     ; Set lines counter
4116   1C73 ED 53 8D 20         LD      (LINESN),DE     ; Set lines number
4117   1C77 C9                  RET
4118   1C78             
4119   1C78 CD 07 0A    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4120   1C7B D5                  PUSH    DE              ; Save number
4121   1C7C E1                  POP     HL              ; Number to HL
4122   1C7D 46                  LD      B,(HL)          ; Get LSB of contents
4123   1C7E 23                  INC     HL
4124   1C7F 7E                  LD      A,(HL)          ; Get MSB of contents
4125   1C80 C3 7D 11            JP      ABPASS          ; Return integer AB
4126   1C83             
4127   1C83 CD C2 0D    DOKE:   CALL    GETNUM          ; Get a number
4128   1C86 CD 07 0A            CALL    DEINT           ; Get integer -32768 to 32767
4129   1C89 D5                  PUSH    DE              ; Save address
4130   1C8A CD CB 07            CALL    CHKSYN          ; Make sure ',' follows
4131   1C8D 2C                  .BYTE      ','
4132   1C8E CD C2 0D            CALL    GETNUM          ; Get a number
4133   1C91 CD 07 0A            CALL    DEINT           ; Get integer -32768 to 32767
4134   1C94 E3                  EX      (SP),HL         ; Save value,get address
4135   1C95 73                  LD      (HL),E          ; Save LSB of value
4136   1C96 23                  INC     HL
4137   1C97 72                  LD      (HL),D          ; Save MSB of value
4138   1C98 E1                  POP     HL              ; Restore code string address
4139   1C99 C9                  RET
4140   1C9A             
4141   1C9A             
4142   1C9A             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4143   1C9A             
4144   1C9A CD C5 0D    HEX: 	CALL	TSTNUM          ; Verify it's a number
4145   1C9D CD 07 0A            CALL	DEINT           ; Get integer -32768 to 32767
4146   1CA0 C5                  PUSH	BC              ; Save contents of BC
4147   1CA1 21 2E 21            LD	    HL,PBUFF
4148   1CA4 7A                  LD	    A,D             ; Get high order into A
4149   1CA5 FE 00               CP      $0
4150   1CA7 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4151   1CA9 CD D2 1C            CALL    BYT2ASC         ; Convert D to ASCII
4152   1CAC 78          		LD      A,B
4153   1CAD FE 30       		CP      '0'
4154   1CAF 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4155   1CB1 70                  LD	    (HL),B          ; Store it to PBUFF
4156   1CB2 23                  INC	    HL              ; Next location
4157   1CB3 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4158   1CB4 23                  INC     HL              ; Next location
4159   1CB5 7B          HEX2:   LD	    A,E             ; Get lower byte
4160   1CB6 CD D2 1C            CALL    BYT2ASC         ; Convert E to ASCII
4161   1CB9 7A          		LD      A,D
4162   1CBA FE 00               CP      $0
4163   1CBC 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4164   1CBE 78          		LD      A,B
4165   1CBF FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4166   1CC1 28 02       		JR      Z,HEX4
4167   1CC3 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4168   1CC4 23                  INC     HL              ; Next location
4169   1CC5 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4170   1CC6 23                  INC     HL              ; PBUFF+4 to zero
4171   1CC7 AF                  XOR     A               ; Terminating character
4172   1CC8 77                  LD      (HL),A          ; Store zero to terminate
4173   1CC9 23                  INC     HL              ; Make sure PBUFF is terminated
4174   1CCA 77                  LD      (HL),A          ; Store the double zero there
4175   1CCB C1                  POP     BC              ; Get BC back
4176   1CCC 21 2E 21            LD      HL,PBUFF        ; Reset to start of PBUFF
4177   1CCF C3 2B 12            JP      STR1            ; Convert the PBUFF to a string and return it
4178   1CD2             
4179   1CD2 47          BYT2ASC	LD      B,A             ; Save original value
4180   1CD3 E6 0F               AND     $0F             ; Strip off upper nybble
4181   1CD5 FE 0A               CP      $0A             ; 0-9?
4182   1CD7 38 02               JR      C,ADD30         ; If A-F, add 7 more
4183   1CD9 C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4184   1CDB C6 30       ADD30	ADD     A,$30           ; And make ASCII
4185   1CDD 4F                  LD      C,A             ; Save converted char to C
4186   1CDE 78                  LD      A,B             ; Retrieve original value
4187   1CDF 0F                  RRCA                    ; and Rotate it right
4188   1CE0 0F                  RRCA
4189   1CE1 0F                  RRCA
4190   1CE2 0F                  RRCA
4191   1CE3 E6 0F               AND     $0F             ; Mask off upper nybble
4192   1CE5 FE 0A               CP      $0A             ; 0-9? < A hex?
4193   1CE7 38 02               JR      C,ADD301        ; Skip Add 7
4194   1CE9 C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4195   1CEB C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4196   1CED 47                  LD      B,A             ; Store high order byte
4197   1CEE C9                  RET	
4198   1CEF             
4199   1CEF             ; Convert "&Hnnnn" to FPREG
4200   1CEF             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4201   1CEF             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4202   1CEF EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4203   1CF0 21 00 00            LD      HL,$0000        ; Zero out the value
4204   1CF3 CD 08 1D            CALL    GETHEX          ; Check the number for valid hex
4205   1CF6 DA 28 1D            JP      C,HXERR         ; First value wasn't hex, HX error
4206   1CF9 18 05               JR      HEXLP1          ; Convert first character
4207   1CFB CD 08 1D    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4208   1CFE 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4209   1D00 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4210   1D01 29                  ADD     HL,HL
4211   1D02 29                  ADD     HL,HL
4212   1D03 29                  ADD     HL,HL
4213   1D04 B5                  OR      L               ; Add in D0-D3 into L
4214   1D05 6F                  LD      L,A             ; Save new value
4215   1D06 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4216   1D08             
4217   1D08 13          GETHEX  INC     DE              ; Next location
4218   1D09 1A                  LD      A,(DE)          ; Load character at pointer
4219   1D0A FE 20               CP      ' '
4220   1D0C CA 08 1D            JP      Z,GETHEX        ; Skip spaces
4221   1D0F D6 30               SUB     $30             ; Get absolute value
4222   1D11 D8                  RET     C               ; < "0", error
4223   1D12 FE 0A               CP      $0A
4224   1D14 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4225   1D16 D6 07               SUB     $07             ; Reduce to A-F
4226   1D18 FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4227   1D1A D8                  RET     C               ; CY set if was :            ; < = > ? @
4228   1D1B FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4229   1D1D 3F                  CCF
4230   1D1E C9                  RET                     ; CY set if it wasn't valid hex
4231   1D1F                 
4232   1D1F EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4233   1D20 7A                  LD      A,D             ; Load DE into AC
4234   1D21 4B                  LD      C,E             ; For prep to 
4235   1D22 E5                  PUSH    HL
4236   1D23 CD 7C 11            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4237   1D26 E1                  POP     HL
4238   1D27 C9                  RET
4239   1D28             
4240   1D28 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4241   1D2A C3 11 05            JP      ERROR
4242   1D2D             
4243   1D2D             ; BIN$(NN) Convert integer to a 1-16 char binary string
4244   1D2D CD C5 0D    BIN:    CALL    TSTNUM          ; Verify it's a number
4245   1D30 CD 07 0A            CALL    DEINT           ; Get integer -32768 to 32767
4246   1D33 C5          BIN2:   PUSH    BC              ; Save contents of BC
4247   1D34 21 2E 21            LD      HL,PBUFF
4248   1D37 06 11               LD      B,17            ; One higher than max char count
4249   1D39             ZEROSUP:                        ; Suppress leading zeros
4250   1D39 05                  DEC     B               ; Max 16 chars
4251   1D3A 78                  LD      A,B
4252   1D3B FE 01               CP      $01
4253   1D3D 28 08               JR      Z,BITOUT        ; Always output at least one character
4254   1D3F CB 13               RL      E
4255   1D41 CB 12               RL      D
4256   1D43 30 F4               JR      NC,ZEROSUP
4257   1D45 18 04               JR      BITOUT2
4258   1D47             BITOUT:      
4259   1D47 CB 13               RL      E
4260   1D49 CB 12               RL      D               ; Top bit now in carry
4261   1D4B             BITOUT2:
4262   1D4B 3E 30               LD      A,'0'           ; Char for '0'
4263   1D4D CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4264   1D4F 77                  LD      (HL),A
4265   1D50 23                  INC     HL
4266   1D51 05                  DEC     B
4267   1D52 20 F3               JR      NZ,BITOUT
4268   1D54 AF                  XOR     A               ; Terminating character
4269   1D55 77                  LD      (HL),A          ; Store zero to terminate
4270   1D56 23                  INC     HL              ; Make sure PBUFF is terminated
4271   1D57 77                  LD      (HL),A          ; Store the double zero there
4272   1D58 C1                  POP     BC
4273   1D59 21 2E 21            LD      HL,PBUFF
4274   1D5C C3 2B 12            JP      STR1
4275   1D5F             
4276   1D5F             ; Convert "&Bnnnn" to FPREG
4277   1D5F             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4278   1D5F EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4279   1D60 21 00 00            LD      HL,$0000        ; Zero out the value
4280   1D63 CD 7C 1D            CALL    CHKBIN          ; Check the number for valid bin
4281   1D66 DA 8A 1D            JP      C,BINERR        ; First value wasn't bin, HX error
4282   1D69 D6 30       BINIT:  SUB     '0'
4283   1D6B 29                  ADD     HL,HL           ; Rotate HL left
4284   1D6C B5                  OR      L
4285   1D6D 6F                  LD      L,A
4286   1D6E CD 7C 1D            CALL    CHKBIN          ; Get second and addtional characters
4287   1D71 30 F6               JR      NC,BINIT        ; Process if a bin character
4288   1D73 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4289   1D74 7A                  LD      A,D             ; Load DE into AC
4290   1D75 4B                  LD      C,E             ; For prep to 
4291   1D76 E5                  PUSH    HL
4292   1D77 CD 7C 11            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4293   1D7A E1                  POP     HL
4294   1D7B C9                  RET
4295   1D7C             
4296   1D7C             ; Char is in A, NC if char is 0 or 1
4297   1D7C 13          CHKBIN: INC     DE
4298   1D7D 1A                  LD      A,(DE)
4299   1D7E FE 20               CP      ' '
4300   1D80 CA 7C 1D            JP      Z,CHKBIN        ; Skip spaces
4301   1D83 FE 30               CP      '0'             ; Set C if < '0'
4302   1D85 D8                  RET     C
4303   1D86 FE 32               CP      '2'
4304   1D88 3F                  CCF                     ; Set C if > '1'
4305   1D89 C9                  RET
4306   1D8A             
4307   1D8A 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4308   1D8C C3 11 05            JP      ERROR
4309   1D8F             
4310   1D8F             
4311   1D8F             JJUMP1: 
4312   1D8F DD 21 FF FF         LD      IX,-1           ; Flag cold start
4313   1D93 C3 61 01            JP      CSTART          ; Go and initialise
4314   1D96             
4315   1D96             MONOUT: 
4316   1D96 C3 08 00            JP      $0008           ; output a char
4317   1D99             
4318   1D99             
4319   1D99             MONITR: 
4320   1D99 C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4321   1D9C             
4322   1D9C             
4323   1D9C 3E 00       INITST: LD      A,0             ; Clear break flag
4324   1D9E 32 92 20            LD      (BRKFLG),A
4325   1DA1 C3 68 01            JP      INIT
4326   1DA4             
4327   1DA4 ED 45       ARETN:  RETN                    ; Return from NMI
4328   1DA6             
4329   1DA6             
4330   1DA6 F5          TSTBIT: PUSH    AF              ; Save bit mask
4331   1DA7 A0                  AND     B               ; Get common bits
4332   1DA8 C1                  POP     BC              ; Restore bit mask
4333   1DA9 B8                  CP      B               ; Same bit set?
4334   1DAA 3E 00               LD      A,0             ; Return 0 in A
4335   1DAC C9                  RET
4336   1DAD             
4337   1DAD CD D6 07    OUTNCR: CALL    OUTC            ; Output character in A
4338   1DB0 C3 FD 0B            JP      PRNTCRLF        ; Output CRLF
4339   1DB3             
4340   1DB3             .end
4341   1DB3             
tasm: Number of errors = 0

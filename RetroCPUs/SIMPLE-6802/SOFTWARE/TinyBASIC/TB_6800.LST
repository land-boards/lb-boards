                        ; Tom Pittman's 6800 Tiny BASIC
                        ; Reverse analyzed from (buggy) hexdump (TB68R1.tiff and TB68R2.tiff) at 
                        ;	http://www.ittybittycomputers.com/IttyBitty/TinyBasic/
                        ;	http://www.ittybittycomputers.com/IttyBitty/TinyBasic/index.htm
                        ;	http://www.ittybittycomputers.com/IttyBitty/TinyBasic/DDJ1/Design.html
                        ; Updates by Holger Veit
                        ;	http://www.ittybittycomputers.com/IttyBitty/TinyBasic/TB_6800.asm
                        ;
                        ; DGG - Noted my changes with my initials
                        ; Assemble using a68
                        ;	Command line
                        ;		..\a68 TB_6800.ASM -l TB_6800.LST -s TB_6800.s
                        ;	Assembler is from: http://www.retrotechnology.com/restore/a68.html
                        ;	Creates S Record that gets loaded from SmithBug
                        ; 	Load via SmithBug with
                        ; 		&
                        ; 		Then copy/paste S Records into terminal window
                        ; 	Run by typing (J = Jump)
                        ;		J 0100
                        ; 
                        
                        ; DGG - Addresses for ACIA
   8000                 ACIACS	EQU	$8000		; ACIA Control/Status port
   8001                 ACIADA	EQU	ACIACS+1	; ACIA data port
                        
   0000                                 org    0
   0000                                 rmb    32
   0020                 start_prgm:     rmb    2            ; $20 - Start of BASIC text (set to 0x0900)
   0022                 end_ram:        rmb    2            ; $22 - End of available RAM
   0024                 end_prgm:       rmb    2            ; $24 - End of BASIC text
   0026                 top_of_stack:   rmb    2            ; $26 - Top of return stack pointer location
   0028                 basic_lineno:   rmb    2            ; $28 - Save for current line number to be executed
   002a                 il_pc:          rmb    2            ; $2A - program counter for IL code
   002c                 basic_ptr:      rmb    2            ; $2C - pointer to currently executed BASIC byte
   002e                 basicptr_save:  rmb    2            ; $2E - temporary save for basic_ptr
   0030                 expr_stack:     rmb    80           ; $30 - lowest byte of expr_stack (0x30)
   0080                 rnd_seed:       rmb    2            ; $80 - used as seed value for RND function
                                                            ; note this is actually top of predecrementing expr_stack
   0082                 var_tbl:        rmb    52           ; $82 - variables (A-Z), 26 words
   00b6                 LS_end:         rmb    2            ; $B6 - used to store addr of end of LS listing,
                                                            ; start of list is in basic_ptr
   00b8                 BP_save:        rmb    2            ; $B8 - another temporary save for basic_ptr
   00ba                 X_save:         rmb    2            ; $BA - temporary save for X
   00bc                 IL_temp:        rmb    2            ; $BC - temporary for various IL operations
                                                            ; used for branch to IL handler routine for opcode
   00be                 lead_zero:      rmb    1            ; $BE - flag for number output and negative sign in DV
   00bf                 column_cnt:     rmb    1            ; $BF - counter for output columns (required for TAB in PRINT)
                                                            ; if bit 7 is set, suppress output (XOFF)
   00c0                 run_mode:       rmb    1            ; $C0 run mode
                                                            ; = 0 direct mode
                                                            ; <> 0 running program
   00c1                 expr_stack_low: rmb    1            ; $C1 - low addr byte of expr_stack (should be 0x30)
   00c2                 expr_stack_x:   rmb    1            ; $C2 high byte of expr_stack_top (==0x00, used with X register)
   00c3                 expr_stack_top: rmb    1            ; $C3 - low byte of expr_stack_top (used in 8 bit comparisons)
   00c4                 il_pc_save:     rmb    2            ; $C4 save of IL program counter
   00c6                                 rmb    58           ; $C6 - unused area in zero page (starting with 0xc6)
                        
                        ; cold start vector
                        ; DGG - PROGRAM START HERE
   0100                                 org    $0100
                        
   0100   bd 02 00      CV:             jsr    COLD_S       ; Do cold start initialization
                        
                        ; warm start vector
   0103   7e 02 2a      WV:             jmp    WARM_S       ; do warm start
                        
                        ; vector: get a character from input device into A
                        ; unimplemented - jump to system specific input routine
   0106   7e 08 f4      IN_V:           jmp    INEEE
                        
                        ; print a character in A to output device
                        ; unimplemented - jump to system specific output routine
   0109   7e 09 06      OUT_V:          jmp    OUTEEE
                        
                        ; test for break from input device, set C=1 if break
                        ; unimplemented - jump to break routine
                        ; note: at the end of the program, there are two
                        ; sample implementations for MIKBUG and MINIBUG
   010c   7e 07 6c      BV:				jmp		TSTBRK
                        
                        ; some standard constants
   010f   7f            BSC:            fcb    $7F          ; backspace code (should be 0x7f, but actually is '_')
   0110   18            LSC:            fcb    $18          ; line cancel code (CTRL-X)
   0111   00            PCC:            fcb    $00          ; CRLF padding characters
                        									; DGG - Used with slow teletypes - no need with VDU (was $83)
                                                            ; low 7 bits are number of NUL/0xFF
                        									; bit7=1: send 0xFF, =0, send NUL
   0112   80            TMC:            fcb    $80          ; DGG - XON/XOFF code
   0113   20            SSS:            fcb    $20          ; reserved bytes at end_prgm (to prevent return stack
                                                            ; underflow (spare area)
                        
                        ;******************************************************************************
                        ; utility routines for BASIC (not called in interpreter code)
                        ;******************************************************************************
                        
                        ;------------------------------------------------------------------------------
                        ; get the byte pointed to by X into B:A
                        ;------------------------------------------------------------------------------
   0114   a6 00         peek:           ldaa   0,x
   0116   5f                            clrb
   0117   39                            rts
                        
                        ;------------------------------------------------------------------------------
                        ; put the byte in A into cell pointed to by X
                        ;------------------------------------------------------------------------------
   0118   a7 00         poke:           staa   0,x
   011a   39                            rts
                        
                        ;******************************************************************************
                        ; Interpreter jump table
                        ;******************************************************************************
   011b                 il_jumptable:
   011b   02 9d                        fdb     IL_BBR       ; 0x40-0x5f: backward branch
   011d   02 a0                        fdb     IL_FBR       ; 0x60-0x7f: forward_branch
   011f   02 f3                        fdb     IL_BC        ; 0x80-0x9f: string match branch
   0121   03 17                        fdb     IL_BV        ; 0xa0-0xbf: branch if not variable
   0123   03 40                        fdb     IL_BN        ; 0xc0-0xdf: branch if not number
   0125   03 10                        fdb     IL_BE        ; 0xe0-0xff: branch if not eoln
   0127   01 fc                        fdb     IL_NO        ; 0x08:      no operation
   0129   01 d7                        fdb     IL_LB        ; 0x09:      push literal byte to TOS
   012b   01 db                        fdb     IL_LN        ; 0x0a:      push literal word to TOS
   012d   01 89                        fdb     IL_DS        ; 0x0b:      duplicate stack top
   012f   01 a6                        fdb     IL_SP        ; 0x0c:      pop TOS into A:B
   0131   01 a9                        fdb     expr_pop_byte ; 0x0d:     undocumented: pop byte into
   0133   01 77                        fdb     sub_177      ; 0x0e:      undocumented: push TOS on return stack
   0135   01 80                        fdb     sub_180      ; 0x0f:      undocumented: pop return stack into TOS
   0137   04 b0                        fdb     IL_SB        ; 0x10:      save BASIC pointer
   0139   04 b5                        fdb     IL_RB        ; 0x11:      restore BASIC pointer
   013b   04 05                        fdb     IL_FV        ; 0x12:      fetch variable
   013d   04 15                        fdb     IL_SV        ; 0x13:      store variable
   013f   04 d3                        fdb     IL_GS        ; 0x14:      save GOSUB line
   0141   04 9e                        fdb     IL_RS        ; 0x15:      restore saved line
   0143   04 93                        fdb     IL_GO        ; 0x16:      goto
   0145   03 c7                        fdb     IL_NE        ; 0x17:      negate
   0147   03 d4                        fdb     IL_AD        ; 0x18:      add
   0149   03 d2                        fdb     IL_SU        ; 0x19:      subtract
   014b   03 ea                        fdb     IL_MP        ; 0x1a:      multiply
   014d   03 70                        fdb     IL_DV        ; 0x1b:      divide
   014f   04 28                        fdb     IL_CP        ; 0x1c:      compare
   0151   04 4e                        fdb     IL_NX        ; 0x1d:      next BASIC statement
   0153   01 fc                        fdb     IL_NO        ; 0x1e:      reserved
   0155   05 dc                        fdb     IL_LS        ; 0x1f:      list program
   0157   05 4a                        fdb     IL_PN        ; 0x20:      print number
   0159   05 bf                        fdb     IL_PQ        ; 0x21:      print BASIC string
   015b   05 c7                        fdb     IL_PT        ; 0x22:      print tab
   015d   06 2d                        fdb     IL_NL        ; 0x23:      new line
   015f   05 b2                        fdb     IL_PC        ; 0x24:      print literal string
   0161   05 d0                        fdb     pt_print_spc ; 0x25:      undocumented op for SPC(x) function
   0163   01 fc                        fdb     IL_NO        ; 0x26:      reserved
   0165   06 5f                        fdb     IL_GL        ; 0x27:      get input line
   0167   01 fc                        fdb     IL_NO        ; 0x28:      reserved
   0169   01 fc                        fdb     IL_NO        ; 0x29:      reserved
   016b   06 b3                        fdb     IL_IL        ; 0x2A:      Insert BASIC line
   016d   02 17                        fdb     IL_MT        ; 0x2B:      mark BASIC program space empty
   016f   04 83                        fdb     IL_XQ        ; 0x2C:      execute
   0171   02 2a                        fdb     WARM_S       ; 0x2D:      warm start
   0173   01 b9                        fdb     IL_US        ; 0x2E:      machine language subroutine call
   0175   04 ab                        fdb     IL_RT        ; 0x2F:      IL subroutine return
                        
                        ;------------------------------------------------------------------------------
                        ; undocumented IL instruction (unused)
                        ; will take a value from expression stack
                        ; and put onto processor stack
                        ;------------------------------------------------------------------------------
   0177   8d 2d         sub_177:       bsr     IL_SP        ; pop word into A:B
   0179   97 bc                        staa    IL_temp      ; save into IL_temp
   017b   d7 bd                        stab    IL_temp+1
   017d   7e 04 dc                     jmp     push_payload ; push value on return stack
                        
                        ;------------------------------------------------------------------------------
                        ; undocumented IL instruction
                        ; will extract stored value on processor stack
                        ; and push back on expr_stack
                        ;------------------------------------------------------------------------------
   0180   bd 05 01      sub_180:       jsr     get_payload  ; extract stored value on return stack
   0183   96 bc                        ldaa    IL_temp      ; get this value
   0185   d6 bd                        ldab    IL_temp+1
   0187   20 04                        bra     expr_push_word ; push on expr_stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: duplicate top    of expr_stack
                        ;------------------------------------------------------------------------------
   0189   8d 1b         IL_DS:         bsr    IL_SP         ; pop top of expr_stack into A:B
   018b   8d 00                        bsr    *+2           ; push A:B twice on expr_stack
                                                            ; (fall through to expr_push_word routine)
                        
                        ;------------------------------------------------------------------------------
                        ; push A:B on expr_stack
                        ;------------------------------------------------------------------------------
   018d   de c2         expr_push_word: ldx    expr_stack_x ; get expr_stack top
   018f   09                           dex                  ; make space for another byte
   0190   e7 00                        stab    0,x          ; store byte (low)
   0192   20 02                        bra     expr_push_a  ; push A byte
                        
                        ;------------------------------------------------------------------------------
                        ; push A on expr_stack
                        ;------------------------------------------------------------------------------
   0194   de c2         expr_push_byte: ldx    expr_stack_x ; get expr_stack top
                        
   0196   09            expr_push_a:   dex                  ; make space for another byte
   0197   a7 00                        staa    0,x          ; save A as new TOS (top of stack value)
   0199   df c2                        stx     expr_stack_x ; set new stack top
   019b   36                           psha                 ; save A
   019c   96 c1                        ldaa    expr_stack_low ; get stack bottom
   019e   91 c3                        cmpa    expr_stack_top ; stack overflow?
   01a0   32                           pula                 ; restore A
   01a1   25 59                        bcs     IL_NO        ; no, exit
                        
   01a3   7e 02 61      j_error:       jmp     error        ; error: stack overflow
                        
                        ;------------------------------------------------------------------------------
                        ; pop the TOS word off stack, result in A:B
                        ;------------------------------------------------------------------------------
   01a6   8d 01         IL_SP:         bsr     expr_pop_byte ; pop a byte into B
   01a8   17                           tba                  ; put into A (high byte)
                                                            ; fall thru to expr_pop_byte to get more
                        
                        ;------------------------------------------------------------------------------
                        ; pop the TOS byte off stack into B
                        ;------------------------------------------------------------------------------
   01a9   c6 01         expr_pop_byte: ldab    #1           ; verify stack is not empty: has 1 byte
                        
   01ab   db c3         pop_byte:      addb    expr_stack_top ; next position on stack
   01ad   c1 80                        cmpb    #$80         ; is it > 0x80?
   01af   22 f2                        bhi     j_error      ; yes, stack underflow error
   01b1   de c2                        ldx     expr_stack_x ; get address of stack top
   01b3   7c 00 c3                     inc     expr_stack_top  ; pop stack
   01b6   e6 00                        ldab    0,x          ; get TOS byte in B
   01b8   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction US: machine language subroutine call
                        ;------------------------------------------------------------------------------
   01b9   8d 05         IL_US:         bsr     us_do        ; call machine language routine
   01bb   8d d7                        bsr     expr_push_byte ; return here when ML routine does RTS
                                                            ; push A:B on stack
   01bd   17                           tba
   01be   20 d4                        bra     expr_push_byte
                        
   01c0   86 06         us_do:         ldaa    #6           ; verify that stack has at least 6 bytes
   01c2   16                           tab
   01c3   9b c3                        adda    expr_stack_top
   01c5   81 80                        cmpa    #rnd_seed    ; at end of expr_stack?
   01c7   22 da                        bhi     j_error      ; yes, error
   01c9   de c2                        ldx     expr_stack_x ; load argument list
   01cb   97 c3                        staa    expr_stack_top ; drop 6 bytes from stack
                        
   01cd   a6 05         us_copyargs:   ldaa    5,x          ; push 5 bytes to return stack
   01cf   36                           psha
   01d0   09                           dex
   01d1   5a                           decb
   01d2   26 f9                        bne     us_copyargs  ; loop until done
   01d4   07                           tpa                  ; push status
   01d5   36                           psha
                                       ; Stack frame is
                                       ; return address IL_US+2 (caller of bsr us_do)
                                       ; B
                                       ; A
                                       ; X
                                       ; X
                                       ; address
                                       ; address
                                       ; PSW
   01d6   3b                           rti                  ; use RTI to branch to routine
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction push byte
                        ;------------------------------------------------------------------------------
   01d7   8d 1c         IL_LB:         bsr     fetch_il_op  ; get next byte from sequence
   01d9   20 b9                        bra     expr_push_byte  ; push single byte
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction push word
                        ;------------------------------------------------------------------------------
   01db   8d 18         IL_LN:         bsr     fetch_il_op  ; get next two bytes into A:B
   01dd   36                           psha
   01de   8d 15                        bsr     fetch_il_op
   01e0   16                           tab
   01e1   32                           pula
   01e2   20 a9                        bra     expr_push_word ; push on stack
                        
                        ;------------------------------------------------------------------------------
                        ; part of IL linterpreter loop, handle SX instruction
                        ;------------------------------------------------------------------------------
   01e4   9b c3         handle_il_SX:  adda    expr_stack_top ; opcode is 0..7, add to current stack ptr
   01e6   97 bd                        staa    IL_temp+1      ; make word pointer 0x00SP+opcode
   01e8   7f 00 bc                     clr     IL_temp
   01eb   8d bc                        bsr     expr_pop_byte  ; drop to byte into B
   01ed   de bc                        ldx     IL_temp        ; get index
   01ef   a6 00                        ldaa    0,x            ; get old byte
   01f1   e7 00                        stab    0,x            ; store byte from TOS there
   01f3   20 9f                        bra     expr_push_byte ; store old byte on TOS
                        
                        ;------------------------------------------------------------------------------
                        ; get the next IL opcode and increment the IL PC
                        ;------------------------------------------------------------------------------
   01f5   de 2a         fetch_il_op:   ldx     il_pc        ; get IL PC
   01f7   a6 00                        ldaa    0,x          ; read next opcode
   01f9   08                           inx                  ; advance to next byte
   01fa   df 2a                        stx     il_pc        ; save IL PC
                        
   01fc   4d            IL_NO:         tsta                 ; set flags
   01fd   39                           rts
                        
                        ;------------------------------------------------------------------------------
   01fe   07 9b         IL_baseaddr:   fdb start_of_il      ; only used address where IL code starts
                        
                        ;------------------------------------------------------------------------------
                        ; Cold start entry point
                        ; DGG - initialize start of BASIC
                        ;------------------------------------------------------------------------------
   0200   ce 0a 00      COLD_S:        ldx     #$0A00
   0203   df 20                        stx     start_prgm
                        
                        ;------------------------------------------------------------------------------
                        ; DGG - Find the top of the SRAM - used as stack pointer
                        ; DGG - Original code detected top in SmithBug scratch-pad area
                        ; DGG - Non-destructive test complements data twice
                        ; DGG - Changed to check up to just before the Scratchpad SRAM (0xEF00-0XEFFF)
                        ; DGG - Tested on build with 32KB of SRAM and got end_ram=7FFF
                        ;------------------------------------------------------------------------------
   0205                 find_end_ram: 
   0205   08            			inx                  ; point to next address
   0206   8c 7e ff      			cpx		#$7EFF		 ; DGG - check if at end of 32KB minus SMITHBUG scratchpad space
   0209   27 0a         			beq		endOfRam
   020b   63 01                     com     1,x          ; complement following byte
   020d   a6 01                     ldaa    1,x          ; load byte
   020f   63 01                     com     1,x          ; complement byte
   0211   a1 01                     cmpa    1,x          ; compare with value, should be different, if it is RAM
   0213   26 f0                     bne     find_end_ram ; if different, advance, until no more RAM cells found
   0215   df 22         endOfRam:   stx     end_ram      ; use topmost RAM cell
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction MT: clear program space
                        ;------------------------------------------------------------------------------
   0217   96 20         IL_MT:         ldaa    start_prgm   ; load start area
   0219   d6 21                        ldab    start_prgm+1
   021b   fb 01 13                     addb    SSS          ; add spare area after end of program
   021e   89 00                        adca    #0
   0220   97 24                        staa    end_prgm     ; save as end of program
   0222   d7 25                        stab    end_prgm+1
   0224   de 20                        ldx     start_prgm   ; get addr of start of program
   0226   6f 00                        clr     0,x          ; clear line number (means end)
   0228   6f 01                        clr     1,x
                        
                        ;------------------------------------------------------------------------------
                        ; warm start entry point
                        ;------------------------------------------------------------------------------
   022a   9e 22         WARM_S:        lds     end_ram      ; set return stack to end of RAM
                        
                                       ; enters here to start IL loop;
                        			   ; return here after error stop
   022c   bd 06 31      restart_il:    jsr     crlf         ; emit a CRLF
                        
   022f   fe 01 fe      restart_il_nocr: ldx   IL_baseaddr  ; load pointer to IL
   0232   df 2a                        stx     il_pc        ; store as current IL PC
   0234   ce 00 80                     ldx     #rnd_seed    ; set expr_stack top to 0x0080
   0237   df c2                        stx     expr_stack_x
   0239   ce 00 30                     ldx     #$30         ; set run_mode = 0 (no program)
                                                            ; set expr_stack_low = 0x30
   023c   df c0                        stx     run_mode
                        
   023e   9f 26         il_rs_return:  sts     top_of_stack ; save current stack position
                        
   0240   8d b3         il_mainloop:   bsr     fetch_il_op  ; fetch next IL opcode
   0242   8d 07                        bsr     exec_il_opcode ; execute current IL instruction
   0244   20 fa                        bra     il_mainloop  ; next instruction
                        
                                       ; trick programming here:
                                       ; this location is entered in IL_RS
                                       ; by incrementing the return address of exec_il_opcode
                                       ; so that it skips over the 'BRA il_mainloop' above
   0246   8c 20 04      il_rs_target:  cpx     #$2004       ; this might mask a BRA *+4, which however would
                                                            ; then point into exec_il_opcode+2, which is a TBA
                                                            ; which could then be used for a synthetic 
                        									; exec_il_opcode...
                                                            ; frankly: this is possibly either a remainder
                                                            ; from old code or a hidden serial number
                        									; the 6502 code has a similar anachronism in this
                        									; place, so it might be a serial number.
   0249   20 f3                        bra     il_rs_return ; enforce storing the stack pointer and do il_mainloop
                        
                        ;------------------------------------------------------------------------------
                        ; with IL opcode in A, decode opcode and
                        ; branch to appropriate routine
                        ;------------------------------------------------------------------------------
   024b   ce 01 17      exec_il_opcode: ldx    #il_jumptable-4 ; preload address of opcode table - 4
   024e   df bc                        stx     IL_temp
   0250   81 30                        cmpa    #$30         ; is opcode below 0x30?
   0252   24 56                        bcc     handle_30_ff ; no, skip to handler for higher opcodes
   0254   81 08                        cmpa    #8           ; is it below 8?
   0256   25 8c                        bcs     handle_il_SX ; yes, skip to handler for SX instructions
   0258   48                           asla                 ; make word index
   0259   97 bd                        staa    IL_temp+1    ; store as offset
   025b   de bc                        ldx     IL_temp
   025d   ee 17                        ldx     $17,x        ; load handler address via offset
   025f   6e 00                        jmp     0,x          ; jump to handler
                        
                        ;------------------------------------------------------------------------------
                        ; common error routine
                        ;------------------------------------------------------------------------------
   0261   bd 06 31      error:         jsr     crlf         ; emit CRLF
   0264   86 21                        ldaa    #'!'
   0266   97 c1                        staa    expr_stack_low ; lower stack bottom a bit to avoid another stack fault
                                                            ; SNAFU already; may overwrite some variables
   0268   bd 01 09                     jsr     OUT_V        ; emit exclamation mark
   026b   86 80                        ldaa    #rnd_seed    ; reinitialize stack top
   026d   97 c3                        staa    expr_stack_top
   026f   d6 2b                        ldab    il_pc+1      ; load IL PC into A:B
   0271   96 2a                        ldaa    il_pc
   0273   f0 01 ff                     subb    IL_baseaddr+1 ; subtract origin of interpreter
   0276   b2 01 fe                     sbca    IL_baseaddr
   0279   bd 05 47                     jsr     emit_number  ; print instruction of IL
   027c   96 c0                        ldaa    run_mode     ; is not in program?
   027e   27 0f                        beq     error_no_lineno ; no, suppress output of line number
   0280   ce 02 98                     ldx     #err_at      ; load error string
   0283   df 2a                        stx     il_pc
   0285   bd 05 b2                     jsr     IL_PC        ; print string at il_prgm_cnt, i.e. "AT "
   0288   96 28                        ldaa    basic_lineno ; get line number
   028a   d6 29                        ldab    basic_lineno+1
   028c   bd 05 47                     jsr     emit_number  ; print it
                        
   028f   86 07         error_no_lineno: ldaa  #7           ; emit BEL (0x07) character
   0291   bd 01 09                     jsr     OUT_V
   0294   9e 26                        lds     top_of_stack ; restore return stack
   0296   20 94                        bra     restart_il   ; restart interpreter after error
                        
   0298   20 41 54 20   err_at:        fcb     ' ','A','T',' ',$80 ; string " AT " + terminator
   029c   80            
                        
                        ;------------------------------------------------------------------------------
                        ; long branch instruction
                        ;------------------------------------------------------------------------------
   029d   7a 00 bc      IL_BBR:        dec     IL_temp      ; adjust position for negative jump (effectively 2's complement)
                        
   02a0   7d 00 bc      IL_FBR:        tst     IL_temp      ; test new position high byte
   02a3   27 bc                        beq     error        ; was displacement 0?
                                                            ; yes, this is an error condition
                        
   02a5   de bc         il_goto:       ldx     IL_temp      ; get new IL target address
   02a7   df 2a                        stx     il_pc        ; do the jump
   02a9   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; part of interpreter loop: handle opcode 0x30-3f
                        ;------------------------------------------------------------------------------
   02aa   81 40         handle_30_ff:  cmpa    #$40         ; above or equal 0x40?
   02ac   24 23                        bcc     handle_40_ff ; yes, handle elsewhere
                        
                                       ; handle the J/JS instructions
   02ae   36                           psha                 ; save opcode
   02af   bd 01 f5                     jsr     fetch_il_op  ; get next byte of instruction (low address)
   02b2   bb 01 ff                     adda    IL_baseaddr+1 ; add to IL interpreter base
   02b5   97 bd                        staa    IL_temp+1
   02b7   32                           pula                 ; restore opcode
   02b8   16                           tab                  ; save into B for later
   02b9   84 07                        anda    #7           ; mask out addressbits
   02bb   b9 01 fe                     adca    IL_baseaddr  ; add to base address
   02be   97 bc                        staa    IL_temp      ; save in temporary
   02c0   c4 08                        andb    #8           ; mask J/JS bit
   02c2   26 e1                        bne     il_goto      ; if set, is GOTO
   02c4   de 2a                        ldx     il_pc        ; get current IL PC
   02c6   97 2a                        staa    il_pc        ; save new IL PC
   02c8   d6 bd                        ldab    IL_temp+1
   02ca   d7 2b                        stab    il_pc+1
   02cc   df bc                        stx     IL_temp      ; save old in temporary
   02ce   7e 04 dc                     jmp     push_payload ; put on return stack
                        
                        ;------------------------------------------------------------------------------
                        ; handle the opcodes >=0x40
                        ;------------------------------------------------------------------------------
   02d1   16            handle_40_ff:  tab                  ; save opcode for later
   02d2   44                           lsra                 ; get opcode high nibble
   02d3   44                           lsra
   02d4   44                           lsra
   02d5   44                           lsra
   02d6   84 0e                        anda    #$E          ; make 0x04,0x06,...0x0e
   02d8   97 bd                        staa    IL_temp+1    ; make index into opcode jump table
   02da   de bc                        ldx     IL_temp
   02dc   ee 17                        ldx     $17,x        ; X points to handler routine
   02de   4f                           clra                 ; preload A=0 for null displacement (error indicator)
   02df   c1 60                        cmpb    #$60         ; is it BBR?
   02e1   c4 1f                        andb    #$1F         ; mask out displacement bits
   02e3   24 02                        bcc     not_bbr      ; was not backward branch
   02e5   ca e0                        orab    #$E0         ; make displacement negative
                        
   02e7   27 06         not_bbr:       beq     displ_error  ; displacement is zero? yes, skip
   02e9   db 2b                        addb    il_pc+1      ; add displayement to current IL_PC
   02eb   d7 bd                        stab    IL_temp+1
   02ed   99 2a                        adca    il_pc
                        
   02ef   97 bc         displ_error:   staa    IL_temp      ; store high byte of new address
                                                            ; if displayement=0, store high byte=0
                                                            ; -> invalid IL address, will lead to error
   02f1   6e 00                        jmp     0,x          ; jump to handler routine
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction string match branch
                        ; jump forward if string was not matched
                        ;------------------------------------------------------------------------------
   02f3   de 2c         IL_BC:         ldx     basic_ptr    ; save pointer to current BASIC character
   02f5   df b8                        stx     BP_save
                        
   02f7   8d 36         bc_loop:       bsr     get_nchar    ; skip spaces
   02f9   8d 2a                        bsr     fetch_basicchar ; consume char
   02fb   16                           tab                  ; save into B
   02fc   bd 01 f5                     jsr     fetch_il_op  ; get next char from IL stream
   02ff   2a 02                        bpl     bc_lastchar  ; if positive (not end of string), match further
   0301   ca 80                        orab    #$80         ; no, make basic char also bit7 set
                        
   0303   11            bc_lastchar:   cba                  ; compare bytes
   0304   26 04                        bne     bc_nomatch   ; do not match, skip
   0306   4d                           tsta                 ; more chars to match?
   0307   2a ee                        bpl     bc_loop      ; yes, loop
   0309   39                           rts                  ; that string matched! continue
                        
   030a   de b8         bc_nomatch:    ldx     BP_save      ; restore BASIC pointer
   030c   df 2c                        stx     basic_ptr
                        
   030e   20 90         j_FBR:         bra     IL_FBR       ; and branch forward
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: jump if not end of line
                        ;------------------------------------------------------------------------------
   0310   8d 1d         IL_BE:         bsr     get_nchar    ; get current BASIC char
   0312   81 0d                        cmpa    #$D          ; is it a CR?
   0314   26 f8                        bne     j_FBR        ; no, jump forward
   0316   39                           rts                  ; continue
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: branch if not variable
                        ; if variable, push 2*ASCII to expr_stack
                        ; (0x41..0x5A => 0x82...0xB4
                        ;  == offset to var table into zero page)
                        ;------------------------------------------------------------------------------
   0317   8d 16         IL_BV:         bsr     get_nchar    ; get current BASIC char
   0319   81 5a                        cmpa    #'Z'         ; is it an alphanumeric?
   031b   2e f1                        bgt     j_FBR        ; no, jump forward
   031d   81 41                        cmpa    #'A'
   031f   2d ed                        blt     j_FBR
   0321   48                           asla                 ; yes, double the ASCII code
                        			                        ; (make it a word index into var table
   0322   bd 01 94                     jsr     expr_push_byte ; push it on the stack
                                                            ; ...and consume this character
                        									; (fall thru to fetch_basicchar)
                        
                        ;------------------------------------------------------------------------------
                        ; get next BASIC char from program or line
                        ; return in A, Z=1 if CR
                        ;------------------------------------------------------------------------------
   0325                 fetch_basicchar:
   0325   de 2c                        ldx     basic_ptr    ; get address of current BASIC byte
   0327   a6 00                        ldaa    0,x          ; get byte
   0329   08                           inx                  ; advance to next character
   032a   df 2c                        stx     basic_ptr    ; save it
   032c   81 0d                        cmpa    #$D          ; check if 0x0d (end of line)
   032e   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; get next BASIC char (without advance)
                        ; C=1 if digit
                        ;------------------------------------------------------------------------------
   032f   8d f4         get_nchar:     bsr     fetch_basicchar ; get next char
   0331   81 20                        cmpa    #' '         ; is it a space?
   0333   27 fa                        beq     get_nchar    ; yes, skip that
   0335   09                           dex                  ; is no space, point back to this char
   0336   df 2c                        stx     basic_ptr
   0338   81 30                        cmpa    #'0'         ; is it a digit?
   033a   0c                           clc
   033b   2d 02                        blt     locret_33A   ; no, return C=0
   033d   81 3a                        cmpa    #':'         ; return C=1 if number
                        
   033f   39            locret_33A:    rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: branch if not number
                        ; if digit, convert this and following digits to number
                        ; and push on expr_stack
                        ;------------------------------------------------------------------------------
   0340   8d ed         IL_BN:         bsr     get_nchar    ; get BASIC char
   0342   24 ca                        bcc     j_FBR        ; if not digit, do forward branch
   0344   ce 00 00                     ldx     #0           ; clear temporary for number
   0347   df bc                        stx     IL_temp
                        
   0349   8d da         loop_bn:       bsr     fetch_basicchar ; get and consume this char
   034b   36                           psha                 ; save it
   034c   96 bc                        ldaa    IL_temp      ; multiply TEMP by 10
   034e   d6 bd                        ldab    IL_temp+1
   0350   58                           aslb                 ; temp*2
   0351   49                           rola
   0352   58                           aslb                 ; (temp*2)*2 = temp*4
   0353   49                           rola
   0354   db bd                        addb    IL_temp+1    ; (temp*4)+temp = temp*5
   0356   99 bc                        adca    IL_temp
   0358   58                           aslb                 ; (temp*5)*2 = temp*10
   0359   49                           rola
   035a   d7 bd                        stab    IL_temp+1
   035c   33                           pulb                 ; restore digit
   035d   c4 0f                        andb    #$F          ; mask out low nibble (0...9)
   035f   db bd                        addb    IL_temp+1    ; add into temp
   0361   89 00                        adca    #0
   0363   97 bc                        staa    IL_temp
   0365   d7 bd                        stab    IL_temp+1
   0367   8d c6                        bsr     get_nchar    ; get next char
   0369   25 de                        bcs     loop_bn      ; loop as long as digit found
   036b   96 bc                        ldaa    IL_temp      ; push A:B on expr_stack (B is still low byte)
   036d   7e 01 8d                     jmp     expr_push_word
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: divide
                        ;------------------------------------------------------------------------------
   0370   8d 73         IL_DV:         bsr     expr_check_4bytes ; validate 2 args on stack; discard 1 byte
   0372   a6 02                        ldaa    2,x          ; high byte dividend
   0374   47                           asra                 ; put sign into carry
   0375   49                           rola
   0376   a2 02                        sbca    2,x          ; A=0xFF if sign=1, 0x00 if sign=0
   0378   97 bc                        staa    IL_temp      ; sign extend dividend into 32bit (IL_temp=high word)
   037a   97 bd                        staa    IL_temp+1
   037c   16                           tab                  ; if negative, subtract 1 from dividend
   037d   eb 03                        addb    3,x          ; 0x0000...0x7fff stays positive
                                                            ; 0x8000 becomes positive
                                                            ; 0x8001...0xffff stays negative
   037f   e7 03                        stab    3,x
   0381   16                           tab
   0382   e9 02                        adcb    2,x
   0384   e7 02                        stab    2,x
   0386   a8 00                        eora    0,x          ; compare with sign of divisor
   0388   97 be                        staa    lead_zero    ; store result sign (negative if different, positive if same)
   038a   2a 02                        bpl     loc_389      ; if different sign, complement divisor
                                                            ; i.e. NEG/NEG -> do nothing
                                                            ;      NEG/POS -> NEG/NEG + lead_zero <0
                                                            ;      POS/NEG -> POS/POS + lead_zero <0
                                                            ;      POS/POS -> do nothing
   038c   8d 3b                        bsr     negate       ; negate operand
                        
   038e   c6 11         loc_389:       ldab    #$11         ; loop counter (16+1 iterations)
   0390   a6 00                        ldaa    0,x          ; is divisor = 0?
   0392   aa 01                        oraa    1,x
   0394   26 03                        bne     dv_loop      ; no, do division
   0396   7e 02 61                     jmp     error
                        
   0399   96 bd         dv_loop:       ldaa    IL_temp+1    ; subtract divisor from 32bit dividend
   039b   a0 01                        suba    1,x
   039d   36                           psha                 ; remember result
   039e   96 bc                        ldaa    IL_temp
   03a0   a2 00                        sbca    0,x
   03a2   36                           psha
   03a3   98 bc                        eora    IL_temp
   03a5   2b 09                        bmi     dv_smaller   ; subtract result was <0 ?
   03a7   32                           pula                 ; no, can subtract, remember a 1 bit (sec)
   03a8   97 bc                        staa    IL_temp      ; and store new result
   03aa   32                           pula
   03ab   97 bd                        staa    IL_temp+1
   03ad   0d                           sec
   03ae   20 03                        bra     dv_shift
                        
   03b0   32            dv_smaller:    pula                 ; discard subtraction
   03b1   32                           pula
   03b2   0c                           clc                  ; remember 0 bit
                        
   03b3   69 03         dv_shift:      rol     3,x          ; shift 32bit dividend left
   03b5   69 02                        rol     2,x          ; shift in result bit into lowest bit of dividend
   03b7   79 00 bd                     rol     IL_temp+1
   03ba   79 00 bc                     rol     IL_temp
   03bd   5a                           decb                 ; decrement loop
   03be   26 d9                        bne     dv_loop      ; subtract divisor from  32bit dividend
   03c0   8d 20                        bsr     j_expr_pop_byte ; drop a byte (other one was already removed above)
                                                            ; X points to result in (former) dividend at 2,X
   03c2   7d 00 be                     tst     lead_zero    ; operand signs were different?
   03c5   2a 0a                        bpl     locret_3CC   ; no, we are done
                        			                        ; else fall thru to negation (of result)
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: negate top of stack
                        ;------------------------------------------------------------------------------
   03c7   de c2         IL_NE:         ldx     expr_stack_x ; point to TOS
   03c9   60 01         negate:        neg     1,x          ; negate low byte
   03cb   26 02                        bne     ne_nocarry   ; not zero: no carry
   03cd   6a 00                        dec     0,x          ; propagate carry into high byte
                        
   03cf   63 00         ne_nocarry:    com     0,x          ; complement high byte
                        
   03d1   39            locret_3CC:    rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: subtract TOS from NOS -> NOS
                        ;------------------------------------------------------------------------------
   03d2   8d f3         IL_SU:         bsr     IL_NE        ; negate TOS. A-B is A+(-B)
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: add TOS and NOS -> NOS
                        ;------------------------------------------------------------------------------
   03d4   8d 0f         IL_AD:         bsr     expr_check_4bytes ; verify 4 bytes on stack
   03d6   e6 03                        ldab    3,x          ; add TOS and NOS into AB
   03d8   eb 01                        addb    1,x
   03da   a6 02                        ldaa    2,x
   03dc   a9 00                        adca    0,x
                        
   03de   a7 02         expr_save_pop: staa    2,x          ; store A:B in NOS and pop further byte
   03e0   e7 03                        stab    3,x
                        
   03e2   7e 01 a9      j_expr_pop_byte: jmp   expr_pop_byte
                        
                        ;------------------------------------------------------------------------------
                        ; validate stack contains at least 4 bytes, pop 1 byte
                        ;------------------------------------------------------------------------------
   03e5   c6 04         expr_check_4bytes: ldab #4
                        
   03e7   7e 01 ab      expr_check_nbytes: jmp  pop_byte    ; pop a byte
                        
                        ;------------------------------------------------------------------------------
                        ; multiply TOS with NOS -> NOS
                        ; I think this this routine is broken for negative numbers
                        ;------------------------------------------------------------------------------
   03ea   8d f9         IL_MP:         bsr     expr_check_4bytes ; validate 2 args
   03ec   86 10                        ldaa    #$10         ; bit count (16 bits)
   03ee   97 bc                        staa    IL_temp
   03f0   4f                           clra                 ; clear bottom 16 bits of result
   03f1   5f                           clrb
                        
   03f2   58            mp_loop:       aslb                 ; shift 1 bit left
   03f3   49                           rola
   03f4   68 01                        asl     1,x          ; shift 1st operand
   03f6   69 00                        rol     0,x
   03f8   24 04                        bcc     mp_notadd    ; is top bit = 1?
   03fa   eb 03                        addb    3,x          ; yes, add 2nd operand into A:B
   03fc   a9 02                        adca    2,x
                        
   03fe   7a 00 bc      mp_notadd:     dec     IL_temp      ; decrement counter
   0401   26 ef                        bne     mp_loop      ; loop 16 times
   0403   20 d9                        bra     expr_save_pop ; save result
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: fetch variable
                        ;------------------------------------------------------------------------------
   0405   8d db         IL_FV:         bsr     j_expr_pop_byte ; get byte (variable address into zero page)
   0407   d7 bd                        stab    IL_temp+1    ; make pointer into var table
   0409   7f 00 bc                     clr     IL_temp
   040c   de bc                        ldx     IL_temp
   040e   a6 00                        ldaa    0,x          ; get word indexed by X into A:B
   0410   e6 01                        ldab    1,x
   0412   7e 01 8d                     jmp     expr_push_word ; push it onto expr_stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: save variable
                        ;------------------------------------------------------------------------------
   0415   c6 03         IL_SV:         ldab    #3
   0417   8d ce                        bsr     expr_check_nbytes ; validate stack contains var index byte
                                                            ; and data word. drop single byte
   0419   e6 01                        ldab    1,x          ; get low byte of data in B
   041b   6f 01                        clr     1,x          ; clear this to build word index to var
   041d   a6 00                        ldaa    0,x          ; get high byte of data in A
   041f   ee 01                        ldx     1,x          ; load index into variable table
   0421   a7 00                        staa    0,x          ; save A:B into variable
   0423   e7 01                        stab    1,x
                        
   0425   7e 01 a6      j_IL_SP:       jmp     IL_SP        ; pop word off stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction compare
                        ; stack: TOS, MASK, NOS
                        ; compare TOS with NOS
                        ; MASK is bit0 = less
                        ;      bit1 = equal
                        ;      bit2 = greater
                        ; if compare reslut AND    mask return <>0, next IL op is skipped
                        ;------------------------------------------------------------------------------
   0428   8d fb         IL_CP:         bsr     j_IL_SP      ; pop TOS into A:B
   042a   37                           pshb                 ; save low byte
   042b   c6 03                        ldab    #3
   042d   8d b8                        bsr     expr_check_nbytes ; verify still 3 bytes on stack,
                        			                        ; drop one byte
   042f   7c 00 c3                     inc     expr_stack_top ; drop more bytes
   0432   7c 00 c3                     inc     expr_stack_top
   0435   33                           pulb                 ; restore low byte of TOS
   0436   e0 02                        subb    2,x          ; compare with 1st arg
                                                            ; note this subtraction is inverted
                        									; thus BGT means BLT, and vice versa
   0438   a2 01                        sbca    1,x
   043a   2e 0b                        bgt     cp_is_lt     ; if less, skip
   043c   2d 05                        blt     cp_is_gt     ; if greater, skip
   043e   5d                           tstb                 ; is result 0?
   043f   27 04                        beq     cp_is_eq
   0441   20 04                        bra     cp_is_lt
                        
   0443   67 00         cp_is_gt:      asr     0,x          ; shift bit 2 into carry
                        
   0445   67 00         cp_is_eq:      asr     0,x          ; shift bit 1 into carry
                        
   0447   67 00         cp_is_lt:      asr     0,x          ; shift bit 0 into carray
   0449   24 1b                        bcc     locret_461   ; not matched: exit, continue new IL op
   044b   7e 01 f5                     jmp     fetch_il_op  ; skip one IL op before continuing
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: advance to next BASIC line
                        ;------------------------------------------------------------------------------
   044e   96 c0         IL_NX:         ldaa    run_mode     ; run mode = 0?
   0450   27 1d                        beq     loc_46A      ; yes, continue program
                        
   0452                 nx_loop:                ; ...
   0452   bd 03 25                     jsr     fetch_basicchar ; get char from program
   0455   26 fb                        bne     nx_loop      ; is not CR, loop
   0457   8d 1d                        bsr     save_lineno  ; store line number
   0459   27 11                        beq     j1_error     ; is 0000 (end of program) -> error
                        
                        ;------------------------------------------------------------------------------
                        ; enters here from a GOTO,
                        ; basic pointer points to new line
                        ;------------------------------------------------------------------------------
   045b   8d 32         go_found_line: bsr    do_runmode    ; set run mode = running
   045d   bd 01 0c                     jsr    BV            ; test for BREAK
   0460   25 05                        bcs    do_break      ; if C=1, do break
   0462   de c4                        ldx    il_pc_save    ; restore IL_PC which was saved in XQ or GO
   0464   df 2a                        stx    il_pc
                        
   0466   39            locret_461:    rts
                        
   0467   fe 01 fe      do_break:      ldx    IL_baseaddr   ; restart interpreter
   046a   df 2a                        stx    il_pc
                        
   046c   7e 02 61      j1_error:      jmp    error         ; and emit break error
                        
                        ;------------------------------------------------------------------------------
                        ; fragment of code for IL_NX
                        ;------------------------------------------------------------------------------
   046f   9e 26         loc_46A:       lds     top_of_stack ; reload stack
   0471   97 bf                        staa    column_cnt   ; clear column count (A was 0)
   0473   7e 02 2f                     jmp     restart_il_nocr ; restart interpreter
                        
                        ;------------------------------------------------------------------------------
                        ; save current linenumber
                        ;------------------------------------------------------------------------------
   0476   bd 03 25      save_lineno:   jsr     fetch_basicchar ; get char from program code
   0479   97 28                        staa    basic_lineno    ; save as high lineno
   047b   bd 03 25                     jsr     fetch_basicchar ; get char from program code
   047e   97 29                        staa    basic_lineno+1  ; save as low lineno
   0480   de 28                        ldx     basic_lineno    ; load line number for later
   0482   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: execute program
                        ;------------------------------------------------------------------------------
   0483   de 20         IL_XQ:         ldx     start_prgm   ; set current start of program
   0485   df 2c                        stx     basic_ptr
   0487   8d ed                        bsr     save_lineno  ; save current line number
   0489   27 e1                        beq     j1_error     ; if zero, error
   048b   de 2a                        ldx     il_pc        ; save current IL_PC
   048d   df c4                        stx     il_pc_save
                        
   048f   07            do_runmode:    tpa                  ; will load non zero value (0xc0) into A - tricky!
   0490   97 c0                        staa    run_mode     ; set run_mode = "running"
   0492   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction GO
                        ;------------------------------------------------------------------------------
   0493   bd 05 1f      IL_GO:         jsr     find_line    ; find line which lineno is on stack
   0496   27 c3                        beq     go_found_line ; found? yes, skip
                        
   0498   de bc         go_error:      ldx     IL_temp      ; set requested lineno as current
   049a   df 28                        stx     basic_lineno
   049c   20 ce                        bra     j1_error     ; error - line not found
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: restore saved line
                        ;------------------------------------------------------------------------------
   049e   8d 61         IL_RS:         bsr     get_payload  ; get saved line 2 levels off stack
   04a0   30                           tsx                  ; point to caller of exec_il_opcode
   04a1   6c 01                        inc     1,x          ; hack: adjust return from exec_il_mainloop
                                                            ; that it points to il_rs_target just below
                                                            ; il_mainloop
   04a3   6c 01                        inc     1,x
   04a5   bd 05 2a                     jsr     find_line1   ; find the basic line
   04a8   26 ee                        bne     go_error     ; line not found? -> error
   04aa   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction return from IL call
                        ;------------------------------------------------------------------------------
   04ab   8d 54         IL_RT:         bsr     get_payload  ; get saved IL PC address
   04ad   df 2a                        stx     il_pc        ; restore it to IL_PC
   04af   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction save BASIC pointer
                        ;------------------------------------------------------------------------------
   04b0   ce 00 2c      IL_SB:         ldx     #basic_ptr   ; get address of basic pointer
   04b3   20 03                        bra     loc_4B3      ; continue in IL_RB common code
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: restore BASIC pointer
                        ;------------------------------------------------------------------------------
   04b5   ce 00 2e      IL_RB:         ldx     #basicptr_save
                        
   04b8   a6 01         loc_4B3:       ldaa    1,x          ; is it into the input line area?
   04ba   81 80                        cmpa    #$80
   04bc   24 08                        bcc     swap_bp      
   04be   a6 00                        ldaa    0,x
   04c0   26 04                        bne     swap_bp      ; no, do swap with save location
   04c2   de 2c                        ldx     basic_ptr
   04c4   20 0a                        bra     loc_4CB
                        
   04c6   de 2c         swap_bp:       ldx     basic_ptr    ; get basic pointer
   04c8   96 2e                        ldaa    basicptr_save ; move saved pointer to basic ptr
   04ca   97 2c                        staa    basic_ptr
   04cc   96 2f                        ldaa    basicptr_save+1
   04ce   97 2d                        staa    basic_ptr+1
                        
   04d0   df 2e         loc_4CB:       stx     basicptr_save ; store old basic pointer into save
   04d2   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction gosub
                        ;------------------------------------------------------------------------------
   04d3   30            IL_GS:         tsx
   04d4   6c 01                        inc     1,x          ; adjust return address to il_rs_target
   04d6   6c 01                        inc     1,x
   04d8   de 28                        ldx     basic_lineno ; get line number of GOSUB
   04da   df bc                        stx     IL_temp      ; store it in temp
                        			                        ; an fall thru to payload saver which
                                                            ; injects temp into return stack
                        
                        ;------------------------------------------------------------------------------
                        ; insert IL_temp into return stack
                        ;
                        ; stack holds (low to high addresses)
                        ; SP->
                        ;   return address of exec_il_opcode
                        ;   other data
                        ;
                        ; afterwards
                        ; SP ->
                        ;   return address of exec_il_opcode
                        ;   payload
                        ;   other data
                        ;------------------------------------------------------------------------------
   04dc   34            push_payload:  des                  ; reserve 2 bytes on processor stack
   04dd   34                           des
   04de   30                           tsx                  ; get address in X
   04df   a6 02                        ldaa    2,x          ; duplicate return address
   04e1   a7 00                        staa    0,x
   04e3   a6 03                        ldaa    3,x
   04e5   a7 01                        staa    1,x
   04e7   96 bc                        ldaa    IL_temp      ; insert return address for JS instruction in stack
   04e9   a7 02                        staa    2,x
   04eb   96 bd                        ldaa    IL_temp+1
   04ed   a7 03                        staa    3,x
   04ef   ce 00 24                     ldx     #end_prgm    ; address of end of program
   04f2   9f bc                        sts     IL_temp      ; save current stack in temporary
   04f4   a6 01                        ldaa    1,x          ; check that stack does not run into program code
   04f6   90 bd                        suba    IL_temp+1
   04f8   a6 00                        ldaa    0,x
   04fa   92 bc                        sbca    IL_temp
   04fc   25 20                        bcs     locret_519   ; is still space available?
                                                            ; yes, exit
   04fe   7e 02 61      j2_error:      jmp    error         ; no error
                        
                        ;------------------------------------------------------------------------------
                        ; return payload in X
                        ;
                        ; stack:
                        ; X
                        ; 0  returnaddr    caller of get_payload
                        ; 1  returnaddr    caller of get_payload
                        ; 2  returnaddr    caller of exec_il_opcode
                        ; 3  returnaddr    caller of exec_il_opcode
                        ; 4  payload
                        ; 5  payload
                        ;------------------------------------------------------------------------------
   0501   30            get_payload:   tsx                  ; copy return stack addr to X
   0502   08                           inx                  ; pointing to return address
   0503   08                           inx                  ; skip over return address and 2 more bytes
                                                            ; point to index 3
   0504   08                           inx
   0505   9c 22                        cpx     end_ram      ; stack underflow?
   0507   27 f5                        beq     j2_error     ; yes, error
   0509   ee 01                        ldx     1,x          ; get payload into X
   050b   df bc                        stx     IL_temp      ; save it
   050d   30                           tsx                  ; point to return address
   050e   37                           pshb                 ; save B
   050f   c6 04                        ldab    #4           ; move 4 bytes above
                        
   0511   a6 03         gp_loop:       ldaa    3,x
   0513   a7 05                        staa    5,x
   0515   09                           dex
   0516   5a                           decb
   0517   26 f8                        bne     gp_loop      ; loop until done
   0519   33                           pulb                 ; restore B
   051a   31                           ins                  ; drop 1 word (duplicate return address)
   051b   31                           ins
   051c   de bc                        ldx     IL_temp      ; get payload
                        
   051e   39            locret_519:    rts                  ; done
                        
                        ;------------------------------------------------------------------------------
                        ; find BASIC line whose lineno is on stack
                        ; discard from stack
                        ; return found line in basic_ptr
                        ; Z=1 if line is matched exactly
                        ;------------------------------------------------------------------------------
   051f   bd 01 a6      find_line:     jsr     IL_SP        ; pop word into A:B
   0522   d7 bd                        stab    IL_temp+1    ; save in temporary
   0524   97 bc                        staa    IL_temp
   0526   9a bd                        oraa    IL_temp+1    ; check if zero (invalid)
   0528   27 d4                        beq     j2_error     ; if so, error
                        
                                       ; find BASIC line whose lineno is in IL_temp
   052a   de 20         find_line1:    ldx     start_prgm   ; set BASIC pointer to start
   052c   df 2c                        stx     basic_ptr
                        
   052e   bd 04 76      test_line:     jsr     save_lineno  ; save current lineno
                                                            ; note: X = lineno
   0531   27 11                        beq     find_exit    ; if zero, skip to end
   0533   d6 29                        ldab    basic_lineno+1 ; compare line number with current line
   0535   96 28                        ldaa    basic_lineno
   0537   d0 bd                        subb    IL_temp+1
   0539   92 bc                        sbca    IL_temp
   053b   24 07                        bcc     find_exit    ; if above, exit
                        
   053d   bd 03 25      find_eoln:     jsr     fetch_basicchar ; get next char
   0540   26 fb                        bne     find_eoln    ; not CR? loop
   0542   20 ea                        bra     test_line    ; check next line
                        
   0544   9c bc         find_exit:     cpx     IL_temp      ; compare current linenumber with searched one
   0546   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; emit number in A:B
                        ;------------------------------------------------------------------------------
   0547   bd 01 8d      emit_number:   jsr     expr_push_word ; push number on stack
                        
   054a   de c2         IL_PN:         ldx     expr_stack_x ; get address of stack top
   054c   6d 00                        tst     0,x          ; is number negative?
   054e   2a 07                        bpl     loc_552      ; no, skip
   0550   bd 03 c7                     jsr     IL_NE        ; negate top of stack
   0553   86 2d                        ldaa    #'-'         ; emit negative sign
   0555   8d 46                        bsr     emit_char
                        
   0557   4f            loc_552:       clra                 ; push 0 (end of digits)
   0558   36                           psha
   0559   c6 0f                        ldab    #$F
   055b   86 1a                        ldaa    #$1A
   055d   36                           psha                 ; counter for 10's (0x1A)
   055e   37                           pshb                 ; counter for 100's (0x0F)
   055f   36                           psha                 ; counter for 1000's, (0x1A)
   0560   37                           pshb                 ; counter for 10000's (0x0f)
   0561   bd 01 a6                     jsr     IL_SP        ; pop TOS into A:B
   0564   30                           tsx                  ; point to the constants 0xF, 0x1A....
                        
   0565   6c 00         loop_10000s:   inc     0,x          ; increment counter for 10000's
   0567   c0 10                        subb    #$10         ; subtract 10000 (0x2710) until negative
   0569   82 27                        sbca    #$27
   056b   24 f8                        bcc     loop_10000s  ; counter for 10000's will become 0x10...0x14
                        
   056d   6a 01         loop_1000s:    dec     1,x          ; is now negative value, subtract until positive again
   056f   cb e8                        addb    #$E8         ; add 1000 (0x3e8) until positive again 
   0571   89 03                        adca    #3           ; decrement counter for 1000's
   0573   24 f8                        bcc     loop_1000s   ; counter for 1000's will become 0x19...0x10
                        
   0575   6c 02         loop_100s:     inc     2,x          ; is positive value now
   0577   c0 64                        subb    #$64         ; subtract 100 (0x54) until negative
   0579   82 00                        sbca    #0
   057b   24 f8                        bcc     loop_100s    ; counter for 100's becomes 0x10...0x19
                        
   057d   6a 03         loop_10s:      dec     3,x          ; is now negative
   057f   cb 0a                        addb    #$A          ; add 10 until positive again
   0581   24 fa                        bcc    loop_10s      ; counter for 10's become 0x10..0x19
                                                            ; B contains remianing 1's digits
   0583   7f 00 be                     clr     lead_zero    ; clear flag to suppress leading zeroes
                        
   0586   32            emit_digits:   pula                 ; restore counter 10000
   0587   4d                           tsta                 ; was zero?
   0588   27 04                        beq     last_digit   ; yes, last digit to emit, this one is in B
   058a   8d 03                        bsr     emit_digit   ; emit digit in A, suppress leading zeroes
   058c   20 f8                        bra     emit_digits  ; guarantee last digit is printed.
                        
   058e   17            last_digit:    tba                  ; last digit is in B
                        
   058f   81 10         emit_digit:    cmpa    #$10         ; check if '0' (note range is 0x10..19 if not last digit)
   0591   26 05                        bne     emit_digit1  ; no, must emit
                                                            ; note for last digit, any value will be emitted,
                                                            ; because it can't be 0x10 (is 0...9)
   0593   7d 00 be                     tst     lead_zero    ; already emitted a digit?
   0596   27 17                        beq     locret_5AA   ; no, exit (leading zero)
                        
   0598   7c 00 be      emit_digit1:   inc     lead_zero    ; notify digit print
   059b   8a 30                        oraa    #'0'         ; make it a real ASCII '0'...'9'
                                                            ; and print it, by fallthru to emit_char
                        
                        ;------------------------------------------------------------------------------
                        ; emit a character in A
                        ;------------------------------------------------------------------------------
   059d   7c 00 bf      emit_char:     inc     column_cnt   ; advance to column 1
   05a0   2b 0a                        bmi     loc_5A7      ; if at column 128, stop emit
   05a2   df ba                        stx     X_save       ; save X
   05a4   37                           pshb                 ; save B
   05a5   bd 01 09                     jsr     OUT_V        ; emit character
   05a8   33                           pulb                 ; restore B
   05a9   de ba                        ldx     X_save       ; restore X
   05ab   39                           rts                  ; done
                        
   05ac   7a 00 bf      loc_5A7:       dec     column_cnt   ; if column = 0x80, don't advance further
                        
   05af   39            locret_5AA:    rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction print string
                        ;------------------------------------------------------------------------------
   05b0   8d eb         pc_loop:       bsr     emit_char    ; emit a character and continue 
                                                            ; with PC instruction
                        
   05b2   bd 01 f5      IL_PC:         jsr     fetch_il_op  ; get next byte of instruction
   05b5   2a f9                        bpl     pc_loop      ; if positive, skip
   05b7   20 e4                        bra     emit_char    ; was last char, emit it and terminate
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction PQ
                        ;------------------------------------------------------------------------------
   05b9   81 22         loop_pq:       cmpa    #'"'         ; is character string terminator?
   05bb   27 f2                        beq     locret_5AA   ; yes, exit
   05bd   8d de                        bsr     emit_char    ; otherwise emit char
                                                            ; and redo PQ instruction
                        
   05bf   bd 03 25      IL_PQ:         jsr     fetch_basicchar ; get next char from BASIC text
   05c2   26 f5                        bne     loop_pq      ; if not CR, loop
   05c4   7e 02 61                     jmp     error        ; error - unterminated string
                        
                        ;------------------------------------------------------------------------------
                        ;  IL instruction print tab
                        ;------------------------------------------------------------------------------
   05c7   d6 bf         IL_PT:         ldab    column_cnt   ; column counter
   05c9   2b e4                        bmi     locret_5AA   ; if overflow, exit
   05cb   ca f8                        orab    #$F8         ; make 7...0
   05cd   50                           negb
   05ce   20 03                        bra     pt_loop      ; jump to space printer
                        
   05d0   bd 01 a6      pt_print_spc:  jsr     IL_SP        ; drop A:B off stack
                        
   05d3   5a            pt_loop:       decb                 ; decrement low byte
   05d4   2d d9                        blt     locret_5AA   ; < 0, exit
   05d6   86 20                        ldaa    #' '         ; emit a space
   05d8   8d c3                        bsr     emit_char
   05da   20 f7                        bra     pt_loop      ; loop
                        
                        ;------------------------------------------------------------------------------
                        ; IL Instruction List BASIC source
                        ;------------------------------------------------------------------------------
   05dc   de 2c         IL_LS:         ldx     basic_ptr    ; save current BASIC pointer
   05de   df b8                        stx     BP_save
   05e0   de 20                        ldx     start_prgm   ; default start: begin of program
   05e2   df 2c                        stx     basic_ptr
   05e4   de 24                        ldx     end_prgm     ; default end: load X with end of program
   05e6   8d 2c                        bsr     ls_getlineno ; if argument to list given, make this new end
                                                            ; note "LIST start,end", so the first result
                                                            ; popped off stack is the end
   05e8   27 02                        beq     ls_nostart   ; no more argument on stack
   05ea   8d 28                        bsr     ls_getlineno ; save first position in LS_begin
                                                            ; get another argument into basic_ptr, if any
                        
   05ec   96 2c         ls_nostart:    ldaa    basic_ptr    ; compare start and end of listing
   05ee   d6 2d                        ldab    basic_ptr+1
   05f0   d0 b7                        subb    LS_end+1
   05f2   92 b6                        sbca    LS_end
   05f4   24 32                        bcc     ls_exit      ; start > end? yes, exit: nothing (more) to list
   05f6   bd 04 76                     jsr     save_lineno  ; save lineno of current line
   05f9   27 2d                        beq     ls_exit      ; is end of program (line 0)? yes, exit
   05fb   96 28                        ldaa    basic_lineno ; get current line number
   05fd   d6 29                        ldab    basic_lineno+1
   05ff   bd 05 47                     jsr     emit_number  ; print line number
   0602   86 20                        ldaa    #' '         ; print a space
                        
   0604   8d 4c         ls_loop:       bsr     j_emitchar
   0606   bd 01 0c                     jsr     BV           ; check for break
   0609   25 1d                        bcs     ls_exit      ; if break, exit
   060b   bd 03 25                     jsr     fetch_basicchar ; get next char from line
   060e   26 f4                        bne     ls_loop      ; if not CR, loop output
   0610   8d 1b                        bsr     IL_NL        ; emit a CRLF
   0612   20 d8                        bra     ls_nostart   ; loop with next line
                        
                        ;------------------------------------------------------------------------------
                        ; called with an address into BASIC code
                        ; return Z=1 if no argument
                        ;------------------------------------------------------------------------------
   0614   08            ls_getlineno:  inx                  ; increment X
   0615   df b6                        stx    LS_end        ; store as default end of listing
   0617   de c2                        ldx    expr_stack_x  ; get expr_stack ptr
   0619   8c 00 80                     cpx    #$80          ; is stack empty?
   061c   27 09                        beq    locret_622    ; yes, no arg given...done
   061e   bd 05 1f                     jsr    find_line     ; find the line (after the lineno) that was given on
                                                            ; stack (start line number)
                                                            ; result in X=basic_ptr
                        
   0621   de 2c         ls_to_linestart: ldx    basic_ptr   ; point back to lineno that was found
   0623   09                           dex
   0624   09                           dex
   0625   df 2c                        stx    basic_ptr     
                        
   0627   39            locret_622:    rts
                        
   0628   de b8         ls_exit:       ldx    BP_save       ; restore old BASIC pointer
   062a   df 2c                        stx    basic_ptr
   062c   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: emit new line
                        ;------------------------------------------------------------------------------
   062d   96 bf         IL_NL:         ldaa    column_cnt   ; if column > 127, suppress output
   062f   2b f6                        bmi     locret_622
                        
                        ;------------------------------------------------------------------------------
                        ; do a CRLF
                        ; DGG - Has padding for slow teletypes - not needed with Multicomp
                        ;------------------------------------------------------------------------------
   0631   86 0d         crlf:          ldaa    #$D          ; emit carriage return character
   0633   8d 1a                        bsr     emit_char_at_0
   0635   f6 01 11                     ldab    PCC          ; get padding mode
   0638   58                           aslb                 ; shift out bit 7
   0639   27 09                        beq     loc_63E      ; if no padding bytes, skip
                        
   063b   37            loc_636:       pshb                 ; save padding count
   063c   8d 0a                        bsr     emit_nul_padding ; emit padding
   063e   33                           pulb                 ; restore count
   063f   5a                           decb                 ; decrement twice (because above 
   0640   58            			   aslb                 ; multiplied *2)
   0641   5a                           decb
   0642   26 f7                        bne     loc_636      ; loop until done
                        
   0644   86 0a         loc_63E:       ldaa    #$A          ; emit line feed character
   0646   8d 0a                        bsr     j_emitchar   ; emit character (with increment column count)
                        
                                                            ; depending on PCC bit 7 emit 
                        									; either NUL or DEL (0xff) byte
   0648   4f            emit_nul_padding: clra              ; padding byte
   0649   7d 01 11                     tst     PCC          ; check if bit 7 of PCC:
                                                            ; =0, emit NUL bytes
                                                            ; =1, emit 0xFF bytes
   064c   2a 01                        bpl     emit_char_at_0 ; emit a NUL byte
   064e   43                           coma
                        
                                       ; emit a char in A and clear column count/XOFF mode
   064f   7f 00 bf      emit_char_at_0: clr    column_cnt   ; reset column to 0
                        
   0652   7e 05 9d      j_emitchar:    jmp     emit_char
                        
   0655   b6 01 12      do_xon:        ldaa    TMC          ; get XOFF flag
   0658   20 01                        bra     loc_655
                        
   065a   4f            do_xoff:       clra
                        
   065b   97 bf         loc_655:       staa    column_cnt   ; save column count
   065d   20 0a                        bra     gl_loop
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: get input line
                        ; uses expr_stack as buffer
                        ;------------------------------------------------------------------------------
   065f   ce 00 30      IL_GL:         ldx     #expr_stack  ; store floor of expr_stack as BASIC pointer
   0662   df 2c                        stx     basic_ptr
   0664   df bc                        stx     IL_temp      ; save pointer to char input into buffer
   0666   bd 01 8d                     jsr     expr_push_word ; save A:B for later (may be variable address, or alike)
                        
   0669   98 80         gl_loop:       eora    rnd_seed     ; use random A to create some entropy
   066b   97 80                        staa    rnd_seed
   066d   bd 01 06                     jsr     IN_V         ; get a char from input device
   0670   84 7f                        anda    #$7F         ; make 7bit ASCII
   0672   27 f5                        beq     gl_loop      ; if NUL, ignore
                                       ; cmpa    #$7F         ; if 0xFF/0x7F, ignore
                                       ; beq     gl_loop
   0674   81 0a                        cmpa    #$A          ; if LF, done
   0676   27 dd                        beq     do_xon
   0678   81 13                        cmpa    #$13         ; if DC3 (XOFF) handle XOFF
   067a   27 de                        beq     do_xoff
   067c   de bc                        ldx     IL_temp      ; get buffer pointer
   067e   b1 01 10                     cmpa    LSC          ; line cancel?
   0681   27 0a                        beq     gl_ctrlx
   0683   b1 01 0f                     cmpa    BSC          ; is it "_" ? (back character)
   0686   26 0c                        bne     gl_chkend    ; no, skip
   0688   8c 00 30                     cpx     #expr_stack  ; at start of buffer?
   068b   26 15                        bne     gl_dobackspace ; no, do a backspace
                        
   068d   de 2c         gl_ctrlx:      ldx     basic_ptr    ; reset pointer to input char
   068f   86 0d                        ldaa    #$D          ; load CR
   0691   7f 00 bf                     clr     column_cnt   ; do XON
                        
   0694   9c c2         gl_chkend:     cpx     expr_stack_x ; is end of buffer reached?
   0696   26 06                        bne     gl_savechar  ; no, skip
   0698   86 07                        ldaa    #7           ; emit BEL character (line overflow)
   069a   8d b6                        bsr     j_emitchar
   069c   20 cb                        bra     gl_loop      ; loop
                        
   069e   a7 00         gl_savechar:   staa    0,x          ; save char in buffer
   06a0   08                           inx                  ; advance
   06a1   08                           inx
                        
   06a2   09            gl_dobackspace:  dex
   06a3   df bc                        stx     IL_temp      ; !!! error in dump, was 0F
                                                            ; save new ptr to input
   06a5   81 0d                        cmpa    #$D          ; was char CR?
   06a7   26 c0                        bne     gl_loop      ; no, get another char
   06a9   bd 06 2d                     jsr     IL_NL        ; end of input reached
   06ac   96 bd                        ldaa    IL_temp+1    ; get buffer line
   06ae   97 c1                        staa    expr_stack_low ; save as new expr_stack bottom
                                                            ; (should not overwrite buffer)
   06b0   7e 01 a6                     jmp     IL_SP        ; pop old value off stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: insert BASIC line
                        ;------------------------------------------------------------------------------
   06b3   bd 04 c6      IL_IL:         jsr     swap_bp      ; basicptr_save = 0x80 (input buffer)
                                                            ; basic_ptr = invalid
   06b6   bd 05 1f                     jsr     find_line    ; search for line with lineno from stack
                                                            ; if found: address of BASIC text in basic_ptr
                                                            ; if not: address of next line or end of program
   06b9   07                           tpa                  ; save status, whether line was found
   06ba   bd 06 21                     jsr     ls_to_linestart ; adjust line back to lineno
   06bd   df b8                        stx     BP_save      ; save this in BP_save as well.
                                                            ; basic_ptr==BP_save is position where to enter
                                                            ; new line (if same lineno, overwrite)
   06bf   de bc                        ldx     IL_temp      ; save lineno to be handled in LS_end
   06c1   df b6                        stx     LS_end
   06c3   5f                           clrb                 ; preload length of stored line with 0
                                                            ; for line not found (must grow)
   06c4   06                           tap                  ; restore status of find_line
   06c5   26 0b                        bne     il_linenotfound ; skip if lineno not matched
                                                            ; hey, this line already exists!
   06c7   bd 04 76                     jsr     save_lineno  ; save lineno where we are currently in basic_lineno
   06ca   c6 fe                        ldab    #$FE         ; advance to end of line,
                                                            ; B is negative length of line
                        
   06cc   5a            il_findeoln:   decb
   06cd   bd 03 25                     jsr     fetch_basicchar
   06d0   26 fa                        bne     il_findeoln  ; loop until end of line
                                                            ; B now contains negative sizeof(stored line)
                        
   06d2   ce 00 00      il_linenotfound: ldx   #0           ; B is 0, if line does not yet exist
   06d5   df 28                        stx     basic_lineno ; clear lineno
   06d7   bd 04 c6                     jsr     swap_bp      ; basic_ptr = 0x80 (input buffer)
                                                            ; basicptr_save = at end of position to insert
                                                            ; (i.e. either before following line, or at end of
                                                            ; line to be grown/shrunk)
   06da   86 0d                        ldaa    #$D          ; calculate sizeof(input buffer)
                                                            ; load EOLN char
   06dc   de 2c                        ldx    basic_ptr     ; start at input buffer (after line number)
   06de   a1 00                        cmpa    0,x          ; is it eoln?
   06e0   27 0c                        beq     loc_6EC      ; yes, skip - this is an empty line: must delete
   06e2   cb 03                        addb    #3           ; no, reserve 3 bytes for lineno and CR
                        
   06e4   5c            loc_6E2:       incb                 ; increment B for every byte in current line <> eoln
   06e5   08                           inx
   06e6   a1 00                        cmpa    0,x          ; advance and check for EOLN
   06e8   26 fa                        bne     loc_6E2      ; loop until eoln found
                                                            ;
                                                            ; all in all, B contains the difference of line lengths:
                                                            ;  -sizeof(stored line)+sizeof(input buffer)
                                                            ; if negative: stored is longer  than new -> shrink program
                                                            ; if zero: stored is same size
                                                            ; if positive: stored is shorter than new -> grow program
   06ea   de b6                        ldx     LS_end       ; restore current lineno
                                                            ; is non-null: there is a line to add
   06ec   df 28                        stx     basic_lineno
                        
   06ee   de b8         loc_6EC:       ldx     BP_save      ; IL_temp = start of area to insert line
   06f0   df bc                        stx     IL_temp
   06f2   5d                           tstb                 ; check number of bytes
                                                            ; negative: shrink program
                                                            ; zero: nothing to move
                                                            ; positive: grow program
   06f3   27 55                        beq     il_samesize  ; same size, just copy
   06f5   2a 23                        bpl     il_growline  ; stored line is longer -> shrink
   06f7   96 2f                        ldaa    basicptr_save+1 ; BP_save = end_of_insert - bytes to shrink
   06f9   1b                           aba
   06fa   97 b9                        staa    BP_save+1
   06fc   96 2e                        ldaa    basicptr_save
   06fe   89 ff                        adca    #$FF
   0700   97 b8                        staa    BP_save      ; BP_save < basicptr_save < end_pgrm < top_of_stack (hopefully)
                        
   0702   de 2e         il_shrink:     ldx     basicptr_save ; copy from end of insert addr to BP_save addr
   0704   e6 00                        ldab    0,x
   0706   9c 24                        cpx     end_prgm     ; until end of program
   0708   27 3c                        beq     loc_744
   070a   9c 26                        cpx     top_of_stack ; or until top_of_stack
   070c   27 38                        beq     loc_744      ; leave, when done
   070e   08                           inx                  ; advance
   070f   df 2e                        stx     basicptr_save
   0711   de b8                        ldx     BP_save
   0713   e7 00                        stab    0,x          ; save the byte
   0715   08                           inx
   0716   df b8                        stx     BP_save
   0718   20 e8                        bra     il_shrink    ; loop until done
                        
   071a   db 25         il_growline:   addb    end_prgm+1   ; make space after end of program for B bytes
   071c   d7 2f                        stab    basicptr_save+1
   071e   86 00                        ldaa    #0
   0720   99 24                        adca    end_prgm
   0722   97 2e                        staa    basicptr_save ; basicptr_save = new end of program
   0724   d0 27                        subb    top_of_stack+1
   0726   92 26                        sbca    top_of_stack ; verify it's below top_of_RAM
   0728   25 06                        bcs     il_dogrow    ; ok, continue
   072a   7a 00 2b                     dec     il_pc+1      ; point back to IL instruction
   072d   7e 02 61                     jmp     error        ; overflow error
                        
   0730   de 2e         il_dogrow:     ldx     basicptr_save ; BP_save is new end of program
   0732   df b8                        stx     BP_save
                        
   0734   de 24         il_grow:       ldx     end_prgm     ; get byte from old end of program
   0736   a6 00                        ldaa    0,x
   0738   09                           dex                  ; advance back
   0739   df 24                        stx     end_prgm
   073b   de 2e                        ldx     basicptr_save ; store byte at new end of program
   073d   a7 00                        staa    0,x
   073f   09                           dex
   0740   df 2e                        stx     basicptr_save
   0742   9c bc                        cpx     IL_temp
   0744   26 ee                        bne     il_grow      ; loop until done
                        
   0746   de b8         loc_744:       ldx     BP_save      ; adjust new end of program
   0748   df 24                        stx     end_prgm
                        
   074a   de 28         il_samesize:   ldx     basic_lineno ; now there is space at position for the new line
                                                            ; check lineno:  is 0 if delete
   074c   27 19                        beq     il_done      ; nothing to copy (gap is already closed)
   074e   de bc                        ldx     IL_temp      ; start of area to insert into (the gap)
   0750   96 28                        ldaa    basic_lineno ; store the line number into this area
   0752   d6 29                        ldab    basic_lineno+1
   0754   a7 00                        staa    0,x
   0756   08                           inx
   0757   e7 00                        stab    0,x
                        
   0759   08            il_moveline:   inx
   075a   df bc                        stx     IL_temp      ; position of gap
   075c   bd 03 25                     jsr     fetch_basicchar ; get char from input buffer
   075f   de bc                        ldx     IL_temp      ; put it into gap
   0761   a7 00                        staa    0,x
   0763   81 0d                        cmpa    #$D          ; until EOLN
   0765   26 f2                        bne     il_moveline
                        
   0767   9e 26         il_done:       lds     top_of_stack ; finished with IL
                                                            ; reload stack pointer
   0769   7e 02 2f                     jmp     restart_il_nocr ; and re-enter BASIC loop
                        
                        ;------------------------------------------------------------------------------
                        ; test break routine for SmithBug
                        ; ESC or CTRL-C keys stop detect break
                        ;------------------------------------------------------------------------------
   076c   01            TSTBRK:			nop					
   076d   36            				psha				; save reg A
   076e   b6 80 00      				ldaa	ACIACS		; check for char in ACIA
   0771   47            				asra				; rx data present
   0772   24 0b         				bcc		ret_BV		; no rx data
   0774   b6 80 01      				ldaa	ACIADA
   0777   81 1b         				cmpa	#$1B		; is char ESC?
   0779   27 07         				beq		gotBRK
   077b   81 03         				cmpa	#$03		; is char CTRL-C?
   077d   27 03         				beq		gotBRK
   077f   32            ret_BV:			pula				; restore reg A
   0780   0c            				clc
   0781   39                            rts
   0782   32            gotBRK:			pula				; restore reg A
   0783   0d            				sec
   0784   39                            rts
                        
                        ;------------------------------------------------------------------------------
                        ; Input/Echo routine for Motorola MINIBUG
                        ;------------------------------------------------------------------------------
   0785   b6 80 00      minibug_inoutput: ldaa ACIACS        ; get ACIA status
   0788   47                           asra                 ; check bit: receiver buffer empty?
   0789   24 fa                        bcc     minibug_inoutput ; yes, wait for char
   078b   b6 80 01                     ldaa    ACIADA        ; get ACIA data
   078e   36                           psha                 ; save it for later
                        
   078f   b6 80 00      wait_tdre:     ldaa    ACIACS        ; get ACIA status
   0792   84 02                        anda    #2           ; check bit1: transmit buf empty?
   0794   27 f9                        beq     wait_tdre    ; no, wait until transmitted
   0796   32                           pula                 ; restore char
   0797   b7 80 01                     staa    ACIADA        ; echo data just entered
   079a   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; test break routine for MIKBUG
                        ;------------------------------------------------------------------------------
                        ; mikbug_chkbreak: ldaa    $8004      ; check bitbang input of PIA
                                       ; clc
                                       ; bmi     locret_7A0   ; if 1, exit: no input
                        
                        ; loc_793:       ldaa    $8004        ; is zero, wait until 1
                                       ; bpl     loc_793
                                       ; bsr     *+2          ; emit byte 0xFF twice
                                       ; ldaa    #$FF         ; emit 0xFF
                                       ; jsr     OUT_V
                                       ; sec
                        
                        ; locret_7A0:    rts
                        
                        ;******************************************************************************
                        ; The IL interpreter commented
                        ;******************************************************************************
   079b   24 3a a0      start_of_il:   fcb $24,':',$20+$80  ; PL    : print literal ":",XON
   079e   27                           fcb $27              ; GL    : get input line
   079f   10                           fcb $10              ; SB    : save BASIC pointer
   07a0   e1                           fcb $E1              ; BE  01: if not eoln, branch to il_test_insert
   07a1   59                           fcb $59              ; BR  19: branch to start_of_il
   07a2   c5            il_test_insert: fcb $C5             ; BN  05: if not number, branch to il_test_let
   07a3   2a                           fcb $2A              ; IL    : insert BASIC line
   07a4   56                           fcb $56              ; BR  16: branch to start_of_il
   07a5   10            il_run:        fcb $10              ; SB    : save BASIC pointer
   07a6   11                           fcb $11              ; RB    : restore BASIC pointer
   07a7   2c                           fcb $2C              ; XC    : execute
   07a8   8b 4c 45 d4   il_test_let:   fcb $8B,'L','E',$D4  ; BC  0B: if not "LET", branch to il_test_go
   07ac   a0                           fcb $A0              ; BV  00: if not variable, error
   07ad   80 bd                        fcb $80,'='+$80      ; BC  00: if not "=", error
   07af   30 bc         il_let:        fcb $30,$BC          ; JS 0BC: call il_expr
   07b1   e0                           fcb $E0              ; BE  00: if not eoln, error
   07b2   13                           fcb $13              ; SV    : store variable
   07b3   1d                           fcb $1D              ; NX    : next BASIC statement
   07b4   94 47 cf      il_test_go:    fcb $94,'G','O'+$80  ; BC  14: if not "GO", branch to il_test_10
   07b7   88 54 cf                     fcb $88,'T','O'+$80  ; BC  08: if not "TO", branch to il_test_sub
   07ba   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   07bc   e0                           fcb $E0              ; BE  00: if not eoln, error
   07bd   10                           fcb $10              ; SB    : save BASIC pointer
   07be   11                           fcb $11              ; RB    : restore BASIC pointer
   07bf   16                           fcb $16              ; GO    : GOTO
   07c0   80 53 55 c2   il_test_sub:   fcb $80,'S','U','B'+$80
                                                            ; BC  00: if not "SUB", error
   07c4   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   07c6   e0                           fcb $E0              ; BE  00: if not eoln, error
   07c7   14                           fcb $14              ; GS    : GOSUB save
   07c8   16                           fcb $16              ; GO    : GOTO
   07c9   90 50 d2      il_test_pr:    fcb $90,'P','R'+$80  ; BC  10: if not "PR", branch to il_jump1
   07cc   83 49 4e d4                  fcb $83,'I','N','T'+$80 
                                                            ; BC  03: if not "INT", branch to il_print
   07d0   e5            il_print:      fcb $E5              ; BE  05: if not eoln, branch to il_pr_test_dq
   07d1   71                           fcb $71              ; BR  31: branch to il_pr_must_eoln
   07d2   88 bb         il_pr_test_semi: fcb $88,';'+$80    ; BC  08: if not ";", branch to il_pr_test_com
   07d4   e1            il_pr_eoln:    fcb $E1              ; BE  01: if not eoln, branch to il_pr_test_dq
   07d5   1d                           fcb $1D              ; NX    : next BASIC statement
   07d6   8f a2         il_pr_test_dq: fcb $8F,'"'+$80      ; BC  0F: if not dblquote, branch to il_pr_expr
   07d8   21                           fcb $21              ; PQ    : print    BASIC string
   07d9   58                           fcb $58              ; BR  18: branch to il_test_semi
   07da   6f            il_jump1:      fcb $6F              ; BR  2F: branch to il_test_if
   07db   83 ac         il_pr_test_com: fcb $83,','+$80     ; BC  03: if not ",", branch to il_test_colon
   07dd   22                           fcb $22              ; PT    : print TAB
   07de   55                           fcb $55              ; BR  15: branch to il_pr_eoln
   07df   83 ba         il_test_colon: fcb $83,':'+$80      ; BC  03: if not ":", branch to il_pr_must_eoln
   07e1   24 93                        fcb $24,$13+$80      ; PR    : print literal XOFF
   07e3   e0            il_pr_must_eoln: fcb $E0            ; BE  00: if not eoln, error
   07e4   23                           fcb $23              ; NL    : new line
   07e5   1d                           fcb $1D              ; NX    : next statement
   07e6   30 bc         il_pr_expr:    fcb $30,$BC          ; JS 0BC: call il_expr
   07e8   20                           fcb $20              ; PN    : print number
   07e9   48                           fcb $48              ; BR  08: branch to il_pr_test_semi
   07ea   91 49 c6                     fcb $91,'I','F'+$80  ; BC  11: if not "IF", branch to il_test_input
   07ed   30 bc         il_test_if:    fcb $30,$BC          ; JS 0BC: call il_expr
   07ef   31 34                        fcb $31,$34          ; JS 134: call il_cmpop
   07f1   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   07f3   84 54 48 45                  fcb $84,'T','H','E','N'+$80
   07f7   ce            
                                                            ; BC  04: if not "THEN", branch to il_test_input
   07f8   1c                           fcb $1C              ; CP    : compare
   07f9   1d                           fcb $1D              ; NX    : next BASIC statement
   07fa   38 0d                        fcb $38,$D           ; J  00D: jump il_test_let
   07fc   9a 49 4e 50   il_test_input: fcb $9A,'I','N','P','U','T'+$80
   0800   55 d4         
                                                            ; BC  1A: if not "INPUT", branch to il_test_return
   0802   a0            il_in_more:    fcb $A0              ; BV  00: if not variable, error
   0803   10                           fcb $10              ; SB    : save BASIC pointer
   0804   e7                           fcb $E7              ; BE  07: if not eoln, branch to il_in_test_com
   0805   24 3f 20 91   il_in_query:   fcb $24,'?',' ',$11+$80
                                                            ; PR    : print literal "? ",XON
   0809   27                           fcb $27              ; GL    : get input line
   080a   e1                           fcb $E1              ; BE  01: if not eoln, branch to il_in_test_com
   080b   59                           fcb $59              ; BR  19: branch to il_in_query
   080c   81 ac         il_in_test_com: fcb $81,','+$80     ; BC  01: if not ",", branch to il_in_get
   080e   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   0810   13                           fcb $13              ; SV    : store variable
   0811   11                           fcb $11              ; RB    : restore BASIC pointer
   0812   82 ac                        fcb $82,','+$80      ; BC  02: if not ",", branch il_in_done
   0814   4d                           fcb $4D              ; BR  0D: branch to il_in_more
   0815   e0                           fcb $E0              ; BE  00: if not eoln, error
   0816   1d                           fcb $1D              ; NX    : next BASIC statement
   0817   89 52 45 54   il_test_return: fcb $89,'R','E','T','U','R','N'+$80
   081b   55 52 ce      
                                                            ; BC  09: if not "RETURN", branch to il_test_end
   081e   e0                           fcb $E0              ; BE  00: if not eoln, error
   081f   15                           fcb $15              ; RS    : restore saved line
   0820   1d                           fcb $1D              ; NX    : next BASIC statement
   0821   85 45 4e c4   il_test_end:   fcb $85,'E','N','D'+$80
                                                            ; BC  05: if not "END", branch to il_test_list
   0825   e0                           fcb $E0              ; BE  00: if not eoln, error
   0826   2d                           fcb $2D              ; WS    : stop
   0827   98 4c 49 53   il_test_list:  fcb $98,'L','I','S','T'+$80
   082b   d4            
                                                            ; BC  18: if not "LIST", branch to il_test_run
   082c   ec                           fcb $EC              ; BE  0C: if not eoln, branch to il_li_line
   082d   24 00 00 00   il_li_newline: fcb $24,0,0,0,0,$0A,0+$80
   0831   00 0a 80      
                                                            ; PR    : print literal NUL,NUL,NUL,NUL,LF,NUL
   0834   1f                           fcb $1F              ; LS    : list the program
   0835   24 93                        fcb $24,$13+$80      ; PR    : print literal XOFF
   0837   23                           fcb $23              ; NL    : newline
   0838   1d                           fcb $1D              ; NX    : next BASIC statement
   0839   30 bc         il_li_line:    fcb $30,$BC          ; JS 0BC: call il_expr
   083b   e1                           fcb $E1              ; if not eoln, branch to il_li2
   083c   50                           fcb $50              ; BR  10: branch to il_li_newline
   083d   80 ac                        fcb $80,','+$80      ; BC  00: if not ",", error
   083f   59                           fcb $59              ; BR  19: branch to il_li_line
   0840   85 52 55 ce   il_test_run:   fcb $85,'R','U','N'+$80
                                                            ; BC  05: if not "RUN", branch to il_test_clear
   0844   38 0a                        fcb $38,$0A          ; J  00A: branch to il_run
   0846   86 43 4c 45   il_test_clear: fcb $86,'C','L','E','A','R'+$80
   084a   41 d2         
                                                            ; BC  06: if not "CLEAR", branch to il_test_rem
   084c   2b                           fcb $2B              ; MT   : mark basic program space empty
   084d   84 52 45 cd   il_test_rem:   fcb $84,'R','E','M'+$80
                                                            ; BC  04: if not "REM, branch to il_assign
   0851   1d                           fcb $1D              ; NX    : next BASIC statement
   0852   a0                           fcb $A0              ; BV  00: if not variable, error
   0853   80 bd         il_assign:     fcb $80,'='+$80      ; BC  00: if not "=", error
   0855   38 14                        fcb $38,$14          ; J  014: branch to il_let
   0857   85 ad         il_expr:       fcb $85,'-'+$80      ; if not "-", branch to il_expr_plus
   0859   30 d3                        fcb $30,$D3          ; JS 0D3: call il_term
   085b   17                           fcb $17              ; NE    : negate
   085c   64                           fcb $64              ; BR  24: branch to il_expr1
   085d   81 ab         il_expr_plus:  fcb $81,'+'+$80      ; BC  01: if not "+", branch to il_expr0
   085f   30 d3         il_expr0:      fcb $30,$D3          ; JS 0D3: call il_term
   0861   85 ab         il_expr1:      fcb $85,'+'+$80      ; BC  05: if not "+", branch to il_expr2
   0863   30 d3                        fcb $30,$D3          ; JS 0D3: call il_term
   0865   18                           fcb $18              ; AD    : add
   0866   5a                           fcb $5A              ; BR  1A: branch to il_expr1
   0867   85 ad         il_expr2:      fcb $85,'-'+$80      ; BC  05: if not "-", branch to il_term
   0869   30 d3                        fcb $30,$D3          ; JS 0D3: call il_term
   086b   19                           fcb $19              ; SU    : subtract
   086c   54                           fcb $54              ; BR  14: branch to il_expr1
   086d   2f            il_expr3:      fcb $2F              ; RT    : return
   086e   30 e2         il_term:       fcb $30,$E2          ; JS 0E2: call il_fact
   0870   85 aa         il_term0:      fcb $85,'*'+$80      ; BC 05: if not "*", branch to il_term1
   0872   30 e2                        fcb $30,$E2          ; JS 0E2: call il_factor
   0874   1a                           fcb $1A              ; MP    : multiply
   0875   5a                           fcb $5A              ; BR  1A: branch to il_term0
   0876   85 af         il_term1:      fcb $85,'/'+$80      ; if not "/", branch to il_term2
   0878   30 e2                        fcb $30,$E2          ; JS 0E2: call il_factor
   087a   1b                           fcb $1B              ; DV    : divide
   087b   54                           fcb $54              ; BR  14: branch to il_term0
   087c   2f            il_term2:      fcb $2F              ; RT    : return
   087d   98 52 4e c4   il_factor:     fcb $98,'R','N','D'+$80
                                                            ; BC  18: if not RND, branch to il_factor1
   0881   0a 80 80                     fcb  $A,$80,$80      ; LN    : push literal 0x8080
   0884   12                           fcb $12              ; FV    : fetch variable rnd_seed
   0885   0a 09 29                     fcb  $A,$09,$29      ; LN    : push literal 0x0929
   0888   1a                           fcb $1A              ; MP    : multiply
   0889   0a 1a 85                     fcb  $A,$1A,$85      ; LN    : push literal 0x1A85
   088c   18                           fcb $18              ; AD    : add
   088d   13                           fcb $13              ; SV    : store variable rnd_seed
   088e   09 80                        fcb   9,$80          ; LB    : push literal byte 0x80
   0890   12                           fcb $12              ; FV    : fetch variable rnd_seed
   0891   01                           fcb   1              ; SX  01: stack    exchange
   0892   0b                           fcb  $B              ; DS    : duplicate stack top
   0893   31 30                        fcb $31,$30          ; JS 130: call il_rn_paren
   0895   61                           fcb $61              ; BR  21: branch to il_factor2
   0896   72            il_factor1:    fcb $72              ; BR  32: branch to il_usr
   0897   0b            il_factor2:    fcb  $B              ; DS    : duplicate stack top
   0898   04                           fcb   4              ; SX  04: stack    exchange
   0899   02                           fcb   2              ; SX  02: stack    exchange
   089a   03                           fcb   3              ; SX  03: stack    exchange
   089b   05                           fcb   5              ; SX  05: stack    exchange
   089c   03                           fcb   3              ; SX  03: stack    exchange
   089d   1b                           fcb $1B              ; DV    : divide
   089e   1a                           fcb $1A              ; MP    : multiply
   089f   19                           fcb $19              ; SU    : subtract
   08a0   0b                           fcb  $B              ; DS    : duplicate stack top
   08a1   09 06                        fcb   9,$06          ; LB    : push literal byte 0x06
   08a3   0a 00 00                     fcb  $A,$00,$00      ; LN    : push literal number 0x0000
   08a6   1c                           fcb $1C              ; CP    : compare
   08a7   17                           fcb $17              ; NE    : negate
   08a8   2f                           fcb $2F              ; RT    : return
   08a9   8f 55 53 d2   il_usr:        fcb $8F,'U','S','R'+$80
                                                            ; BC  0F: if not "USR", branch to il_factor3
   08ad   80                           fcb $80              ; BC  00: if not "(", error
   08ae   a8                           fcb $A8              ; if not variable, branch to il_usr1
   08af   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   08b1   31 2a                        fcb $31,$2A          ; JS 12A: call il_us_test_com
   08b3   31 2a                        fcb $31,$2A          ; JS 12A: call il_us_test_com
   08b5   80 a9                        fcb $80,')'+$80      ; BC  00: if not ")", error
   08b7   2e            il_usr1:       fcb $2E              ; US    : machine language call
   08b8   2f                           fcb $2F              ; RT    : return
   08b9   a2            il_factor3:    fcb $A2              ; BV  02: if not variable, branch to il_factor4
   08ba   12                           fcb $12              ; FV    : fetch    variable
   08bb   2f                           fcb $2F              ; RT    : return
   08bc   c1            il_factor4:    fcb $C1              ; BN  01: if not number, branch    to il_lparen
   08bd   2f                           fcb $2F              ; RT    : return
   08be   80 a8                        fcb $80,'('+$80      ; BC  00: if not "(", error
   08c0   30 bc         il_factor5:    fcb $30,$BC          ; JS 0BC: call il_expr
   08c2   80 a9                        fcb $80,')'+$80      ; BC  00: if not ")", error
   08c4   2f                           fcb $2F              ; RT    : return
   08c5   83 ac         il_us_test_com: fcb $83,','+$80     ; BC  03: if not ",", branch to il_us_dup
   08c7   38 bc                        fcb $38,$BC          ; J  0BC: branch to il_expr
   08c9   0b            il_us_dup:     fcb  $B              ; DS    : duplicate stack top
   08ca   2f                           fcb $2F              ; RT    : return
   08cb   80 a8         il_rn_paren:   fcb $80,'('+$80      ; BC  00: if not "(", error
   08cd   52                           fcb $52              ; BR  12: branch to il_factor5
   08ce   2f                           fcb $2F              ; RT    : return
   08cf   84 bd         il_cmpop:      fcb $84,'='+$80      ; if not "=", branch to il_cmpop1
   08d1   09 02                        fcb   9,$02          ; LB    : push literal byte 0x02
   08d3   2f                           fcb $2F              ; RT    ; return
   08d4   8e bc         il_cmpop1:     fcb $8E,'<'+$80      ; BR  0E: if not "<", branch to il_cmpop4
   08d6   84 bd                        fcb $84,'='+$80      ; BR  04: if not "=", branch to il_cmpop2
   08d8   09 93                        fcb   9,$93          ; LB    : push literal byte 0x93
   08da   2f                           fcb $2F              ; RT    : return
   08db   84 be         il_cmpop2:     fcb $84,'>'+$80      ; BR  04: if not ">", branch to il_cmpop3
   08dd   09 05                        fcb   9,$05          ; LB    : push literal byte 0x05
   08df   2f                           fcb $2F              ; RT    : return
   08e0   09 91         il_cmpop3:     fcb   9,$91          ; LB    : push literal byte 0x91
   08e2   2f                           fcb $2F              ; RT    : return
   08e3   80 be         il_cmpop4:     fcb $80,'>'+$80      ; BR  00: if not ">", error
   08e5   84 bd                        fcb $84,'='+$80      ; BR  04: if not "=", branch to il_cmpop5
   08e7   09 06                        fcb   9,$06          ; LB    : push literal byte 0x06
   08e9   2f                           fcb $2F              ; RT    : return
   08ea   84 bc         il_cmpop5:     fcb $84,'<'+$80      ; BR  04: if not "<", branch to il_cmpop6
   08ec   09 95                        fcb   9,$95          ; LB    : push literal byte 0x95
   08ee   2f                           fcb $2F              ; RT    : return
   08ef   09 04         il_cmpop6:     fcb   9,$04          ; LB    : push literal byte 0x04
   08f1   2f                           fcb $2F              ; RT   :return
   08f2   00                           fcb 0
   08f3   00                           fcb 0
                        
                        ; DGG - INPUT ROUTINE ALSO IN SMITHBUG BUT DUPLICATED HERE FOR CONVENIENCE
   08f4   b6 80 00      INEEE:	LDAA	ACIACS
   08f7   47            		ASRA
   08f8   24 fa         		BCC		INEEE	;RECEIVE NOT READY
   08fa   b6 80 01      		LDAA	ACIADA	;INPUT CHARACTER
   08fd   84 7f         		ANDA	#$7F	;RESET PARITY BIT
   08ff   81 7f         		CMPA	#$7F
   0901   27 f1         		BEQ		INEEE	;IF RUBOUT, GET NEXT CHAR
   0903   2f 01         		BLE 	OUTEEE
   0905   39            		rts
                        	
                        ; DGG - OUTPUT ROUTINE ALSO IN SMITHBUG BUT DUPLICATED HERE FOR CONVENIENCE
   0906   36            OUTEEE: PSH	A
   0907   b6 80 00      OUTEEE1 LDA A	ACIACS
   090a   47            		ASR A
   090b   47            		ASR A
   090c   24 f9         		BCC		OUTEEE1
   090e   32            		PUL A
   090f   b7 80 01      		STA A	ACIADA
   0912   39            		RTS
                        ;------------------------------------------------------------------------------
                        ; not called: reference code for break check for MIKBUG/MINIBUG monitors
                        ;------------------------------------------------------------------------------
                                       ; jmp     minibug_chkbreak
                                       ; jmp     mikbug_chkbreak
                        
   0913                 		       end
8000  ACIACS        8001  ACIADA        00b8  BP_save       010f  BSC       
010c  BV            0200  COLD_S        0100  CV            03d4  IL_AD     
029d  IL_BBR        02f3  IL_BC         0310  IL_BE         0340  IL_BN     
0317  IL_BV         0428  IL_CP         0189  IL_DS         0370  IL_DV     
02a0  IL_FBR        0405  IL_FV         065f  IL_GL         0493  IL_GO     
04d3  IL_GS         06b3  IL_IL         01d7  IL_LB         01db  IL_LN     
05dc  IL_LS         03ea  IL_MP         0217  IL_MT         03c7  IL_NE     
062d  IL_NL         01fc  IL_NO         044e  IL_NX         05b2  IL_PC     
054a  IL_PN         05bf  IL_PQ         05c7  IL_PT         04b5  IL_RB     
049e  IL_RS         04ab  IL_RT         04b0  IL_SB         01a6  IL_SP     
03d2  IL_SU         0415  IL_SV         01b9  IL_US         0483  IL_XQ     
01fe  IL_baseaddr    00bc  IL_temp       08f4  INEEE         0106  IN_V      
0110  LSC           00b6  LS_end        0906  OUTEEE        0907  OUTEEE1   
0109  OUT_V         0111  PCC           0113  SSS           0112  TMC       
076c  TSTBRK        022a  WARM_S        0103  WV            00ba  X_save    
0028  basic_lineno    002c  basic_ptr     002e  basicptr_save    0303  bc_lastchar
02f7  bc_loop       030a  bc_nomatch    00bf  column_cnt    0445  cp_is_eq  
0443  cp_is_gt      0447  cp_is_lt      0631  crlf          02ef  displ_error
0467  do_break      048f  do_runmode    065a  do_xoff       0655  do_xon    
0399  dv_loop       03b3  dv_shift      03b0  dv_smaller    059d  emit_char 
064f  emit_char_at_0    058f  emit_digit    0598  emit_digit1    0586  emit_digits
0648  emit_nul_padding    0547  emit_number    0215  endOfRam      0024  end_prgm  
0022  end_ram       0298  err_at        0261  error         028f  error_no_lineno
024b  exec_il_opcode    03e5  expr_check_4bytes    03e7  expr_check_nbytes    01a9  expr_pop_byte
0196  expr_push_a    0194  expr_push_byte    018d  expr_push_word    03de  expr_save_pop
0030  expr_stack    00c1  expr_stack_low    00c3  expr_stack_top    00c2  expr_stack_x
0325  fetch_basicchar    01f5  fetch_il_op    0205  find_end_ram    053d  find_eoln 
0544  find_exit     051f  find_line     052a  find_line1    032f  get_nchar 
0501  get_payload    0694  gl_chkend     068d  gl_ctrlx      06a2  gl_dobackspace
0669  gl_loop       069e  gl_savechar    0498  go_error      045b  go_found_line
0782  gotBRK        0511  gp_loop       02aa  handle_30_ff    02d1  handle_40_ff
01e4  handle_il_SX    0853  il_assign     08cf  il_cmpop      08d4  il_cmpop1 
08db  il_cmpop2     08e0  il_cmpop3     08e3  il_cmpop4     08ea  il_cmpop5 
08ef  il_cmpop6     0730  il_dogrow     0767  il_done       0857  il_expr   
085f  il_expr0      0861  il_expr1      0867  il_expr2      086d  il_expr3  
085d  il_expr_plus    087d  il_factor     0896  il_factor1    0897  il_factor2
08b9  il_factor3    08bc  il_factor4    08c0  il_factor5    06cc  il_findeoln
02a5  il_goto       0734  il_grow       071a  il_growline    0802  il_in_more
0805  il_in_query    080c  il_in_test_com    07da  il_jump1      011b  il_jumptable
07af  il_let        0839  il_li_line    082d  il_li_newline    06d2  il_linenotfound
0240  il_mainloop    0759  il_moveline    002a  il_pc         00c4  il_pc_save
07d4  il_pr_eoln    07e6  il_pr_expr    07e3  il_pr_must_eoln    07db  il_pr_test_com
07d6  il_pr_test_dq    07d2  il_pr_test_semi    07d0  il_print      08cb  il_rn_paren
023e  il_rs_return    0246  il_rs_target    07a5  il_run        074a  il_samesize
0702  il_shrink     086e  il_term       0870  il_term0      0876  il_term1  
087c  il_term2      0846  il_test_clear    07df  il_test_colon    0821  il_test_end
07b4  il_test_go    07ed  il_test_if    07fc  il_test_input    07a2  il_test_insert
07a8  il_test_let    0827  il_test_list    07c9  il_test_pr    084d  il_test_rem
0817  il_test_return    0840  il_test_run    07c0  il_test_sub    08c9  il_us_dup 
08c5  il_us_test_com    08a9  il_usr        08b7  il_usr1       046c  j1_error  
04fe  j2_error      030e  j_FBR         0425  j_IL_SP       0652  j_emitchar
01a3  j_error       03e2  j_expr_pop_byte    058e  last_digit    00be  lead_zero 
038e  loc_389       046f  loc_46A       04b8  loc_4B3       04d0  loc_4CB   
0557  loc_552       05ac  loc_5A7       063b  loc_636       0644  loc_63E   
065b  loc_655       06e4  loc_6E2       06ee  loc_6EC       0746  loc_744   
033f  locret_33A    03d1  locret_3CC    0466  locret_461    051e  locret_519
05af  locret_5AA    0627  locret_622    0565  loop_10000s    056d  loop_1000s
0575  loop_100s     057d  loop_10s      0349  loop_bn       05b9  loop_pq   
0628  ls_exit       0614  ls_getlineno    0604  ls_loop       05ec  ls_nostart
0621  ls_to_linestart    0785  minibug_inoutput    03f2  mp_loop       03fe  mp_notadd 
03cf  ne_nocarry    03c9  negate        02e7  not_bbr       0452  nx_loop   
05b0  pc_loop       0114  peek          0118  poke          01ab  pop_byte  
05d3  pt_loop       05d0  pt_print_spc    04dc  push_payload    022c  restart_il
022f  restart_il_nocr    077f  ret_BV        0080  rnd_seed      00c0  run_mode  
0476  save_lineno    079b  start_of_il    0020  start_prgm    0177  sub_177   
0180  sub_180       04c6  swap_bp       052e  test_line     0026  top_of_stack
01cd  us_copyargs    01c0  us_do         0082  var_tbl       078f  wait_tdre 

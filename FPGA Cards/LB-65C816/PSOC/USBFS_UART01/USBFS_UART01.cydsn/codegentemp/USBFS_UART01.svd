<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_0.xsd">
  <name>CY8C4247AZI_L433</name>
  <version>0.1</version>
  <description>PSoC 4200L</description>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <peripherals>
    <peripheral>
      <name>DMAC</name>
      <description>DMAC Registers</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DMAC_CTL</name>
          <description>DMA controller control register</description>
          <addressOffset>0x40101000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Global DMAC enable</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>DMA controller is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>DMA controller is enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS</name>
          <description>DMA controller status register</description>
          <addressOffset>0x40101010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Specifies the index of the currently active data transfer. This value increases from '0' to the DATA_NR field specified of the currently active descriptor control word.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_ADDR</name>
              <description>Specifies the channel number of the currently active channel. For example, if channel 7 is active, DMAC_STATUS.ACTIVE is '1' and STATUS.CH_ADDR is '7'.</description>
              <lsb>16</lsb>
              <msb>20</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the data transfer engine.</description>
              <lsb>24</lsb>
              <msb>26</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>Idle state when the DMA is not active.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_DESCR</name>
                  <description>The DMA is loading the descriptor to the DMA transfer engine.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_SRC</name>
                  <description>The DMA is getting the value from the source location.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_DST</name>
                  <description>The DMA is storing the value at the destination location.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_DESCR</name>
                  <description>The DMA is updating the descriptors after completion of transfer.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_TRIG_DEACT</name>
                  <description>The DMA is waiting for the level sensitive trigger to deactivate.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STORE_ERROR</name>
                  <description>There was an error during the transaction and the DMA is writing the error code to the channel status register.</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Specifies the priority of the currently active channel.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Specifies whether the PING descriptor ('0') or PONG descriptor ('1') of the channel is currently in use.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Specifies if there is a currently active (pending) channel in the data transfer engine.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>No currently active channel.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>Currently active channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_SRC_ADDR</name>
          <description>Source address currently being used by the DMA controller</description>
          <addressOffset>0x40101014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The source address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_DST_ADDR</name>
          <description>Destination address currently being used by the DMA controller</description>
          <addressOffset>0x40101018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>The destination address currently being used by the DMA transfer engine. This field is provided for debug purposes. Note while reading the DMAC_STATUS, DMAC_STATUS_SRC_ADDR and DMAC_STATUS_DST_ADDR registers, the transfer engine may have advanced after one or more of these reads. Meaning the register values may not be related to each other.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_STATUS_CH_ACT</name>
          <description>Channel activation status</description>
          <addressOffset>0x4010101C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Channel activation status. Bit i is associated to channel i. Software reads this field to get information on all actively pending channels (either in pending or in the data transfer engine).</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL0</name>
          <description>DMA channel 0 control register</description>
          <addressOffset>0x40101080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL1</name>
          <description>DMA channel 1 control register</description>
          <addressOffset>0x40101084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL2</name>
          <description>DMA channel 2 control register</description>
          <addressOffset>0x40101088</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL3</name>
          <description>DMA channel 3 control register</description>
          <addressOffset>0x4010108C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL4</name>
          <description>DMA channel 4 control register</description>
          <addressOffset>0x40101090</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL5</name>
          <description>DMA channel 5 control register</description>
          <addressOffset>0x40101094</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL6</name>
          <description>DMA channel 6 control register</description>
          <addressOffset>0x40101098</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL7</name>
          <description>DMA channel 7 control register</description>
          <addressOffset>0x4010109C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL8</name>
          <description>DMA channel 8 control register</description>
          <addressOffset>0x401010A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL9</name>
          <description>DMA channel 9 control register</description>
          <addressOffset>0x401010A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL10</name>
          <description>DMA channel 10 control register</description>
          <addressOffset>0x401010A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL11</name>
          <description>DMA channel 11 control register</description>
          <addressOffset>0x401010AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL12</name>
          <description>DMA channel 12 control register</description>
          <addressOffset>0x401010B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL13</name>
          <description>DMA channel 13 control register</description>
          <addressOffset>0x401010B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL14</name>
          <description>DMA channel 14 control register</description>
          <addressOffset>0x401010B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL15</name>
          <description>DMA channel 15 control register</description>
          <addressOffset>0x401010BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL16</name>
          <description>DMA channel 16 control register</description>
          <addressOffset>0x401010C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL17</name>
          <description>DMA channel 17 control register</description>
          <addressOffset>0x401010C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL18</name>
          <description>DMA channel 18 control register</description>
          <addressOffset>0x401010C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL19</name>
          <description>DMA channel 19 control register</description>
          <addressOffset>0x401010CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL20</name>
          <description>DMA channel 20 control register</description>
          <addressOffset>0x401010D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL21</name>
          <description>DMA channel 21 control register</description>
          <addressOffset>0x401010D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL22</name>
          <description>DMA channel 22 control register</description>
          <addressOffset>0x401010D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL23</name>
          <description>DMA channel 23 control register</description>
          <addressOffset>0x401010DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL24</name>
          <description>DMA channel 24 control register</description>
          <addressOffset>0x401010E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL25</name>
          <description>DMA channel 25 control register</description>
          <addressOffset>0x401010E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL26</name>
          <description>DMA channel 26 control register</description>
          <addressOffset>0x401010E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL27</name>
          <description>DMA channel 27 control register</description>
          <addressOffset>0x401010EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL28</name>
          <description>DMA channel 28 control register</description>
          <addressOffset>0x401010F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL29</name>
          <description>DMA channel 29 control register</description>
          <addressOffset>0x401010F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL30</name>
          <description>DMA channel 30 control register</description>
          <addressOffset>0x401010F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CH_CTL31</name>
          <description>DMA channel 31 control register</description>
          <addressOffset>0x401010FC</addressOffset>
          <size>31</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>Channel enable control.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Channel is currently disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Channel is currently enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Identifies the descriptor structure that is currently in use by the DMA controller.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DESCR0</name>
                  <description>Descriptor 0 (PING) is currently in use.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DESCR1</name>
                  <description>Descriptor 1 (PONG) is currently in use.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRIO</name>
              <description>Channel priority. Priority can be 0,1,2 or 3. 0 is the highest.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x401017F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x401017F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x401017F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Mask for corresponding field in INTR register.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x401017FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Bitwise AND between the interrupt reguest (INTR) and mask (INTR_MASK) registers.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 0</description>
          <addressOffset>0x40101800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 0</description>
          <addressOffset>0x40101804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_CTL</name>
          <description>Descriptor 0 control register for channel 0</description>
          <addressOffset>0x40101808</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 0</description>
          <addressOffset>0x4010180C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 0</description>
          <addressOffset>0x40101810</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 0</description>
          <addressOffset>0x40101814</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 0</description>
          <addressOffset>0x40101818</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR0_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 0</description>
          <addressOffset>0x4010181C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 1</description>
          <addressOffset>0x40101820</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 1</description>
          <addressOffset>0x40101824</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_CTL</name>
          <description>Descriptor 0 control register for channel 1</description>
          <addressOffset>0x40101828</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 1</description>
          <addressOffset>0x4010182C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 1</description>
          <addressOffset>0x40101830</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 1</description>
          <addressOffset>0x40101834</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 1</description>
          <addressOffset>0x40101838</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR1_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 1</description>
          <addressOffset>0x4010183C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 2</description>
          <addressOffset>0x40101840</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 2</description>
          <addressOffset>0x40101844</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_CTL</name>
          <description>Descriptor 0 control register for channel 2</description>
          <addressOffset>0x40101848</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 2</description>
          <addressOffset>0x4010184C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 2</description>
          <addressOffset>0x40101850</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 2</description>
          <addressOffset>0x40101854</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 2</description>
          <addressOffset>0x40101858</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR2_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 2</description>
          <addressOffset>0x4010185C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 3</description>
          <addressOffset>0x40101860</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 3</description>
          <addressOffset>0x40101864</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_CTL</name>
          <description>Descriptor 0 control register for channel 3</description>
          <addressOffset>0x40101868</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 3</description>
          <addressOffset>0x4010186C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 3</description>
          <addressOffset>0x40101870</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 3</description>
          <addressOffset>0x40101874</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 3</description>
          <addressOffset>0x40101878</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR3_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 3</description>
          <addressOffset>0x4010187C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 4</description>
          <addressOffset>0x40101880</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 4</description>
          <addressOffset>0x40101884</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_CTL</name>
          <description>Descriptor 0 control register for channel 4</description>
          <addressOffset>0x40101888</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 4</description>
          <addressOffset>0x4010188C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 4</description>
          <addressOffset>0x40101890</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 4</description>
          <addressOffset>0x40101894</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 4</description>
          <addressOffset>0x40101898</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR4_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 4</description>
          <addressOffset>0x4010189C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 5</description>
          <addressOffset>0x401018A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 5</description>
          <addressOffset>0x401018A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_CTL</name>
          <description>Descriptor 0 control register for channel 5</description>
          <addressOffset>0x401018A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 5</description>
          <addressOffset>0x401018AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 5</description>
          <addressOffset>0x401018B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 5</description>
          <addressOffset>0x401018B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 5</description>
          <addressOffset>0x401018B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR5_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 5</description>
          <addressOffset>0x401018BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 6</description>
          <addressOffset>0x401018C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 6</description>
          <addressOffset>0x401018C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_CTL</name>
          <description>Descriptor 0 control register for channel 6</description>
          <addressOffset>0x401018C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 6</description>
          <addressOffset>0x401018CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 6</description>
          <addressOffset>0x401018D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 6</description>
          <addressOffset>0x401018D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 6</description>
          <addressOffset>0x401018D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR6_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 6</description>
          <addressOffset>0x401018DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 7</description>
          <addressOffset>0x401018E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 7</description>
          <addressOffset>0x401018E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_CTL</name>
          <description>Descriptor 0 control register for channel 7</description>
          <addressOffset>0x401018E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 7</description>
          <addressOffset>0x401018EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 7</description>
          <addressOffset>0x401018F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 7</description>
          <addressOffset>0x401018F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 7</description>
          <addressOffset>0x401018F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR7_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 7</description>
          <addressOffset>0x401018FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 8</description>
          <addressOffset>0x40101900</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 8</description>
          <addressOffset>0x40101904</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PING_CTL</name>
          <description>Descriptor 0 control register for channel 8</description>
          <addressOffset>0x40101908</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 8</description>
          <addressOffset>0x4010190C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 8</description>
          <addressOffset>0x40101910</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 8</description>
          <addressOffset>0x40101914</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 8</description>
          <addressOffset>0x40101918</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR8_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 8</description>
          <addressOffset>0x4010191C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 9</description>
          <addressOffset>0x40101920</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 9</description>
          <addressOffset>0x40101924</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PING_CTL</name>
          <description>Descriptor 0 control register for channel 9</description>
          <addressOffset>0x40101928</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 9</description>
          <addressOffset>0x4010192C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 9</description>
          <addressOffset>0x40101930</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 9</description>
          <addressOffset>0x40101934</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 9</description>
          <addressOffset>0x40101938</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR9_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 9</description>
          <addressOffset>0x4010193C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 10</description>
          <addressOffset>0x40101940</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 10</description>
          <addressOffset>0x40101944</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PING_CTL</name>
          <description>Descriptor 0 control register for channel 10</description>
          <addressOffset>0x40101948</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 10</description>
          <addressOffset>0x4010194C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 10</description>
          <addressOffset>0x40101950</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 10</description>
          <addressOffset>0x40101954</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 10</description>
          <addressOffset>0x40101958</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR10_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 10</description>
          <addressOffset>0x4010195C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 11</description>
          <addressOffset>0x40101960</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 11</description>
          <addressOffset>0x40101964</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PING_CTL</name>
          <description>Descriptor 0 control register for channel 11</description>
          <addressOffset>0x40101968</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 11</description>
          <addressOffset>0x4010196C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 11</description>
          <addressOffset>0x40101970</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 11</description>
          <addressOffset>0x40101974</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 11</description>
          <addressOffset>0x40101978</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR11_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 11</description>
          <addressOffset>0x4010197C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 12</description>
          <addressOffset>0x40101980</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 12</description>
          <addressOffset>0x40101984</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PING_CTL</name>
          <description>Descriptor 0 control register for channel 12</description>
          <addressOffset>0x40101988</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 12</description>
          <addressOffset>0x4010198C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 12</description>
          <addressOffset>0x40101990</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 12</description>
          <addressOffset>0x40101994</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 12</description>
          <addressOffset>0x40101998</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR12_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 12</description>
          <addressOffset>0x4010199C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 13</description>
          <addressOffset>0x401019A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 13</description>
          <addressOffset>0x401019A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PING_CTL</name>
          <description>Descriptor 0 control register for channel 13</description>
          <addressOffset>0x401019A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 13</description>
          <addressOffset>0x401019AC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 13</description>
          <addressOffset>0x401019B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 13</description>
          <addressOffset>0x401019B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 13</description>
          <addressOffset>0x401019B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR13_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 13</description>
          <addressOffset>0x401019BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 14</description>
          <addressOffset>0x401019C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 14</description>
          <addressOffset>0x401019C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PING_CTL</name>
          <description>Descriptor 0 control register for channel 14</description>
          <addressOffset>0x401019C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 14</description>
          <addressOffset>0x401019CC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 14</description>
          <addressOffset>0x401019D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 14</description>
          <addressOffset>0x401019D4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 14</description>
          <addressOffset>0x401019D8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR14_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 14</description>
          <addressOffset>0x401019DC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 15</description>
          <addressOffset>0x401019E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 15</description>
          <addressOffset>0x401019E4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PING_CTL</name>
          <description>Descriptor 0 control register for channel 15</description>
          <addressOffset>0x401019E8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 15</description>
          <addressOffset>0x401019EC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 15</description>
          <addressOffset>0x401019F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 15</description>
          <addressOffset>0x401019F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 15</description>
          <addressOffset>0x401019F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR15_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 15</description>
          <addressOffset>0x401019FC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 16</description>
          <addressOffset>0x40101A00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 16</description>
          <addressOffset>0x40101A04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PING_CTL</name>
          <description>Descriptor 0 control register for channel 16</description>
          <addressOffset>0x40101A08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 16</description>
          <addressOffset>0x40101A0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 16</description>
          <addressOffset>0x40101A10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 16</description>
          <addressOffset>0x40101A14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 16</description>
          <addressOffset>0x40101A18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR16_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 16</description>
          <addressOffset>0x40101A1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 17</description>
          <addressOffset>0x40101A20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 17</description>
          <addressOffset>0x40101A24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PING_CTL</name>
          <description>Descriptor 0 control register for channel 17</description>
          <addressOffset>0x40101A28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 17</description>
          <addressOffset>0x40101A2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 17</description>
          <addressOffset>0x40101A30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 17</description>
          <addressOffset>0x40101A34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 17</description>
          <addressOffset>0x40101A38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR17_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 17</description>
          <addressOffset>0x40101A3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 18</description>
          <addressOffset>0x40101A40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 18</description>
          <addressOffset>0x40101A44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PING_CTL</name>
          <description>Descriptor 0 control register for channel 18</description>
          <addressOffset>0x40101A48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 18</description>
          <addressOffset>0x40101A4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 18</description>
          <addressOffset>0x40101A50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 18</description>
          <addressOffset>0x40101A54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 18</description>
          <addressOffset>0x40101A58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR18_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 18</description>
          <addressOffset>0x40101A5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 19</description>
          <addressOffset>0x40101A60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 19</description>
          <addressOffset>0x40101A64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PING_CTL</name>
          <description>Descriptor 0 control register for channel 19</description>
          <addressOffset>0x40101A68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 19</description>
          <addressOffset>0x40101A6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 19</description>
          <addressOffset>0x40101A70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 19</description>
          <addressOffset>0x40101A74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 19</description>
          <addressOffset>0x40101A78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR19_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 19</description>
          <addressOffset>0x40101A7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 20</description>
          <addressOffset>0x40101A80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 20</description>
          <addressOffset>0x40101A84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PING_CTL</name>
          <description>Descriptor 0 control register for channel 20</description>
          <addressOffset>0x40101A88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 20</description>
          <addressOffset>0x40101A8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 20</description>
          <addressOffset>0x40101A90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 20</description>
          <addressOffset>0x40101A94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 20</description>
          <addressOffset>0x40101A98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR20_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 20</description>
          <addressOffset>0x40101A9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 21</description>
          <addressOffset>0x40101AA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 21</description>
          <addressOffset>0x40101AA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PING_CTL</name>
          <description>Descriptor 0 control register for channel 21</description>
          <addressOffset>0x40101AA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 21</description>
          <addressOffset>0x40101AAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 21</description>
          <addressOffset>0x40101AB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 21</description>
          <addressOffset>0x40101AB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 21</description>
          <addressOffset>0x40101AB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR21_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 21</description>
          <addressOffset>0x40101ABC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 22</description>
          <addressOffset>0x40101AC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 22</description>
          <addressOffset>0x40101AC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PING_CTL</name>
          <description>Descriptor 0 control register for channel 22</description>
          <addressOffset>0x40101AC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 22</description>
          <addressOffset>0x40101ACC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 22</description>
          <addressOffset>0x40101AD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 22</description>
          <addressOffset>0x40101AD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 22</description>
          <addressOffset>0x40101AD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR22_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 22</description>
          <addressOffset>0x40101ADC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 23</description>
          <addressOffset>0x40101AE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 23</description>
          <addressOffset>0x40101AE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PING_CTL</name>
          <description>Descriptor 0 control register for channel 23</description>
          <addressOffset>0x40101AE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 23</description>
          <addressOffset>0x40101AEC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 23</description>
          <addressOffset>0x40101AF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 23</description>
          <addressOffset>0x40101AF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 23</description>
          <addressOffset>0x40101AF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR23_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 23</description>
          <addressOffset>0x40101AFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 24</description>
          <addressOffset>0x40101B00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 24</description>
          <addressOffset>0x40101B04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PING_CTL</name>
          <description>Descriptor 0 control register for channel 24</description>
          <addressOffset>0x40101B08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 24</description>
          <addressOffset>0x40101B0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 24</description>
          <addressOffset>0x40101B10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 24</description>
          <addressOffset>0x40101B14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 24</description>
          <addressOffset>0x40101B18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR24_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 24</description>
          <addressOffset>0x40101B1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 25</description>
          <addressOffset>0x40101B20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 25</description>
          <addressOffset>0x40101B24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PING_CTL</name>
          <description>Descriptor 0 control register for channel 25</description>
          <addressOffset>0x40101B28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 25</description>
          <addressOffset>0x40101B2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 25</description>
          <addressOffset>0x40101B30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 25</description>
          <addressOffset>0x40101B34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 25</description>
          <addressOffset>0x40101B38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR25_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 25</description>
          <addressOffset>0x40101B3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 26</description>
          <addressOffset>0x40101B40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 26</description>
          <addressOffset>0x40101B44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PING_CTL</name>
          <description>Descriptor 0 control register for channel 26</description>
          <addressOffset>0x40101B48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 26</description>
          <addressOffset>0x40101B4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 26</description>
          <addressOffset>0x40101B50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 26</description>
          <addressOffset>0x40101B54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 26</description>
          <addressOffset>0x40101B58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR26_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 26</description>
          <addressOffset>0x40101B5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 27</description>
          <addressOffset>0x40101B60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 27</description>
          <addressOffset>0x40101B64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PING_CTL</name>
          <description>Descriptor 0 control register for channel 27</description>
          <addressOffset>0x40101B68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 27</description>
          <addressOffset>0x40101B6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 27</description>
          <addressOffset>0x40101B70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 27</description>
          <addressOffset>0x40101B74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 27</description>
          <addressOffset>0x40101B78</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR27_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 27</description>
          <addressOffset>0x40101B7C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 28</description>
          <addressOffset>0x40101B80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 28</description>
          <addressOffset>0x40101B84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PING_CTL</name>
          <description>Descriptor 0 control register for channel 28</description>
          <addressOffset>0x40101B88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 28</description>
          <addressOffset>0x40101B8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 28</description>
          <addressOffset>0x40101B90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 28</description>
          <addressOffset>0x40101B94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 28</description>
          <addressOffset>0x40101B98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR28_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 28</description>
          <addressOffset>0x40101B9C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 29</description>
          <addressOffset>0x40101BA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 29</description>
          <addressOffset>0x40101BA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PING_CTL</name>
          <description>Descriptor 0 control register for channel 29</description>
          <addressOffset>0x40101BA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 29</description>
          <addressOffset>0x40101BAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 29</description>
          <addressOffset>0x40101BB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 29</description>
          <addressOffset>0x40101BB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 29</description>
          <addressOffset>0x40101BB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR29_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 29</description>
          <addressOffset>0x40101BBC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 30</description>
          <addressOffset>0x40101BC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 30</description>
          <addressOffset>0x40101BC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PING_CTL</name>
          <description>Descriptor 0 control register for channel 30</description>
          <addressOffset>0x40101BC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 30</description>
          <addressOffset>0x40101BCC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 30</description>
          <addressOffset>0x40101BD0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 30</description>
          <addressOffset>0x40101BD4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 30</description>
          <addressOffset>0x40101BD8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR30_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 30</description>
          <addressOffset>0x40101BDC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PING_SRC</name>
          <description>Descriptor 0 source address location for channel 31</description>
          <addressOffset>0x40101BE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PING_DST</name>
          <description>Descriptor 0 destination address location for channel 31</description>
          <addressOffset>0x40101BE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PING_CTL</name>
          <description>Descriptor 0 control register for channel 31</description>
          <addressOffset>0x40101BE8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PING_STATUS</name>
          <description>Descriptor 0 status register for channel 31</description>
          <addressOffset>0x40101BEC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PONG_SRC</name>
          <description>Descriptor 1 source address location for channel 31</description>
          <addressOffset>0x40101BF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SRC</name>
              <description>Source address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PONG_DST</name>
          <description>Descriptor 1 destination address location for channel 31</description>
          <addressOffset>0x40101BF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DST</name>
              <description>Destination address.</description>
              <lsb>0</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PONG_CTL</name>
          <description>Descriptor 1 control register for channel 31</description>
          <addressOffset>0x40101BF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Number of data elements this descriptor transfers. A value of N results in a transfer of N+1 data elements.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_SIZE</name>
              <description>Specifies the data element size.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>1 byte.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>Halfword (2 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the destination location.</description>
              <lsb>20</lsb>
              <msb>20</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DST_ADDR_INCR</name>
              <description>Specifies whether the destination address is incremented by the DST_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>21</lsb>
              <msb>21</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_DST_ADDR</name>
                  <description>Increment the destination address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_TRANSFER_SIZE</name>
              <description>Specifies the bus transfer size to the source location.</description>
              <lsb>22</lsb>
              <msb>22</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_SIZE</name>
                  <description>As specified by DATA_SIZE field.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>Word (4 bytes).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SRC_ADDR_INCR</name>
              <description>Specifies whether the source address is incremented by the SRC_TRANSFER_SIZE after the transfer of each data element.</description>
              <lsb>23</lsb>
              <msb>23</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INC_NONE</name>
                  <description>No address increment.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INC_SRC_ADDR</name>
                  <description>Increment the source address.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WAIT_FOR_DEACT</name>
              <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PULSE</name>
                  <description>Do not wait for de-activation (for pulse sensitive triggers).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_FOUR</name>
                  <description>Wait for up to 4 cycles.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_EIGHT</name>
                  <description>Wait for up to 8 cycles.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEVEL_UNKNOWN</name>
                  <description>Wait indefinitely. This option may result in DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INV_DESCR</name>
              <description>If set, the VALID bit of the descriptor's STATUS word is set to '0' on completion of the current descriptor structure.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_CAUSE</name>
              <description>If set, the interrupt bit of the channel is set to '1' on completion of the current descriptor structure.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>If set, the transfer is preemptable. Multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>FLIPPING</name>
              <description>If set, on completion of the current descriptor structure, the current descriptor identifier is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>OPCODE</name>
              <description>Specifies how the DMA reacts to a trigger event.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE_DATA_ELEMENT</name>
                  <description>A single trigger initiates a single data element transfer. This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR</name>
                  <description>A single trigger initiates an entire descriptor transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENTIRE_DESCRIPTOR_CHAIN</name>
                  <description>A single trigger initiates a descriptor list transfer. This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CHi_CTL.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_DESCR31_PONG_STATUS</name>
          <description>Descriptor 1 status register for channel 31</description>
          <addressOffset>0x40101BFC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Descriptor validity status. Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'. Software sets this field to '1' when a descriptor is initialized.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code and the interrupt cause bit is set to '1'.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VALID</name>
                  <description>Valid.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESONSE</name>
              <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).</description>
              <lsb>16</lsb>
              <msb>18</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_ERROR</name>
                  <description>No error. Setting this response does NOT set the interrupt bit to '1'. STATUS.VALID is NOT affected. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DONE</name>
                  <description>Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CHx_CTL.ENABLED is NOT affected. CHx_CTL.PING_PONG is updated if CONTROL.FLIPPING is '1'.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_BUS_ERROR</name>
                  <description>Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_BUS_ERROR</name>
                  <description>Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '1'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SRC_MISAL</name>
                  <description>Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DST_MISAL</name>
                  <description>Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INVALID</name>
                  <description>Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CHx_CTL.ENABLED is set to '0'. CHx_CTL.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CURR_DATA_NR</name>
              <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field: ? - When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.                                                                 ? - When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.                                                                 ? - In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.                                                                 ? HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'.                                                                 ? This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
              <lsb>0</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART_1</name>
      <description>UART</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RX_UART_1_RX_ADDRESS1</name>
          <description>RX Address1 Register</description>
          <addressOffset>0x400F0022</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>RX_UART_1_RX_ADDRESS2</name>
          <description>RX Address2 Register</description>
          <addressOffset>0x400F0032</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>RX_UART_1_RX_DATA</name>
          <description>RX Data Register</description>
          <addressOffset>0x400F0042</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>TX_UART_1_TX_DATA</name>
          <description>TX Data Register</description>
          <addressOffset>0x400F0044</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
        </register>
        <register>
          <name>RX_UART_1_RX_STATUS</name>
          <description>RX status register</description>
          <addressOffset>0x400F0062</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>UART_1_RX_STS_MRKSPC</name>
              <description>No description available</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_1_RX_STS_BREAK</name>
              <description>No description available</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_1_RX_STS_PAR_ERROR</name>
              <description>No description available</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_1_RX_STS_STOP_ERROR</name>
              <description>No description available</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_1_RX_STS_OVERRUN</name>
              <description>No description available</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_1_RX_STS_FIFO_NOTEMPTY</name>
              <description>No description available</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_1_RX_STS_ADDR_MATCH</name>
              <description>No description available</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_UART_1_TX_STATUS</name>
          <description>TX status register</description>
          <addressOffset>0x400F0064</addressOffset>
          <size>8</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>UART_1_TX_STS_COMPLETE</name>
              <description>No description available</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_1_TX_STS_FIFO_EMPTY</name>
              <description>No description available</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_1_TX_STS_FIFO_FULL</name>
              <description>No description available</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_1_TX_STS_FIFO_NOT_FULL</name>
              <description>No description available</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USBUART</name>
      <description>USBFS</description>
      <baseAddress>0x0</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CR0</name>
          <description>USB Control 0 Register</description>
          <addressOffset>0x402C0020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DEVICE_ADDRESS</name>
              <description>These bits specify the USB device address to which the SIE will respond. This address must be set by firmware and is specified by the USB Host with a SET ADDRESS command during USB enumeration. This value must be programmed by firmware when assigned during enumeration. It is not set automatically by the hardware.</description>
              <lsb>0</lsb>
              <msb>6</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>USB_ENABLE</name>
              <description>This bit enables the device to respond to USB traffic.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Block responds to USB traffic.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Block does not respond to USB traffic.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CR1</name>
          <description>USB Control 1 Register</description>
          <addressOffset>0x402C0024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>REG_ENABLE</name>
              <description>This bit controls the operation of the internal USB regulator. For applications with supply voltages in the 5V range this bit is set high to enable the internal regulator. For device supply voltage in the 3.3V range this bit is cleared to connect the transceiver directly to the supply.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Regulator for 5V is disabled.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Regulator for 5V is enabled.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE_LOCK</name>
              <description>This bit is set to turn on the automatic frequency locking of the internal oscillator to USB traffic.  Unless an external clock is being provided this bit should remain set for proper USB operation.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_ACTIVITY</name>
              <description>The Bus Activity bit is a stickybit that detects any non-idle USB event that has occurred on the USB bus. Once set to High by the SIE to indicate the bus activity this bit retains its logical High value until firmware clears it.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_OFFSET_MSB</name>
              <description>This bit enables trim bit[7].</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIE_EP_INT_EN</name>
          <description>USB SIE Data Endpoints Interrupt Enable Register</description>
          <addressOffset>0x402C0028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EP1_INTR_EN</name>
              <description>Enables interrupt for EP1.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP2_INTR_EN</name>
              <description>Enables interrupt for EP2.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP3_INTR_EN</name>
              <description>Enables interrupt for EP3.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP4_INTR_EN</name>
              <description>Enables interrupt for EP4.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP5_INTR_EN</name>
              <description>Enables interrupt for EP5.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP6_INTR_EN</name>
              <description>Enables interrupt for EP6.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP7_INTR_EN</name>
              <description>Enables interrupt for EP7.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP8_INTR_EN</name>
              <description>Enables interrupt for EP8.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIE_EP_INT_SR</name>
          <description>SIE Data Endpoint Interrupt Status Register</description>
          <addressOffset>0x402C002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EP1_INTR</name>
              <description>Interrupt status for EP1.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP2_INTR</name>
              <description>Interrupt status for EP2.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP3_INTR</name>
              <description>Interrupt status for EP3.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP4_INTR</name>
              <description>Interrupt status for EP4.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP5_INTR</name>
              <description>Interrupt status for EP5.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP6_INTR</name>
              <description>Interrupt status for EP6.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP7_INTR</name>
              <description>Interrupt status for EP7.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP8_INTR</name>
              <description>Interrupt status for EP8.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIE_EP1_CNT0</name>
          <description>SIE Endpoint 1 Count0 Register</description>
          <addressOffset>0x402C0030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_COUNT_MSB</name>
              <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_VALID</name>
              <description>DATA_ERROR - 0, DATA_VALID - 1.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_TOGGLE</name>
              <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIE_EP1_CNT1</name>
          <description>SIE Endpoint 1 Count1 Register</description>
          <addressOffset>0x402C0034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_COUNT</name>
              <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIE_EP1_CR0</name>
          <description>SIE Endpoint 1 Control Register</description>
          <addressOffset>0x402C0038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Ignore all USB traffic to this endpoint.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_INOUT</name>
                  <description>SETUP: Accept, IN: NAK, OUT: NAK.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STATUS_OUT_ONLY</name>
                  <description>SETUP: Accept, IN: STALL, OUT: ACK 0B tokens, NAK others.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STALL_INOUT</name>
                  <description>SETUP: Accept, IN: STALL, OUT: STALL.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ISO_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: Accept Isochronous OUT token.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STATUS_IN_ONLY</name>
                  <description>SETUP: Accept, IN: Respond with 0B data, OUT:  Stall.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ISO_IN</name>
                  <description>SETUP: Ignore, IN: Accept Isochronous IN token, OUT: Ignore.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: NAK.</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: Accept data and ACK if STALL = 0, STALL otherwise. Change to MODE=8 after one succesfull OUT token.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_OUT_STATUS_IN</name>
                  <description>SETUP: Accept, IN: Respond with 0B data, OUT:  Accept data.</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_IN</name>
                  <description>SETUP: Ignore, IN: NAK, OUT: Ignore.</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_IN</name>
                  <description>SETUP: Ignore, IN: Respond to IN with data if STALL=0, STALL otherwise, OUT: Ignore</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_IN_STATUS_OUT</name>
                  <description>SETUP: Accept, IN: Respond to IN with data, OUT: ACK 0B tokens, NAK others.</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACKED_TXN</name>
              <description>ACKED_NO - 0, ACKED_YES - 1.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NAK_INT_EN</name>
              <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_IN_TXN</name>
              <description>The Error in transaction bit is set whenever an error is detected.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STALL</name>
              <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBIO_CR0</name>
          <description>USBIO Control 0 Register</description>
          <addressOffset>0x402C0040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RD</name>
              <description>Received Data. This read only bit gives the state of the USB differential receiver.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIFF_LOW</name>
                  <description>D+ less than D- (K state), or D+=D-=0 (SE0).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIFF_HIGH</name>
                  <description>D+ greater than D- (J state).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TD</name>
              <description>Transmit Data. Transmit a USB J or K state on the USB bus. No effect if TEN=0 or TSE0=1.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIFF_K</name>
                  <description>Force USB K state (D+ is low D- is high).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIFF_J</name>
                  <description>Force USB J state (D+ is high D- is low).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSE0</name>
              <description>Transmit Single-Ended Zero. SE0: both D+ and D- low. No effect if TEN=0.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>TEN</name>
              <description>USB Transmit Enable. This is used to manually transmit on the D+ and D- pins. Normally this bit should be cleared to allow the internal SIE to drive the pins. The most common reason for manually transmitting is to force a resume state on the bus.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USBIO_CR1</name>
          <description>USBIO Control 1 Register</description>
          <addressOffset>0x402C0048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DMO</name>
              <description>This read only bit gives the state of the D- pin.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>DPO</name>
              <description>This read only bit gives the state of the D+ pin.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>USBPUEN</name>
              <description>This bit enables the connection of the internal 1.5 k pull up resistor on the D+ pin.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>IOMODE</name>
              <description>This bit allows the D+ and D- pins to be configured for either USB mode or bit-banged modes. If this bit is set the DMI and DPI bits are used to drive the D- and D+ pins.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Bit_banged</name>
                  <description>Bit-banged mode for Dm and Dp.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>USB</name>
                  <description>USB block controls Dm and Dp.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SIE_EP2_CNT0</name>
          <description>SIE Endpoint 1 Count0 Register</description>
          <addressOffset>0x402C0070</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_COUNT_MSB</name>
              <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_VALID</name>
              <description>DATA_ERROR - 0, DATA_VALID - 1.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_TOGGLE</name>
              <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIE_EP2_CNT1</name>
          <description>SIE Endpoint 1 Count1 Register</description>
          <addressOffset>0x402C0074</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_COUNT</name>
              <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIE_EP2_CR0</name>
          <description>SIE Endpoint 1 Control Register</description>
          <addressOffset>0x402C0078</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Ignore all USB traffic to this endpoint.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_INOUT</name>
                  <description>SETUP: Accept, IN: NAK, OUT: NAK.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STATUS_OUT_ONLY</name>
                  <description>SETUP: Accept, IN: STALL, OUT: ACK 0B tokens, NAK others.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STALL_INOUT</name>
                  <description>SETUP: Accept, IN: STALL, OUT: STALL.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ISO_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: Accept Isochronous OUT token.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STATUS_IN_ONLY</name>
                  <description>SETUP: Accept, IN: Respond with 0B data, OUT:  Stall.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ISO_IN</name>
                  <description>SETUP: Ignore, IN: Accept Isochronous IN token, OUT: Ignore.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: NAK.</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: Accept data and ACK if STALL = 0, STALL otherwise. Change to MODE=8 after one succesfull OUT token.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_OUT_STATUS_IN</name>
                  <description>SETUP: Accept, IN: Respond with 0B data, OUT:  Accept data.</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_IN</name>
                  <description>SETUP: Ignore, IN: NAK, OUT: Ignore.</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_IN</name>
                  <description>SETUP: Ignore, IN: Respond to IN with data if STALL=0, STALL otherwise, OUT: Ignore</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_IN_STATUS_OUT</name>
                  <description>SETUP: Accept, IN: Respond to IN with data, OUT: ACK 0B tokens, NAK others.</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACKED_TXN</name>
              <description>ACKED_NO - 0, ACKED_YES - 1.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NAK_INT_EN</name>
              <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_IN_TXN</name>
              <description>The Error in transaction bit is set whenever an error is detected.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STALL</name>
              <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EP0_CR</name>
          <description>Endpoint0 control Register</description>
          <addressOffset>0x402C00A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Ignore all USB traffic to this endpoint.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_INOUT</name>
                  <description>SETUP: Accept, IN: NAK, OUT: NAK.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STATUS_OUT_ONLY</name>
                  <description>SETUP: Accept, IN: STALL, OUT: ACK 0B tokens, NAK others.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STALL_INOUT</name>
                  <description>SETUP: Accept, IN: STALL, OUT: STALL.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ISO_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: Accept Isochronous OUT token.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STATUS_IN_ONLY</name>
                  <description>SETUP: Accept, IN: Respond with 0B data, OUT:  Stall.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ISO_IN</name>
                  <description>SETUP: Ignore, IN: Accept Isochronous IN token, OUT: Ignore.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: NAK.</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: Accept data and ACK if STALL = 0, STALL otherwise. Change to MODE=8 after one succesfull OUT token.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_OUT_STATUS_IN</name>
                  <description>SETUP: Accept, IN: Respond with 0B data, OUT:  Accept data.</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_IN</name>
                  <description>SETUP: Ignore, IN: NAK, OUT: Ignore.</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_IN</name>
                  <description>SETUP: Ignore, IN: Respond to IN with data if STALL=0, STALL otherwise, OUT: Ignore</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_IN_STATUS_OUT</name>
                  <description>SETUP: Accept, IN: Respond to IN with data, OUT: ACK 0B tokens, NAK others.</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACKED_TXN</name>
              <description>ACKED_NO - 0, ACKED_YES - 1.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NAK_INT_EN</name>
              <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_IN_TXN</name>
              <description>The Error in transaction bit is set whenever an error is detected.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STALL</name>
              <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EP0_CNT</name>
          <description>Endpoint0 control Register</description>
          <addressOffset>0x402C00A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>BYTE_COUNT</name>
              <description>These bits indicate the number of data bytes in a transaction. For IN transactions firmware loads the count with the number of bytes to be transmitted to the host from the endpoint FIFO. Valid values are 0 to 8. For OUT or SETUP transactions the count is updated by hardware to the number of data bytes received plus two for the CRC bytes. Valid values are 2 to 10.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_VALID</name>
              <description>This bit is used for OUT/SETUP transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DATA_ERROR</name>
                  <description>No ACK'd transactions since bit was last cleared.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DATA_VALID</name>
                  <description>Indicates a transaction ended with an ACK.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATA_TOGGLE</name>
              <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIE_EP3_CNT0</name>
          <description>SIE Endpoint 1 Count0 Register</description>
          <addressOffset>0x402C00B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_COUNT_MSB</name>
              <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
              <lsb>0</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_VALID</name>
              <description>DATA_ERROR - 0, DATA_VALID - 1.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA_TOGGLE</name>
              <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIE_EP3_CNT1</name>
          <description>SIE Endpoint 1 Count1 Register</description>
          <addressOffset>0x402C00B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>DATA_COUNT</name>
              <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SIE_EP3_CR0</name>
          <description>SIE Endpoint 1 Control Register</description>
          <addressOffset>0x402C00B8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>MODE</name>
              <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Ignore all USB traffic to this endpoint.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_INOUT</name>
                  <description>SETUP: Accept, IN: NAK, OUT: NAK.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STATUS_OUT_ONLY</name>
                  <description>SETUP: Accept, IN: STALL, OUT: ACK 0B tokens, NAK others.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STALL_INOUT</name>
                  <description>SETUP: Accept, IN: STALL, OUT: STALL.</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ISO_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: Accept Isochronous OUT token.</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STATUS_IN_ONLY</name>
                  <description>SETUP: Accept, IN: Respond with 0B data, OUT:  Stall.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ISO_IN</name>
                  <description>SETUP: Ignore, IN: Accept Isochronous IN token, OUT: Ignore.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: NAK.</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_OUT</name>
                  <description>SETUP: Ignore, IN: Ignore, OUT: Accept data and ACK if STALL = 0, STALL otherwise. Change to MODE=8 after one succesfull OUT token.</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_OUT_STATUS_IN</name>
                  <description>SETUP: Accept, IN: Respond with 0B data, OUT:  Accept data.</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NAK_IN</name>
                  <description>SETUP: Ignore, IN: NAK, OUT: Ignore.</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_IN</name>
                  <description>SETUP: Ignore, IN: Respond to IN with data if STALL=0, STALL otherwise, OUT: Ignore</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK_IN_STATUS_OUT</name>
                  <description>SETUP: Accept, IN: Respond to IN with data, OUT: ACK 0B tokens, NAK others.</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ACKED_TXN</name>
              <description>ACKED_NO - 0, ACKED_YES - 1.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>NAK_INT_EN</name>
              <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_IN_TXN</name>
              <description>The Error in transaction bit is set whenever an error is detected.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>STALL</name>
              <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_EP1_CFG</name>
          <description>Arbiter Endpoint 1 Configuration Register</description>
          <addressOffset>0x402C0200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>IN_DATA_RDY</name>
              <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_REQ</name>
              <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_BYPASS</name>
              <description>CRC_NORMAL - 0, CRC_BYPASS - 1</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PTR</name>
              <description>RESET_KRYPTON - 0, RESET_NORMAL - 1</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_EP1_INT_EN</name>
          <description>Arbiter Endpoint 1 Interrupt Enable Register</description>
          <addressOffset>0x402C0204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>IN_BUF_FULL_EN</name>
              <description>IN Endpoint Local Buffer Full</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_GNT_EN</name>
              <description>Endpoint DMA Grant</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_OVER_EN</name>
              <description>Endpoint Buffer Overflow</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_UNDER_EN</name>
              <description>Endpoint Buffer Underflow</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_INT_EN</name>
              <description>Endpoint Error in Transaction Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TERMIN_EN</name>
              <description>Endpoint DMA Terminated Enable</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_EP1_INT_SR</name>
          <description>Arbiter Endpoint 1 Interrupt Status Register</description>
          <addressOffset>0x402C0208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>IN_BUF_FULL_EN</name>
              <description>IN Endpoint Local Buffer Full</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_GNT_EN</name>
              <description>Endpoint DMA Grant</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_OVER_EN</name>
              <description>Endpoint Buffer Overflow</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_UNDER_EN</name>
              <description>Endpoint Buffer Underflow</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_INT_EN</name>
              <description>Endpoint Error in Transaction Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TERMIN_EN</name>
              <description>Endpoint DMA Terminated Enable</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW1_WA</name>
          <description>Arbiter Endpoint 1 Write Address LSB Register</description>
          <addressOffset>0x402C0210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WA8</name>
              <description>Write Address for EP.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW1_WA_MSB</name>
          <description>Arbiter Endpoint 1 Write Address MSB Register</description>
          <addressOffset>0x402C0214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WA9</name>
              <description>Write Address for EP MSB.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW1_RA</name>
          <description>Arbiter Endpoint 1 Read Address LSB Register</description>
          <addressOffset>0x402C0218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RA8</name>
              <description>Read Address for EP MSB.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW1_RA_MSB</name>
          <description>Arbiter Endpoint 1 Read Address MSB Register</description>
          <addressOffset>0x402C021C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RA9</name>
              <description>Read Address for EP MSB.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_EP2_CFG</name>
          <description>Arbiter Endpoint 1 Configuration Register</description>
          <addressOffset>0x402C0240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>IN_DATA_RDY</name>
              <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_REQ</name>
              <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_BYPASS</name>
              <description>CRC_NORMAL - 0, CRC_BYPASS - 1</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PTR</name>
              <description>RESET_KRYPTON - 0, RESET_NORMAL - 1</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_EP2_INT_EN</name>
          <description>Arbiter Endpoint 1 Interrupt Enable Register</description>
          <addressOffset>0x402C0244</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>IN_BUF_FULL_EN</name>
              <description>IN Endpoint Local Buffer Full</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_GNT_EN</name>
              <description>Endpoint DMA Grant</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_OVER_EN</name>
              <description>Endpoint Buffer Overflow</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_UNDER_EN</name>
              <description>Endpoint Buffer Underflow</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_INT_EN</name>
              <description>Endpoint Error in Transaction Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TERMIN_EN</name>
              <description>Endpoint DMA Terminated Enable</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_EP2_INT_SR</name>
          <description>Arbiter Endpoint 1 Interrupt Status Register</description>
          <addressOffset>0x402C0248</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>IN_BUF_FULL_EN</name>
              <description>IN Endpoint Local Buffer Full</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_GNT_EN</name>
              <description>Endpoint DMA Grant</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_OVER_EN</name>
              <description>Endpoint Buffer Overflow</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_UNDER_EN</name>
              <description>Endpoint Buffer Underflow</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_INT_EN</name>
              <description>Endpoint Error in Transaction Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TERMIN_EN</name>
              <description>Endpoint DMA Terminated Enable</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW2_WA</name>
          <description>Arbiter Endpoint 1 Write Address LSB Register</description>
          <addressOffset>0x402C0250</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WA8</name>
              <description>Write Address for EP.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW2_WA_MSB</name>
          <description>Arbiter Endpoint 1 Write Address MSB Register</description>
          <addressOffset>0x402C0254</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WA9</name>
              <description>Write Address for EP MSB.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW2_RA</name>
          <description>Arbiter Endpoint 1 Read Address LSB Register</description>
          <addressOffset>0x402C0258</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RA8</name>
              <description>Read Address for EP MSB.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW2_RA_MSB</name>
          <description>Arbiter Endpoint 1 Read Address MSB Register</description>
          <addressOffset>0x402C025C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RA9</name>
              <description>Read Address for EP MSB.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_CFG</name>
          <description>Arbiter configuration register</description>
          <addressOffset>0x402C0270</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>AUTO_MEM</name>
              <description>Enables Auto Memory Configuration.  Manual memory configuration by default.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_CFG</name>
              <description>DMA Access Configuration.</description>
              <lsb>5</lsb>
              <msb>6</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DMA_NONE</name>
                  <description>No DMA.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DMA_MANUAL</name>
                  <description>Manual DMA.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DMA_AUTO</name>
                  <description>Auto DMA.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CFG_CMP</name>
              <description>Register Configuration Complete Indication. Posedge is detected on this bit. Hence a 0 to 1 transition is required.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>USB_CLK_EN</name>
          <description>USB Control 0 Register</description>
          <addressOffset>0x402C0274</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>CSR_CLK_EN</name>
              <description>Clock Enable for Core Logic clocked by AHB bus clock.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disabled</name>
                  <description>Disables clock to UBS block.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enabled</name>
                  <description>Enables clock to UBS block.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_INT_EN</name>
          <description>Arbiter Interrupt Enable Register</description>
          <addressOffset>0x402C0278</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EP1_INTR_EN</name>
              <description>Enables interrupt for EP1.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP2_INTR_EN</name>
              <description>Enables interrupt for EP2.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP3_INTR_EN</name>
              <description>Enables interrupt for EP3.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP4_INTR_EN</name>
              <description>Enables interrupt for EP4.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP5_INTR_EN</name>
              <description>Enables interrupt for EP5.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP6_INTR_EN</name>
              <description>Enables interrupt for EP6.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP7_INTR_EN</name>
              <description>Enables interrupt for EP7.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP8_INTR_EN</name>
              <description>Enables interrupt for EP8.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_INT_SR</name>
          <description>Arbiter Interrupt Status</description>
          <addressOffset>0x402C027C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>EP1_INTR</name>
              <description>Interrupt status for EP1.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>EP2_INTR</name>
              <description>Interrupt status for EP2.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>EP3_INTR</name>
              <description>Interrupt status for EP3.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>EP4_INTR</name>
              <description>Interrupt status for EP4.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>EP5_INTR</name>
              <description>Interrupt status for EP5.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>EP6_INTR</name>
              <description>Interrupt status for EP6.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>EP7_INTR</name>
              <description>Interrupt status for EP7.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-only</access>
            </field>
            <field>
              <name>EP8_INTR</name>
              <description>Interrupt status for EP8.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_EP3_CFG</name>
          <description>Arbiter Endpoint 1 Configuration Register</description>
          <addressOffset>0x402C0280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>IN_DATA_RDY</name>
              <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_REQ</name>
              <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_BYPASS</name>
              <description>CRC_NORMAL - 0, CRC_BYPASS - 1</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PTR</name>
              <description>RESET_KRYPTON - 0, RESET_NORMAL - 1</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_EP3_INT_EN</name>
          <description>Arbiter Endpoint 1 Interrupt Enable Register</description>
          <addressOffset>0x402C0284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>IN_BUF_FULL_EN</name>
              <description>IN Endpoint Local Buffer Full</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_GNT_EN</name>
              <description>Endpoint DMA Grant</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_OVER_EN</name>
              <description>Endpoint Buffer Overflow</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_UNDER_EN</name>
              <description>Endpoint Buffer Underflow</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_INT_EN</name>
              <description>Endpoint Error in Transaction Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TERMIN_EN</name>
              <description>Endpoint DMA Terminated Enable</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_EP3_INT_SR</name>
          <description>Arbiter Endpoint 1 Interrupt Status Register</description>
          <addressOffset>0x402C0288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>IN_BUF_FULL_EN</name>
              <description>IN Endpoint Local Buffer Full</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_GNT_EN</name>
              <description>Endpoint DMA Grant</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_OVER_EN</name>
              <description>Endpoint Buffer Overflow</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_UNDER_EN</name>
              <description>Endpoint Buffer Underflow</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_INT_EN</name>
              <description>Endpoint Error in Transaction Interrupt</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TERMIN_EN</name>
              <description>Endpoint DMA Terminated Enable</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW3_WA</name>
          <description>Arbiter Endpoint 1 Write Address LSB Register</description>
          <addressOffset>0x402C0290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WA8</name>
              <description>Write Address for EP.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW3_WA_MSB</name>
          <description>Arbiter Endpoint 1 Write Address MSB Register</description>
          <addressOffset>0x402C0294</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>WA9</name>
              <description>Write Address for EP MSB.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW3_RA</name>
          <description>Arbiter Endpoint 1 Read Address LSB Register</description>
          <addressOffset>0x402C0298</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RA8</name>
              <description>Read Address for EP MSB.</description>
              <lsb>0</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ARB_RW3_RA_MSB</name>
          <description>Arbiter Endpoint 1 Read Address MSB Register</description>
          <addressOffset>0x402C029C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>RA9</name>
              <description>Read Address for EP MSB.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>POWER_CTRL</name>
          <description>Power Control Register</description>
          <addressOffset>0x402C2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>VBUS_VALID_OVR</name>
              <description>Overrides the value received from the GPIO input buffer connected to VBUS</description>
              <lsb>0</lsb>
              <msb>1</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FORCE_VALID_0</name>
                  <description>Force vbus_valid = 0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FORCE_VALID_1</name>
                  <description>Force vbus_valid = 1.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO_VALID</name>
                  <description>Use vbus_valid signal from GPIO input.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHY_VALID</name>
                  <description>Use vbus_valid signal from PHY detector.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUSPEND</name>
              <description>Put PHY into Suspend mode. If the PHY is enabled, this bit MUST be set before entering a low power mode (DeepSleep/Hibernate).</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND_DEL</name>
              <description>Delayed version of SUSPEND. Always set SUSPEND and SUSPEND_DEL together in a single register write.  When taking PHY out of suspend mode, first clear SUSPEND, then clear SUSPEND_DEL at least 2us later.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ISOLATE</name>
              <description>Isolates the PHY outputs. Clear this bit at least 2us after vbus is known to be valid (vbus_valid=1). Isolation will be forced when vbus_valid goes low (see VBUS_VALID_OVR).</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>CHDET_PWR_CTL</name>
              <description>Power programmability for bandgap voltage buffer in the charger detect block.  See s8bg_vrefbuf public cell for more information. Default '0' is low power mode.</description>
              <lsb>5</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_DM_PULLDOWN</name>
              <description>Enables the ~15k pull down on the DM, default off. The 15k pull down is needed for Data Contact Detection (DCD).</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_VBUS_PULLDOWN</name>
              <description>Enables the weak pull down on the VBUS, default on, to prevent floating node crow bar currents.</description>
              <lsb>26</lsb>
              <msb>26</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_RCVR</name>
              <description>Enables the differential USB receiver.</description>
              <lsb>27</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_DPO</name>
              <description>Enables the single ended receiver on D+.</description>
              <lsb>28</lsb>
              <msb>28</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_DMO</name>
              <description>Enables the signle ended receiver on D-.</description>
              <lsb>29</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_CHGDET</name>
              <description>Enables the charger detection circuitry.  After USB has connected, this circuitry can be disabled to save power.</description>
              <lsb>30</lsb>
              <msb>30</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Mast enable of PHY and Charger Detector.  Nothing will work until this bit is set.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHGDET_CTRL</name>
          <description>Charger Detection Control Register</description>
          <addressOffset>0x402C2004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>COMP_DP</name>
              <description>Connect the primary/secondary detection comparator and current sink  to D+.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_DM</name>
              <description>Connect the primary/secondary detection comparator and current sink to D-.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_EN</name>
              <description>Enable the primary/secondary detection comparator and current sink. This bit can be written concurrently with COMP_DP/COMP_DM.  Note that REF_EN must also be 1 for the comparator to work (because it receives a reference from it).</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_DP</name>
              <description>Connect the primary/secondary detection reference driver to D+.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_DM</name>
              <description>Connect the primary/secondary detection reference driver to D-.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_EN</name>
              <description>Enable the primary/secondary reference driver.  This bit can be written concurrently with REF_DP/REF_DM.</description>
              <lsb>5</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>DCD_SRC_EN</name>
              <description>Enable the Data Contact Detect current source on D+.</description>
              <lsb>6</lsb>
              <msb>6</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ADFT_CTRL</name>
              <description>ADFT option to bring out buffered version of voltage reference input or adft intput to ADFT output (adft_out).</description>
              <lsb>12</lsb>
              <msb>13</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADFT_NORMAL</name>
                  <description>Normal operating mode, reference buffer used to generate internal references.  adft_out pulled low.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADFT_VBG</name>
                  <description>Use reference buffer to bring out voltage reference input (vbg) onto adft_out.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADFT_DONTUSE</name>
                  <description>Illegal - do not use.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADFT_ADFTIN</name>
                  <description>Use reference buffer to bring out buffered version of system level adft input (adft_in) onto adft_out.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMP_OUT</name>
              <description>Output of the primary/secondary detection comparator.  This output is not filtered or debounced and must be polled in software.</description>
              <lsb>31</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPM_CTRL</name>
          <description>LPM Control Register</description>
          <addressOffset>0x402C2010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>LPM_EN</name>
              <description>LPM enable.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Disable</name>
                  <description>LPM token will not get a response (backward compatibility mode).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Enable</name>
                  <description>LPM token will get a handshake response (ACK, STALL, NYET or NAK). A STALL will be sent if the bLinkState is not 0001b. A NYET, NAK or ACK response will be sent depending on the NYET_EN and LPM_ACK_RESP bits below.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_ACK_RESP</name>
              <description>LPM ACK response enable (if LPM_EN=1), to allow firmware to refuse a low power request.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NYET_NACK</name>
                  <description>A LPM token will get a NYET or NAK (depending on NYET_EN bit below) response and the device will NOT go to a low power mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACK</name>
                  <description>A LPM token will get an ACK response and the device will go to the requested low power mode.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NYET_EN</name>
              <description>Allow firmware to choose which response to use for an LPM token (LPM_EN=1) when the device is NOT ready to go to the requested low power mode (LPM_ACK_RESP=0).</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NYET</name>
                  <description>A LPM token will get an NAK response (indicating a CRC error),  the host is expected to repeat the LPM token.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NACK</name>
                  <description>A LPM token will get a NYET response.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SUB_RESP</name>
              <description>Enable a STALL response for all undefined SubPIDs, i.e. other than LPM (0011b). If not enabled then there will be no response (Error) for the undefined SubPIDs.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LPM_STAT</name>
          <description>LPM Status register</description>
          <addressOffset>0x402C2014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>LPM_BESL</name>
              <description>Best Effort Service Latency. This value should match either the Baseline (DeepSleep) or Deep (Hibernate) BESL in the BOS descriptor.</description>
              <lsb>0</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_REMOTEWAKE</name>
              <description>LPM ACK response enable (if LPM_EN=1), to allow firmware to refuse a low power request.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>Prohibited</name>
                  <description>Device is prohibited from initiating a remote wake.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>Allowed</name>
                  <description>Device is allow to wake the host.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>Cy_INTR_SIE</name>
          <description>USB SOF, BUS RESET and EP0 Interrupt Status</description>
          <addressOffset>0x402C2020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SOF_INTR</name>
              <description>USB SOF Interrupt.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_RESET_INTR</name>
              <description>BUS RESET Interrupt.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP0_INTR</name>
              <description>EP0 Interrupt.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_INTR</name>
              <description>LPM Interrupt.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESUME_INTR</name>
              <description>Resume Interrupt.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SIE_MASK</name>
          <description>USB SOF, BUS RESET and EP0 Interrupt Mask</description>
          <addressOffset>0x402C2028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SOF_INTR</name>
              <description>USB SOF Interrupt.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_RESET_INTR</name>
              <description>BUS RESET Interrupt.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP0_INTR</name>
              <description>EP0 Interrupt.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_INTR</name>
              <description>LPM Interrupt.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESUME_INTR</name>
              <description>Resume Interrupt.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_LVL_SEL</name>
          <description>Select interrupt level for each interrupt source</description>
          <addressOffset>0x402C2030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SOF_LVL_SEL</name>
              <description>USB SOF Interrupt level select.</description>
              <lsb>0</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_RESET_LVL_SEL</name>
              <description>BUS RESET Interrupt level select.</description>
              <lsb>2</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP0_LVL_SEL</name>
              <description>EP0 Interrupt level select.</description>
              <lsb>4</lsb>
              <msb>5</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_LVL_SEL</name>
              <description>LPM Interrupt level select.</description>
              <lsb>6</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESUME_LVL_SEL</name>
              <description>Resume Interrupt level select.</description>
              <lsb>8</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB_EP_LVL_SEL</name>
              <description>Arbiter Endpoint Interrupt level select.</description>
              <lsb>14</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP1_LVL_SEL</name>
              <description>EP1 Interrupt level select.</description>
              <lsb>16</lsb>
              <msb>17</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP2_LVL_SEL</name>
              <description>EP2 Interrupt level select.</description>
              <lsb>18</lsb>
              <msb>19</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP3_LVL_SEL</name>
              <description>EP3 Interrupt level select.</description>
              <lsb>20</lsb>
              <msb>21</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP4_LVL_SEL</name>
              <description>EP4 Interrupt level select.</description>
              <lsb>22</lsb>
              <msb>23</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP5_LVL_SEL</name>
              <description>EP5 Interrupt level select.</description>
              <lsb>24</lsb>
              <msb>25</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP6_LVL_SEL</name>
              <description>EP6 Interrupt level select.</description>
              <lsb>26</lsb>
              <msb>27</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP7_LVL_SEL</name>
              <description>EP7 Interrupt level select.</description>
              <lsb>28</lsb>
              <msb>29</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP8_LVL_SEL</name>
              <description>EP8 Interrupt level select.</description>
              <lsb>30</lsb>
              <msb>31</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE_HIGH</name>
          <description>High priority interrupt Cause register</description>
          <addressOffset>0x402C2034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SOF_INTR</name>
              <description>USB SOF Interrupt.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_RESET_INTR</name>
              <description>BUS RESET Interrupt.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP0_INTR</name>
              <description>EP0 Interrupt.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_INTR</name>
              <description>LPM Interrupt.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESUME_INTR</name>
              <description>Resume Interrupt.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB_EP_INTR</name>
              <description>Arbiter Endpoint Interrupt.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP1_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP2_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP3_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP4_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP5_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP6_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP7_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP8_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE_MED</name>
          <description>Medium priority interrupt Cause register</description>
          <addressOffset>0x402C2038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SOF_INTR</name>
              <description>USB SOF Interrupt.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_RESET_INTR</name>
              <description>BUS RESET Interrupt.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP0_INTR</name>
              <description>EP0 Interrupt.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_INTR</name>
              <description>LPM Interrupt.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESUME_INTR</name>
              <description>Resume Interrupt.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB_EP_INTR</name>
              <description>Arbiter Endpoint Interrupt.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP1_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP2_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP3_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP4_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP5_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP6_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP7_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP8_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE_LO</name>
          <description>Low priority interrupt Cause register</description>
          <addressOffset>0x402C203C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0</resetValue>
          <resetMask>0</resetMask>
          <fields>
            <field>
              <name>SOF_INTR</name>
              <description>USB SOF Interrupt.</description>
              <lsb>0</lsb>
              <msb>0</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>BUS_RESET_INTR</name>
              <description>BUS RESET Interrupt.</description>
              <lsb>1</lsb>
              <msb>1</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP0_INTR</name>
              <description>EP0 Interrupt.</description>
              <lsb>2</lsb>
              <msb>2</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_INTR</name>
              <description>LPM Interrupt.</description>
              <lsb>3</lsb>
              <msb>3</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>RESUME_INTR</name>
              <description>Resume Interrupt.</description>
              <lsb>4</lsb>
              <msb>4</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB_EP_INTR</name>
              <description>Arbiter Endpoint Interrupt.</description>
              <lsb>7</lsb>
              <msb>7</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP1_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>8</lsb>
              <msb>8</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP2_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>9</lsb>
              <msb>9</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP3_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>10</lsb>
              <msb>10</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP4_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>11</lsb>
              <msb>11</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP5_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>12</lsb>
              <msb>12</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP6_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>13</lsb>
              <msb>13</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP7_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>14</lsb>
              <msb>14</msb>
              <access>read-write</access>
            </field>
            <field>
              <name>EP8_INTR</name>
              <description>EP1 Interrupt.</description>
              <lsb>15</lsb>
              <msb>15</msb>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>